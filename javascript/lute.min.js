"use strict";
(function() {

Error.stackTraceLimit = Infinity;

var $global, $module;
if (typeof window !== "undefined") { /* web page */
  $global = window;
} else if (typeof self !== "undefined") { /* web worker */
  $global = self;
} else if (typeof global !== "undefined") { /* Node.js */
  $global = global;
  $global.require = require;
} else { /* others (e.g. Nashorn) */
  $global = this;
}

if ($global === undefined || $global.Array === undefined) {
  throw new Error("no global object found");
}
if (typeof module !== "undefined") {
  $module = module;
}

var $packages = {}, $idCounter = 0;
var $keys = function(m) { return m ? Object.keys(m) : []; };
var $flushConsole = function() {};
var $throwRuntimeError; /* set by package "runtime" */
var $throwNilPointerError = function() { $throwRuntimeError("invalid memory address or nil pointer dereference"); };
var $call = function(fn, rcvr, args) { return fn.apply(rcvr, args); };
var $makeFunc = function(fn) { return function() { return $externalize(fn(this, new ($sliceType($jsObjectPtr))($global.Array.prototype.slice.call(arguments, []))), $emptyInterface); }; };
var $unused = function(v) {};

var $mapArray = function(array, f) {
  var newArray = new array.constructor(array.length);
  for (var i = 0; i < array.length; i++) {
    newArray[i] = f(array[i]);
  }
  return newArray;
};

var $methodVal = function(recv, name) {
  var vals = recv.$methodVals || {};
  recv.$methodVals = vals; /* noop for primitives */
  var f = vals[name];
  if (f !== undefined) {
    return f;
  }
  var method = recv[name];
  f = function() {
    $stackDepthOffset--;
    try {
      return method.apply(recv, arguments);
    } finally {
      $stackDepthOffset++;
    }
  };
  vals[name] = f;
  return f;
};

var $methodExpr = function(typ, name) {
  var method = typ.prototype[name];
  if (method.$expr === undefined) {
    method.$expr = function() {
      $stackDepthOffset--;
      try {
        if (typ.wrapped) {
          arguments[0] = new typ(arguments[0]);
        }
        return Function.call.apply(method, arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return method.$expr;
};

var $ifaceMethodExprs = {};
var $ifaceMethodExpr = function(name) {
  var expr = $ifaceMethodExprs["$" + name];
  if (expr === undefined) {
    expr = $ifaceMethodExprs["$" + name] = function() {
      $stackDepthOffset--;
      try {
        return Function.call.apply(arguments[0][name], arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return expr;
};

var $subslice = function(slice, low, high, max) {
  if (high === undefined) {
    high = slice.$length;
  }
  if (max === undefined) {
    max = slice.$capacity;
  }
  if (low < 0 || high < low || max < high || high > slice.$capacity || max > slice.$capacity) {
    $throwRuntimeError("slice bounds out of range");
  }
  if (slice === slice.constructor.nil) {
    return slice;
  }
  var s = new slice.constructor(slice.$array);
  s.$offset = slice.$offset + low;
  s.$length = high - low;
  s.$capacity = max - low;
  return s;
};

var $substring = function(str, low, high) {
  if (low < 0 || high < low || high > str.length) {
    $throwRuntimeError("slice bounds out of range");
  }
  return str.substring(low, high);
};

var $sliceToArray = function(slice) {
  if (slice.$array.constructor !== Array) {
    return slice.$array.subarray(slice.$offset, slice.$offset + slice.$length);
  }
  return slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
};

var $decodeRune = function(str, pos) {
  var c0 = str.charCodeAt(pos);

  if (c0 < 0x80) {
    return [c0, 1];
  }

  if (c0 !== c0 || c0 < 0xC0) {
    return [0xFFFD, 1];
  }

  var c1 = str.charCodeAt(pos + 1);
  if (c1 !== c1 || c1 < 0x80 || 0xC0 <= c1) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xE0) {
    var r = (c0 & 0x1F) << 6 | (c1 & 0x3F);
    if (r <= 0x7F) {
      return [0xFFFD, 1];
    }
    return [r, 2];
  }

  var c2 = str.charCodeAt(pos + 2);
  if (c2 !== c2 || c2 < 0x80 || 0xC0 <= c2) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF0) {
    var r = (c0 & 0x0F) << 12 | (c1 & 0x3F) << 6 | (c2 & 0x3F);
    if (r <= 0x7FF) {
      return [0xFFFD, 1];
    }
    if (0xD800 <= r && r <= 0xDFFF) {
      return [0xFFFD, 1];
    }
    return [r, 3];
  }

  var c3 = str.charCodeAt(pos + 3);
  if (c3 !== c3 || c3 < 0x80 || 0xC0 <= c3) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF8) {
    var r = (c0 & 0x07) << 18 | (c1 & 0x3F) << 12 | (c2 & 0x3F) << 6 | (c3 & 0x3F);
    if (r <= 0xFFFF || 0x10FFFF < r) {
      return [0xFFFD, 1];
    }
    return [r, 4];
  }

  return [0xFFFD, 1];
};

var $encodeRune = function(r) {
  if (r < 0 || r > 0x10FFFF || (0xD800 <= r && r <= 0xDFFF)) {
    r = 0xFFFD;
  }
  if (r <= 0x7F) {
    return String.fromCharCode(r);
  }
  if (r <= 0x7FF) {
    return String.fromCharCode(0xC0 | r >> 6, 0x80 | (r & 0x3F));
  }
  if (r <= 0xFFFF) {
    return String.fromCharCode(0xE0 | r >> 12, 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
  }
  return String.fromCharCode(0xF0 | r >> 18, 0x80 | (r >> 12 & 0x3F), 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
};

var $stringToBytes = function(str) {
  var array = new Uint8Array(str.length);
  for (var i = 0; i < str.length; i++) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

var $bytesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i += 10000) {
    str += String.fromCharCode.apply(undefined, slice.$array.subarray(slice.$offset + i, slice.$offset + Math.min(slice.$length, i + 10000)));
  }
  return str;
};

var $stringToRunes = function(str) {
  var array = new Int32Array(str.length);
  var rune, j = 0;
  for (var i = 0; i < str.length; i += rune[1], j++) {
    rune = $decodeRune(str, i);
    array[j] = rune[0];
  }
  return array.subarray(0, j);
};

var $runesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i++) {
    str += $encodeRune(slice.$array[slice.$offset + i]);
  }
  return str;
};

var $copyString = function(dst, src) {
  var n = Math.min(src.length, dst.$length);
  for (var i = 0; i < n; i++) {
    dst.$array[dst.$offset + i] = src.charCodeAt(i);
  }
  return n;
};

var $copySlice = function(dst, src) {
  var n = Math.min(src.$length, dst.$length);
  $copyArray(dst.$array, src.$array, dst.$offset, src.$offset, n, dst.constructor.elem);
  return n;
};

var $copyArray = function(dst, src, dstOffset, srcOffset, n, elem) {
  if (n === 0 || (dst === src && dstOffset === srcOffset)) {
    return;
  }

  if (src.subarray) {
    dst.set(src.subarray(srcOffset, srcOffset + n), dstOffset);
    return;
  }

  switch (elem.kind) {
  case $kindArray:
  case $kindStruct:
    if (dst === src && dstOffset > srcOffset) {
      for (var i = n - 1; i >= 0; i--) {
        elem.copy(dst[dstOffset + i], src[srcOffset + i]);
      }
      return;
    }
    for (var i = 0; i < n; i++) {
      elem.copy(dst[dstOffset + i], src[srcOffset + i]);
    }
    return;
  }

  if (dst === src && dstOffset > srcOffset) {
    for (var i = n - 1; i >= 0; i--) {
      dst[dstOffset + i] = src[srcOffset + i];
    }
    return;
  }
  for (var i = 0; i < n; i++) {
    dst[dstOffset + i] = src[srcOffset + i];
  }
};

var $clone = function(src, type) {
  var clone = type.zero();
  type.copy(clone, src);
  return clone;
};

var $pointerOfStructConversion = function(obj, type) {
  if(obj.$proxies === undefined) {
    obj.$proxies = {};
    obj.$proxies[obj.constructor.string] = obj;
  }
  var proxy = obj.$proxies[type.string];
  if (proxy === undefined) {
    var properties = {};
    for (var i = 0; i < type.elem.fields.length; i++) {
      (function(fieldProp) {
        properties[fieldProp] = {
          get: function() { return obj[fieldProp]; },
          set: function(value) { obj[fieldProp] = value; }
        };
      })(type.elem.fields[i].prop);
    }
    proxy = Object.create(type.prototype, properties);
    proxy.$val = proxy;
    obj.$proxies[type.string] = proxy;
    proxy.$proxies = obj.$proxies;
  }
  return proxy;
};

var $append = function(slice) {
  return $internalAppend(slice, arguments, 1, arguments.length - 1);
};

var $appendSlice = function(slice, toAppend) {
  if (toAppend.constructor === String) {
    var bytes = $stringToBytes(toAppend);
    return $internalAppend(slice, bytes, 0, bytes.length);
  }
  return $internalAppend(slice, toAppend.$array, toAppend.$offset, toAppend.$length);
};

var $internalAppend = function(slice, array, offset, length) {
  if (length === 0) {
    return slice;
  }

  var newArray = slice.$array;
  var newOffset = slice.$offset;
  var newLength = slice.$length + length;
  var newCapacity = slice.$capacity;

  if (newLength > newCapacity) {
    newOffset = 0;
    newCapacity = Math.max(newLength, slice.$capacity < 1024 ? slice.$capacity * 2 : Math.floor(slice.$capacity * 5 / 4));

    if (slice.$array.constructor === Array) {
      newArray = slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
      newArray.length = newCapacity;
      var zero = slice.constructor.elem.zero;
      for (var i = slice.$length; i < newCapacity; i++) {
        newArray[i] = zero();
      }
    } else {
      newArray = new slice.$array.constructor(newCapacity);
      newArray.set(slice.$array.subarray(slice.$offset, slice.$offset + slice.$length));
    }
  }

  $copyArray(newArray, array, newOffset + slice.$length, offset, length, slice.constructor.elem);

  var newSlice = new slice.constructor(newArray);
  newSlice.$offset = newOffset;
  newSlice.$length = newLength;
  newSlice.$capacity = newCapacity;
  return newSlice;
};

var $equal = function(a, b, type) {
  if (type === $jsObjectPtr) {
    return a === b;
  }
  switch (type.kind) {
  case $kindComplex64:
  case $kindComplex128:
    return a.$real === b.$real && a.$imag === b.$imag;
  case $kindInt64:
  case $kindUint64:
    return a.$high === b.$high && a.$low === b.$low;
  case $kindArray:
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!$equal(a[i], b[i], type.elem)) {
        return false;
      }
    }
    return true;
  case $kindStruct:
    for (var i = 0; i < type.fields.length; i++) {
      var f = type.fields[i];
      if (!$equal(a[f.prop], b[f.prop], f.typ)) {
        return false;
      }
    }
    return true;
  case $kindInterface:
    return $interfaceIsEqual(a, b);
  default:
    return a === b;
  }
};

var $interfaceIsEqual = function(a, b) {
  if (a === $ifaceNil || b === $ifaceNil) {
    return a === b;
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a.constructor === $jsObjectPtr) {
    return a.object === b.object;
  }
  if (!a.constructor.comparable) {
    $throwRuntimeError("comparing uncomparable type " + a.constructor.string);
  }
  return $equal(a.$val, b.$val, a.constructor);
};

var $min = Math.min;
var $mod = function(x, y) { return x % y; };
var $parseInt = parseInt;
var $parseFloat = function(f) {
  if (f !== undefined && f !== null && f.constructor === Number) {
    return f;
  }
  return parseFloat(f);
};

var $froundBuf = new Float32Array(1);
var $fround = Math.fround || function(f) {
  $froundBuf[0] = f;
  return $froundBuf[0];
};

var $imul = Math.imul || function(a, b) {
  var ah = (a >>> 16) & 0xffff;
  var al = a & 0xffff;
  var bh = (b >>> 16) & 0xffff;
  var bl = b & 0xffff;
  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) >> 0);
};

var $floatKey = function(f) {
  if (f !== f) {
    $idCounter++;
    return "NaN$" + $idCounter;
  }
  return String(f);
};

var $flatten64 = function(x) {
  return x.$high * 4294967296 + x.$low;
};

var $shiftLeft64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high << y | x.$low >>> (32 - y), (x.$low << y) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$low << (y - 32), 0);
  }
  return new x.constructor(0, 0);
};

var $shiftRightInt64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$high >> 31, (x.$high >> (y - 32)) >>> 0);
  }
  if (x.$high < 0) {
    return new x.constructor(-1, 4294967295);
  }
  return new x.constructor(0, 0);
};

var $shiftRightUint64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >>> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(0, x.$high >>> (y - 32));
  }
  return new x.constructor(0, 0);
};

var $mul64 = function(x, y) {
  var high = 0, low = 0;
  if ((y.$low & 1) !== 0) {
    high = x.$high;
    low = x.$low;
  }
  for (var i = 1; i < 32; i++) {
    if ((y.$low & 1<<i) !== 0) {
      high += x.$high << i | x.$low >>> (32 - i);
      low += (x.$low << i) >>> 0;
    }
  }
  for (var i = 0; i < 32; i++) {
    if ((y.$high & 1<<i) !== 0) {
      high += x.$low << i;
    }
  }
  return new x.constructor(high, low);
};

var $div64 = function(x, y, returnRemainder) {
  if (y.$high === 0 && y.$low === 0) {
    $throwRuntimeError("integer divide by zero");
  }

  var s = 1;
  var rs = 1;

  var xHigh = x.$high;
  var xLow = x.$low;
  if (xHigh < 0) {
    s = -1;
    rs = -1;
    xHigh = -xHigh;
    if (xLow !== 0) {
      xHigh--;
      xLow = 4294967296 - xLow;
    }
  }

  var yHigh = y.$high;
  var yLow = y.$low;
  if (y.$high < 0) {
    s *= -1;
    yHigh = -yHigh;
    if (yLow !== 0) {
      yHigh--;
      yLow = 4294967296 - yLow;
    }
  }

  var high = 0, low = 0, n = 0;
  while (yHigh < 2147483648 && ((xHigh > yHigh) || (xHigh === yHigh && xLow > yLow))) {
    yHigh = (yHigh << 1 | yLow >>> 31) >>> 0;
    yLow = (yLow << 1) >>> 0;
    n++;
  }
  for (var i = 0; i <= n; i++) {
    high = high << 1 | low >>> 31;
    low = (low << 1) >>> 0;
    if ((xHigh > yHigh) || (xHigh === yHigh && xLow >= yLow)) {
      xHigh = xHigh - yHigh;
      xLow = xLow - yLow;
      if (xLow < 0) {
        xHigh--;
        xLow += 4294967296;
      }
      low++;
      if (low === 4294967296) {
        high++;
        low = 0;
      }
    }
    yLow = (yLow >>> 1 | yHigh << (32 - 1)) >>> 0;
    yHigh = yHigh >>> 1;
  }

  if (returnRemainder) {
    return new x.constructor(xHigh * rs, xLow * rs);
  }
  return new x.constructor(high * s, low * s);
};

var $divComplex = function(n, d) {
  var ninf = n.$real === Infinity || n.$real === -Infinity || n.$imag === Infinity || n.$imag === -Infinity;
  var dinf = d.$real === Infinity || d.$real === -Infinity || d.$imag === Infinity || d.$imag === -Infinity;
  var nnan = !ninf && (n.$real !== n.$real || n.$imag !== n.$imag);
  var dnan = !dinf && (d.$real !== d.$real || d.$imag !== d.$imag);
  if(nnan || dnan) {
    return new n.constructor(NaN, NaN);
  }
  if (ninf && !dinf) {
    return new n.constructor(Infinity, Infinity);
  }
  if (!ninf && dinf) {
    return new n.constructor(0, 0);
  }
  if (d.$real === 0 && d.$imag === 0) {
    if (n.$real === 0 && n.$imag === 0) {
      return new n.constructor(NaN, NaN);
    }
    return new n.constructor(Infinity, Infinity);
  }
  var a = Math.abs(d.$real);
  var b = Math.abs(d.$imag);
  if (a <= b) {
    var ratio = d.$real / d.$imag;
    var denom = d.$real * ratio + d.$imag;
    return new n.constructor((n.$real * ratio + n.$imag) / denom, (n.$imag * ratio - n.$real) / denom);
  }
  var ratio = d.$imag / d.$real;
  var denom = d.$imag * ratio + d.$real;
  return new n.constructor((n.$imag * ratio + n.$real) / denom, (n.$imag - n.$real * ratio) / denom);
};

var $kindBool = 1;
var $kindInt = 2;
var $kindInt8 = 3;
var $kindInt16 = 4;
var $kindInt32 = 5;
var $kindInt64 = 6;
var $kindUint = 7;
var $kindUint8 = 8;
var $kindUint16 = 9;
var $kindUint32 = 10;
var $kindUint64 = 11;
var $kindUintptr = 12;
var $kindFloat32 = 13;
var $kindFloat64 = 14;
var $kindComplex64 = 15;
var $kindComplex128 = 16;
var $kindArray = 17;
var $kindChan = 18;
var $kindFunc = 19;
var $kindInterface = 20;
var $kindMap = 21;
var $kindPtr = 22;
var $kindSlice = 23;
var $kindString = 24;
var $kindStruct = 25;
var $kindUnsafePointer = 26;

var $methodSynthesizers = [];
var $addMethodSynthesizer = function(f) {
  if ($methodSynthesizers === null) {
    f();
    return;
  }
  $methodSynthesizers.push(f);
};
var $synthesizeMethods = function() {
  $methodSynthesizers.forEach(function(f) { f(); });
  $methodSynthesizers = null;
};

var $ifaceKeyFor = function(x) {
  if (x === $ifaceNil) {
    return 'nil';
  }
  var c = x.constructor;
  return c.string + '$' + c.keyFor(x.$val);
};

var $identity = function(x) { return x; };

var $typeIDCounter = 0;

var $idKey = function(x) {
  if (x.$id === undefined) {
    $idCounter++;
    x.$id = $idCounter;
  }
  return String(x.$id);
};

var $newType = function(size, kind, string, named, pkg, exported, constructor) {
  var typ;
  switch(kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $identity;
    break;

  case $kindString:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return "$" + x; };
    break;

  case $kindFloat32:
  case $kindFloat64:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return $floatKey(x); };
    break;

  case $kindInt64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindUint64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >>> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindComplex64:
    typ = function(real, imag) {
      this.$real = $fround(real);
      this.$imag = $fround(imag);
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindComplex128:
    typ = function(real, imag) {
      this.$real = real;
      this.$imag = imag;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindArray:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, "", false, function(array) {
      this.$get = function() { return array; };
      this.$set = function(v) { typ.copy(this, v); };
      this.$val = array;
    });
    typ.init = function(elem, len) {
      typ.elem = elem;
      typ.len = len;
      typ.comparable = elem.comparable;
      typ.keyFor = function(x) {
        return Array.prototype.join.call($mapArray(x, function(e) {
          return String(elem.keyFor(e)).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }), "$");
      };
      typ.copy = function(dst, src) {
        $copyArray(dst, src, 0, 0, src.length, elem);
      };
      typ.ptr.init(typ);
      Object.defineProperty(typ.ptr.nil, "nilCheck", { get: $throwNilPointerError });
    };
    break;

  case $kindChan:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $idKey;
    typ.init = function(elem, sendOnly, recvOnly) {
      typ.elem = elem;
      typ.sendOnly = sendOnly;
      typ.recvOnly = recvOnly;
    };
    break;

  case $kindFunc:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(params, results, variadic) {
      typ.params = params;
      typ.results = results;
      typ.variadic = variadic;
      typ.comparable = false;
    };
    break;

  case $kindInterface:
    typ = { implementedBy: {}, missingMethodFor: {} };
    typ.keyFor = $ifaceKeyFor;
    typ.init = function(methods) {
      typ.methods = methods;
      methods.forEach(function(m) {
        $ifaceNil[m.prop] = $throwNilPointerError;
      });
    };
    break;

  case $kindMap:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(key, elem) {
      typ.key = key;
      typ.elem = elem;
      typ.comparable = false;
    };
    break;

  case $kindPtr:
    typ = constructor || function(getter, setter, target) {
      this.$get = getter;
      this.$set = setter;
      this.$target = target;
      this.$val = this;
    };
    typ.keyFor = $idKey;
    typ.init = function(elem) {
      typ.elem = elem;
      typ.wrapped = (elem.kind === $kindArray);
      typ.nil = new typ($throwNilPointerError, $throwNilPointerError);
    };
    break;

  case $kindSlice:
    typ = function(array) {
      if (array.constructor !== typ.nativeArray) {
        array = new typ.nativeArray(array);
      }
      this.$array = array;
      this.$offset = 0;
      this.$length = array.length;
      this.$capacity = array.length;
      this.$val = this;
    };
    typ.init = function(elem) {
      typ.elem = elem;
      typ.comparable = false;
      typ.nativeArray = $nativeArray(elem.kind);
      typ.nil = new typ([]);
    };
    break;

  case $kindStruct:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, pkg, exported, constructor);
    typ.ptr.elem = typ;
    typ.ptr.prototype.$get = function() { return this; };
    typ.ptr.prototype.$set = function(v) { typ.copy(this, v); };
    typ.init = function(pkgPath, fields) {
      typ.pkgPath = pkgPath;
      typ.fields = fields;
      fields.forEach(function(f) {
        if (!f.typ.comparable) {
          typ.comparable = false;
        }
      });
      typ.keyFor = function(x) {
        var val = x.$val;
        return $mapArray(fields, function(f) {
          return String(f.typ.keyFor(val[f.prop])).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }).join("$");
      };
      typ.copy = function(dst, src) {
        for (var i = 0; i < fields.length; i++) {
          var f = fields[i];
          switch (f.typ.kind) {
          case $kindArray:
          case $kindStruct:
            f.typ.copy(dst[f.prop], src[f.prop]);
            continue;
          default:
            dst[f.prop] = src[f.prop];
            continue;
          }
        }
      };
      /* nil value */
      var properties = {};
      fields.forEach(function(f) {
        properties[f.prop] = { get: $throwNilPointerError, set: $throwNilPointerError };
      });
      typ.ptr.nil = Object.create(constructor.prototype, properties);
      typ.ptr.nil.$val = typ.ptr.nil;
      /* methods for embedded fields */
      $addMethodSynthesizer(function() {
        var synthesizeMethod = function(target, m, f) {
          if (target.prototype[m.prop] !== undefined) { return; }
          target.prototype[m.prop] = function() {
            var v = this.$val[f.prop];
            if (f.typ === $jsObjectPtr) {
              v = new $jsObjectPtr(v);
            }
            if (v.$val === undefined) {
              v = new f.typ(v);
            }
            return v[m.prop].apply(v, arguments);
          };
        };
        fields.forEach(function(f) {
          if (f.embedded) {
            $methodSet(f.typ).forEach(function(m) {
              synthesizeMethod(typ, m, f);
              synthesizeMethod(typ.ptr, m, f);
            });
            $methodSet($ptrType(f.typ)).forEach(function(m) {
              synthesizeMethod(typ.ptr, m, f);
            });
          }
        });
      });
    };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  switch (kind) {
  case $kindBool:
  case $kindMap:
    typ.zero = function() { return false; };
    break;

  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8 :
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
  case $kindFloat32:
  case $kindFloat64:
    typ.zero = function() { return 0; };
    break;

  case $kindString:
    typ.zero = function() { return ""; };
    break;

  case $kindInt64:
  case $kindUint64:
  case $kindComplex64:
  case $kindComplex128:
    var zero = new typ(0, 0);
    typ.zero = function() { return zero; };
    break;

  case $kindPtr:
  case $kindSlice:
    typ.zero = function() { return typ.nil; };
    break;

  case $kindChan:
    typ.zero = function() { return $chanNil; };
    break;

  case $kindFunc:
    typ.zero = function() { return $throwNilPointerError; };
    break;

  case $kindInterface:
    typ.zero = function() { return $ifaceNil; };
    break;

  case $kindArray:
    typ.zero = function() {
      var arrayClass = $nativeArray(typ.elem.kind);
      if (arrayClass !== Array) {
        return new arrayClass(typ.len);
      }
      var array = new Array(typ.len);
      for (var i = 0; i < typ.len; i++) {
        array[i] = typ.elem.zero();
      }
      return array;
    };
    break;

  case $kindStruct:
    typ.zero = function() { return new typ.ptr(); };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  typ.id = $typeIDCounter;
  $typeIDCounter++;
  typ.size = size;
  typ.kind = kind;
  typ.string = string;
  typ.named = named;
  typ.pkg = pkg;
  typ.exported = exported;
  typ.methods = [];
  typ.methodSetCache = null;
  typ.comparable = true;
  return typ;
};

var $methodSet = function(typ) {
  if (typ.methodSetCache !== null) {
    return typ.methodSetCache;
  }
  var base = {};

  var isPtr = (typ.kind === $kindPtr);
  if (isPtr && typ.elem.kind === $kindInterface) {
    typ.methodSetCache = [];
    return [];
  }

  var current = [{typ: isPtr ? typ.elem : typ, indirect: isPtr}];

  var seen = {};

  while (current.length > 0) {
    var next = [];
    var mset = [];

    current.forEach(function(e) {
      if (seen[e.typ.string]) {
        return;
      }
      seen[e.typ.string] = true;

      if (e.typ.named) {
        mset = mset.concat(e.typ.methods);
        if (e.indirect) {
          mset = mset.concat($ptrType(e.typ).methods);
        }
      }

      switch (e.typ.kind) {
      case $kindStruct:
        e.typ.fields.forEach(function(f) {
          if (f.embedded) {
            var fTyp = f.typ;
            var fIsPtr = (fTyp.kind === $kindPtr);
            next.push({typ: fIsPtr ? fTyp.elem : fTyp, indirect: e.indirect || fIsPtr});
          }
        });
        break;

      case $kindInterface:
        mset = mset.concat(e.typ.methods);
        break;
      }
    });

    mset.forEach(function(m) {
      if (base[m.name] === undefined) {
        base[m.name] = m;
      }
    });

    current = next;
  }

  typ.methodSetCache = [];
  Object.keys(base).sort().forEach(function(name) {
    typ.methodSetCache.push(base[name]);
  });
  return typ.methodSetCache;
};

var $Bool          = $newType( 1, $kindBool,          "bool",           true, "", false, null);
var $Int           = $newType( 4, $kindInt,           "int",            true, "", false, null);
var $Int8          = $newType( 1, $kindInt8,          "int8",           true, "", false, null);
var $Int16         = $newType( 2, $kindInt16,         "int16",          true, "", false, null);
var $Int32         = $newType( 4, $kindInt32,         "int32",          true, "", false, null);
var $Int64         = $newType( 8, $kindInt64,         "int64",          true, "", false, null);
var $Uint          = $newType( 4, $kindUint,          "uint",           true, "", false, null);
var $Uint8         = $newType( 1, $kindUint8,         "uint8",          true, "", false, null);
var $Uint16        = $newType( 2, $kindUint16,        "uint16",         true, "", false, null);
var $Uint32        = $newType( 4, $kindUint32,        "uint32",         true, "", false, null);
var $Uint64        = $newType( 8, $kindUint64,        "uint64",         true, "", false, null);
var $Uintptr       = $newType( 4, $kindUintptr,       "uintptr",        true, "", false, null);
var $Float32       = $newType( 4, $kindFloat32,       "float32",        true, "", false, null);
var $Float64       = $newType( 8, $kindFloat64,       "float64",        true, "", false, null);
var $Complex64     = $newType( 8, $kindComplex64,     "complex64",      true, "", false, null);
var $Complex128    = $newType(16, $kindComplex128,    "complex128",     true, "", false, null);
var $String        = $newType( 8, $kindString,        "string",         true, "", false, null);
var $UnsafePointer = $newType( 4, $kindUnsafePointer, "unsafe.Pointer", true, "", false, null);

var $nativeArray = function(elemKind) {
  switch (elemKind) {
  case $kindInt:
    return Int32Array;
  case $kindInt8:
    return Int8Array;
  case $kindInt16:
    return Int16Array;
  case $kindInt32:
    return Int32Array;
  case $kindUint:
    return Uint32Array;
  case $kindUint8:
    return Uint8Array;
  case $kindUint16:
    return Uint16Array;
  case $kindUint32:
    return Uint32Array;
  case $kindUintptr:
    return Uint32Array;
  case $kindFloat32:
    return Float32Array;
  case $kindFloat64:
    return Float64Array;
  default:
    return Array;
  }
};
var $toNativeArray = function(elemKind, array) {
  var nativeArray = $nativeArray(elemKind);
  if (nativeArray === Array) {
    return array;
  }
  return new nativeArray(array);
};
var $arrayTypes = {};
var $arrayType = function(elem, len) {
  var typeKey = elem.id + "$" + len;
  var typ = $arrayTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(12, $kindArray, "[" + len + "]" + elem.string, false, "", false, null);
    $arrayTypes[typeKey] = typ;
    typ.init(elem, len);
  }
  return typ;
};

var $chanType = function(elem, sendOnly, recvOnly) {
  var string = (recvOnly ? "<-" : "") + "chan" + (sendOnly ? "<- " : " ") + elem.string;
  var field = sendOnly ? "SendChan" : (recvOnly ? "RecvChan" : "Chan");
  var typ = elem[field];
  if (typ === undefined) {
    typ = $newType(4, $kindChan, string, false, "", false, null);
    elem[field] = typ;
    typ.init(elem, sendOnly, recvOnly);
  }
  return typ;
};
var $Chan = function(elem, capacity) {
  if (capacity < 0 || capacity > 2147483647) {
    $throwRuntimeError("makechan: size out of range");
  }
  this.$elem = elem;
  this.$capacity = capacity;
  this.$buffer = [];
  this.$sendQueue = [];
  this.$recvQueue = [];
  this.$closed = false;
};
var $chanNil = new $Chan(null, 0);
$chanNil.$sendQueue = $chanNil.$recvQueue = { length: 0, push: function() {}, shift: function() { return undefined; }, indexOf: function() { return -1; } };

var $funcTypes = {};
var $funcType = function(params, results, variadic) {
  var typeKey = $mapArray(params, function(p) { return p.id; }).join(",") + "$" + $mapArray(results, function(r) { return r.id; }).join(",") + "$" + variadic;
  var typ = $funcTypes[typeKey];
  if (typ === undefined) {
    var paramTypes = $mapArray(params, function(p) { return p.string; });
    if (variadic) {
      paramTypes[paramTypes.length - 1] = "..." + paramTypes[paramTypes.length - 1].substr(2);
    }
    var string = "func(" + paramTypes.join(", ") + ")";
    if (results.length === 1) {
      string += " " + results[0].string;
    } else if (results.length > 1) {
      string += " (" + $mapArray(results, function(r) { return r.string; }).join(", ") + ")";
    }
    typ = $newType(4, $kindFunc, string, false, "", false, null);
    $funcTypes[typeKey] = typ;
    typ.init(params, results, variadic);
  }
  return typ;
};

var $interfaceTypes = {};
var $interfaceType = function(methods) {
  var typeKey = $mapArray(methods, function(m) { return m.pkg + "," + m.name + "," + m.typ.id; }).join("$");
  var typ = $interfaceTypes[typeKey];
  if (typ === undefined) {
    var string = "interface {}";
    if (methods.length !== 0) {
      string = "interface { " + $mapArray(methods, function(m) {
        return (m.pkg !== "" ? m.pkg + "." : "") + m.name + m.typ.string.substr(4);
      }).join("; ") + " }";
    }
    typ = $newType(8, $kindInterface, string, false, "", false, null);
    $interfaceTypes[typeKey] = typ;
    typ.init(methods);
  }
  return typ;
};
var $emptyInterface = $interfaceType([]);
var $ifaceNil = {};
var $error = $newType(8, $kindInterface, "error", true, "", false, null);
$error.init([{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}]);

var $mapTypes = {};
var $mapType = function(key, elem) {
  var typeKey = key.id + "$" + elem.id;
  var typ = $mapTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(4, $kindMap, "map[" + key.string + "]" + elem.string, false, "", false, null);
    $mapTypes[typeKey] = typ;
    typ.init(key, elem);
  }
  return typ;
};
var $makeMap = function(keyForFunc, entries) {
  var m = {};
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    m[keyForFunc(e.k)] = e;
  }
  return m;
};

var $ptrType = function(elem) {
  var typ = elem.ptr;
  if (typ === undefined) {
    typ = $newType(4, $kindPtr, "*" + elem.string, false, "", elem.exported, null);
    elem.ptr = typ;
    typ.init(elem);
  }
  return typ;
};

var $newDataPointer = function(data, constructor) {
  if (constructor.elem.kind === $kindStruct) {
    return data;
  }
  return new constructor(function() { return data; }, function(v) { data = v; });
};

var $indexPtr = function(array, index, constructor) {
  array.$ptr = array.$ptr || {};
  return array.$ptr[index] || (array.$ptr[index] = new constructor(function() { return array[index]; }, function(v) { array[index] = v; }));
};

var $sliceType = function(elem) {
  var typ = elem.slice;
  if (typ === undefined) {
    typ = $newType(12, $kindSlice, "[]" + elem.string, false, "", false, null);
    elem.slice = typ;
    typ.init(elem);
  }
  return typ;
};
var $makeSlice = function(typ, length, capacity) {
  capacity = capacity || length;
  if (length < 0 || length > 2147483647) {
    $throwRuntimeError("makeslice: len out of range");
  }
  if (capacity < 0 || capacity < length || capacity > 2147483647) {
    $throwRuntimeError("makeslice: cap out of range");
  }
  var array = new typ.nativeArray(capacity);
  if (typ.nativeArray === Array) {
    for (var i = 0; i < capacity; i++) {
      array[i] = typ.elem.zero();
    }
  }
  var slice = new typ(array);
  slice.$length = length;
  return slice;
};

var $structTypes = {};
var $structType = function(pkgPath, fields) {
  var typeKey = $mapArray(fields, function(f) { return f.name + "," + f.typ.id + "," + f.tag; }).join("$");
  var typ = $structTypes[typeKey];
  if (typ === undefined) {
    var string = "struct { " + $mapArray(fields, function(f) {
      return f.name + " " + f.typ.string + (f.tag !== "" ? (" \"" + f.tag.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"") : "");
    }).join("; ") + " }";
    if (fields.length === 0) {
      string = "struct {}";
    }
    typ = $newType(0, $kindStruct, string, false, "", false, function() {
      this.$val = this;
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        var arg = arguments[i];
        this[f.prop] = arg !== undefined ? arg : f.typ.zero();
      }
    });
    $structTypes[typeKey] = typ;
    typ.init(pkgPath, fields);
  }
  return typ;
};

var $assertType = function(value, type, returnTuple) {
  var isInterface = (type.kind === $kindInterface), ok, missingMethod = "";
  if (value === $ifaceNil) {
    ok = false;
  } else if (!isInterface) {
    ok = value.constructor === type;
  } else {
    var valueTypeString = value.constructor.string;
    ok = type.implementedBy[valueTypeString];
    if (ok === undefined) {
      ok = true;
      var valueMethodSet = $methodSet(value.constructor);
      var interfaceMethods = type.methods;
      for (var i = 0; i < interfaceMethods.length; i++) {
        var tm = interfaceMethods[i];
        var found = false;
        for (var j = 0; j < valueMethodSet.length; j++) {
          var vm = valueMethodSet[j];
          if (vm.name === tm.name && vm.pkg === tm.pkg && vm.typ === tm.typ) {
            found = true;
            break;
          }
        }
        if (!found) {
          ok = false;
          type.missingMethodFor[valueTypeString] = tm.name;
          break;
        }
      }
      type.implementedBy[valueTypeString] = ok;
    }
    if (!ok) {
      missingMethod = type.missingMethodFor[valueTypeString];
    }
  }

  if (!ok) {
    if (returnTuple) {
      return [type.zero(), false];
    }
    $panic(new $packages["runtime"].TypeAssertionError.ptr(
      $packages["runtime"]._type.ptr.nil,
      (value === $ifaceNil ? $packages["runtime"]._type.ptr.nil : new $packages["runtime"]._type.ptr(value.constructor.string)),
      new $packages["runtime"]._type.ptr(type.string),
      missingMethod));
  }

  if (!isInterface) {
    value = value.$val;
  }
  if (type === $jsObjectPtr) {
    value = value.object;
  }
  return returnTuple ? [value, true] : value;
};

var $stackDepthOffset = 0;
var $getStackDepth = function() {
  var err = new Error();
  if (err.stack === undefined) {
    return undefined;
  }
  return $stackDepthOffset + err.stack.split("\n").length;
};

var $panicStackDepth = null, $panicValue;
var $callDeferred = function(deferred, jsErr, fromPanic) {
  if (!fromPanic && deferred !== null && deferred.index >= $curGoroutine.deferStack.length) {
    throw jsErr;
  }
  if (jsErr !== null) {
    var newErr = null;
    try {
      $curGoroutine.deferStack.push(deferred);
      $panic(new $jsErrorPtr(jsErr));
    } catch (err) {
      newErr = err;
    }
    $curGoroutine.deferStack.pop();
    $callDeferred(deferred, newErr);
    return;
  }
  if ($curGoroutine.asleep) {
    return;
  }

  $stackDepthOffset--;
  var outerPanicStackDepth = $panicStackDepth;
  var outerPanicValue = $panicValue;

  var localPanicValue = $curGoroutine.panicStack.pop();
  if (localPanicValue !== undefined) {
    $panicStackDepth = $getStackDepth();
    $panicValue = localPanicValue;
  }

  try {
    while (true) {
      if (deferred === null) {
        deferred = $curGoroutine.deferStack[$curGoroutine.deferStack.length - 1];
        if (deferred === undefined) {
          /* The panic reached the top of the stack. Clear it and throw it as a JavaScript error. */
          $panicStackDepth = null;
          if (localPanicValue.Object instanceof Error) {
            throw localPanicValue.Object;
          }
          var msg;
          if (localPanicValue.constructor === $String) {
            msg = localPanicValue.$val;
          } else if (localPanicValue.Error !== undefined) {
            msg = localPanicValue.Error();
          } else if (localPanicValue.String !== undefined) {
            msg = localPanicValue.String();
          } else {
            msg = localPanicValue;
          }
          throw new Error(msg);
        }
      }
      var call = deferred.pop();
      if (call === undefined) {
        $curGoroutine.deferStack.pop();
        if (localPanicValue !== undefined) {
          deferred = null;
          continue;
        }
        return;
      }
      var r = call[0].apply(call[2], call[1]);
      if (r && r.$blk !== undefined) {
        deferred.push([r.$blk, [], r]);
        if (fromPanic) {
          throw null;
        }
        return;
      }

      if (localPanicValue !== undefined && $panicStackDepth === null) {
        throw null; /* error was recovered */
      }
    }
  } finally {
    if (localPanicValue !== undefined) {
      if ($panicStackDepth !== null) {
        $curGoroutine.panicStack.push(localPanicValue);
      }
      $panicStackDepth = outerPanicStackDepth;
      $panicValue = outerPanicValue;
    }
    $stackDepthOffset++;
  }
};

var $panic = function(value) {
  $curGoroutine.panicStack.push(value);
  $callDeferred(null, null, true);
};
var $recover = function() {
  if ($panicStackDepth === null || ($panicStackDepth !== undefined && $panicStackDepth !== $getStackDepth() - 2)) {
    return $ifaceNil;
  }
  $panicStackDepth = null;
  return $panicValue;
};
var $throw = function(err) { throw err; };

var $noGoroutine = { asleep: false, exit: false, deferStack: [], panicStack: [] };
var $curGoroutine = $noGoroutine, $totalGoroutines = 0, $awakeGoroutines = 0, $checkForDeadlock = true;
var $mainFinished = false;
var $go = function(fun, args) {
  $totalGoroutines++;
  $awakeGoroutines++;
  var $goroutine = function() {
    try {
      $curGoroutine = $goroutine;
      var r = fun.apply(undefined, args);
      if (r && r.$blk !== undefined) {
        fun = function() { return r.$blk(); };
        args = [];
        return;
      }
      $goroutine.exit = true;
    } catch (err) {
      if (!$goroutine.exit) {
        throw err;
      }
    } finally {
      $curGoroutine = $noGoroutine;
      if ($goroutine.exit) { /* also set by runtime.Goexit() */
        $totalGoroutines--;
        $goroutine.asleep = true;
      }
      if ($goroutine.asleep) {
        $awakeGoroutines--;
        if (!$mainFinished && $awakeGoroutines === 0 && $checkForDeadlock) {
          console.error("fatal error: all goroutines are asleep - deadlock!");
          if ($global.process !== undefined) {
            $global.process.exit(2);
          }
        }
      }
    }
  };
  $goroutine.asleep = false;
  $goroutine.exit = false;
  $goroutine.deferStack = [];
  $goroutine.panicStack = [];
  $schedule($goroutine);
};

var $scheduled = [];
var $runScheduled = function() {
  try {
    var r;
    while ((r = $scheduled.shift()) !== undefined) {
      r();
    }
  } finally {
    if ($scheduled.length > 0) {
      setTimeout($runScheduled, 0);
    }
  }
};

var $schedule = function(goroutine) {
  if (goroutine.asleep) {
    goroutine.asleep = false;
    $awakeGoroutines++;
  }
  $scheduled.push(goroutine);
  if ($curGoroutine === $noGoroutine) {
    $runScheduled();
  }
};

var $setTimeout = function(f, t) {
  $awakeGoroutines++;
  return setTimeout(function() {
    $awakeGoroutines--;
    f();
  }, t);
};

var $block = function() {
  if ($curGoroutine === $noGoroutine) {
    $throwRuntimeError("cannot block in JavaScript callback, fix by wrapping code in goroutine");
  }
  $curGoroutine.asleep = true;
};

var $send = function(chan, value) {
  if (chan.$closed) {
    $throwRuntimeError("send on closed channel");
  }
  var queuedRecv = chan.$recvQueue.shift();
  if (queuedRecv !== undefined) {
    queuedRecv([value, true]);
    return;
  }
  if (chan.$buffer.length < chan.$capacity) {
    chan.$buffer.push(value);
    return;
  }

  var thisGoroutine = $curGoroutine;
  var closedDuringSend;
  chan.$sendQueue.push(function(closed) {
    closedDuringSend = closed;
    $schedule(thisGoroutine);
    return value;
  });
  $block();
  return {
    $blk: function() {
      if (closedDuringSend) {
        $throwRuntimeError("send on closed channel");
      }
    }
  };
};
var $recv = function(chan) {
  var queuedSend = chan.$sendQueue.shift();
  if (queuedSend !== undefined) {
    chan.$buffer.push(queuedSend(false));
  }
  var bufferedValue = chan.$buffer.shift();
  if (bufferedValue !== undefined) {
    return [bufferedValue, true];
  }
  if (chan.$closed) {
    return [chan.$elem.zero(), false];
  }

  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.value; } };
  var queueEntry = function(v) {
    f.value = v;
    $schedule(thisGoroutine);
  };
  chan.$recvQueue.push(queueEntry);
  $block();
  return f;
};
var $close = function(chan) {
  if (chan.$closed) {
    $throwRuntimeError("close of closed channel");
  }
  chan.$closed = true;
  while (true) {
    var queuedSend = chan.$sendQueue.shift();
    if (queuedSend === undefined) {
      break;
    }
    queuedSend(true); /* will panic */
  }
  while (true) {
    var queuedRecv = chan.$recvQueue.shift();
    if (queuedRecv === undefined) {
      break;
    }
    queuedRecv([chan.$elem.zero(), false]);
  }
};
var $select = function(comms) {
  var ready = [];
  var selection = -1;
  for (var i = 0; i < comms.length; i++) {
    var comm = comms[i];
    var chan = comm[0];
    switch (comm.length) {
    case 0: /* default */
      selection = i;
      break;
    case 1: /* recv */
      if (chan.$sendQueue.length !== 0 || chan.$buffer.length !== 0 || chan.$closed) {
        ready.push(i);
      }
      break;
    case 2: /* send */
      if (chan.$closed) {
        $throwRuntimeError("send on closed channel");
      }
      if (chan.$recvQueue.length !== 0 || chan.$buffer.length < chan.$capacity) {
        ready.push(i);
      }
      break;
    }
  }

  if (ready.length !== 0) {
    selection = ready[Math.floor(Math.random() * ready.length)];
  }
  if (selection !== -1) {
    var comm = comms[selection];
    switch (comm.length) {
    case 0: /* default */
      return [selection];
    case 1: /* recv */
      return [selection, $recv(comm[0])];
    case 2: /* send */
      $send(comm[0], comm[1]);
      return [selection];
    }
  }

  var entries = [];
  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.selection; } };
  var removeFromQueues = function() {
    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];
      var queue = entry[0];
      var index = queue.indexOf(entry[1]);
      if (index !== -1) {
        queue.splice(index, 1);
      }
    }
  };
  for (var i = 0; i < comms.length; i++) {
    (function(i) {
      var comm = comms[i];
      switch (comm.length) {
      case 1: /* recv */
        var queueEntry = function(value) {
          f.selection = [i, value];
          removeFromQueues();
          $schedule(thisGoroutine);
        };
        entries.push([comm[0].$recvQueue, queueEntry]);
        comm[0].$recvQueue.push(queueEntry);
        break;
      case 2: /* send */
        var queueEntry = function() {
          if (comm[0].$closed) {
            $throwRuntimeError("send on closed channel");
          }
          f.selection = [i];
          removeFromQueues();
          $schedule(thisGoroutine);
          return comm[1];
        };
        entries.push([comm[0].$sendQueue, queueEntry]);
        comm[0].$sendQueue.push(queueEntry);
        break;
      }
    })(i);
  }
  $block();
  return f;
};

var $jsObjectPtr, $jsErrorPtr;

var $needsExternalization = function(t) {
  switch (t.kind) {
    case $kindBool:
    case $kindInt:
    case $kindInt8:
    case $kindInt16:
    case $kindInt32:
    case $kindUint:
    case $kindUint8:
    case $kindUint16:
    case $kindUint32:
    case $kindUintptr:
    case $kindFloat32:
    case $kindFloat64:
      return false;
    default:
      return t !== $jsObjectPtr;
  }
};

var $externalize = function(v, t) {
  if (t === $jsObjectPtr) {
    return v;
  }
  switch (t.kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindFloat32:
  case $kindFloat64:
    return v;
  case $kindInt64:
  case $kindUint64:
    return $flatten64(v);
  case $kindArray:
    if ($needsExternalization(t.elem)) {
      return $mapArray(v, function(e) { return $externalize(e, t.elem); });
    }
    return v;
  case $kindFunc:
    return $externalizeFunction(v, t, false);
  case $kindInterface:
    if (v === $ifaceNil) {
      return null;
    }
    if (v.constructor === $jsObjectPtr) {
      return v.$val.object;
    }
    return $externalize(v.$val, v.constructor);
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var entry = v[keys[i]];
      m[$externalize(entry.k, t.key)] = $externalize(entry.v, t.elem);
    }
    return m;
  case $kindPtr:
    if (v === t.nil) {
      return null;
    }
    return $externalize(v.$get(), t.elem);
  case $kindSlice:
    if ($needsExternalization(t.elem)) {
      return $mapArray($sliceToArray(v), function(e) { return $externalize(e, t.elem); });
    }
    return $sliceToArray(v);
  case $kindString:
    if ($isASCII(v)) {
      return v;
    }
    var s = "", r;
    for (var i = 0; i < v.length; i += r[1]) {
      r = $decodeRune(v, i);
      var c = r[0];
      if (c > 0xFFFF) {
        var h = Math.floor((c - 0x10000) / 0x400) + 0xD800;
        var l = (c - 0x10000) % 0x400 + 0xDC00;
        s += String.fromCharCode(h, l);
        continue;
      }
      s += String.fromCharCode(c);
    }
    return s;
  case $kindStruct:
    var timePkg = $packages["time"];
    if (timePkg !== undefined && v.constructor === timePkg.Time.ptr) {
      var milli = $div64(v.UnixNano(), new $Int64(0, 1000000));
      return new Date($flatten64(milli));
    }

    var noJsObject = {};
    var searchJsObject = function(v, t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      switch (t.kind) {
      case $kindPtr:
        if (v === t.nil) {
          return noJsObject;
        }
        return searchJsObject(v.$get(), t.elem);
      case $kindStruct:
        var f = t.fields[0];
        return searchJsObject(v[f.prop], f.typ);
      case $kindInterface:
        return searchJsObject(v.$val, v.constructor);
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(v, t);
    if (o !== noJsObject) {
      return o;
    }

    o = {};
    for (var i = 0; i < t.fields.length; i++) {
      var f = t.fields[i];
      if (!f.exported) {
        continue;
      }
      o[f.name] = $externalize(v[f.prop], f.typ);
    }
    return o;
  }
  $throwRuntimeError("cannot externalize " + t.string);
};

var $externalizeFunction = function(v, t, passThis) {
  if (v === $throwNilPointerError) {
    return null;
  }
  if (v.$externalizeWrapper === undefined) {
    $checkForDeadlock = false;
    v.$externalizeWrapper = function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = [];
          for (var j = i; j < arguments.length; j++) {
            varargs.push($internalize(arguments[j], vt));
          }
          args.push(new (t.params[i])(varargs));
          break;
        }
        args.push($internalize(arguments[i], t.params[i]));
      }
      var result = v.apply(passThis ? this : undefined, args);
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $externalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $externalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  }
  return v.$externalizeWrapper;
};

var $internalize = function(v, t, recv) {
  if (t === $jsObjectPtr) {
    return v;
  }
  if (t === $jsObjectPtr.elem) {
    $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
  }
  if (v && v.__internal_object__ !== undefined) {
    return $assertType(v.__internal_object__, t, false);
  }
  var timePkg = $packages["time"];
  if (timePkg !== undefined && t === timePkg.Time) {
    if (!(v !== null && v !== undefined && v.constructor === Date)) {
      $throwRuntimeError("cannot internalize time.Time from " + typeof v + ", must be Date");
    }
    return timePkg.Unix(new $Int64(0, 0), new $Int64(0, v.getTime() * 1000000));
  }
  switch (t.kind) {
  case $kindBool:
    return !!v;
  case $kindInt:
    return parseInt(v);
  case $kindInt8:
    return parseInt(v) << 24 >> 24;
  case $kindInt16:
    return parseInt(v) << 16 >> 16;
  case $kindInt32:
    return parseInt(v) >> 0;
  case $kindUint:
    return parseInt(v);
  case $kindUint8:
    return parseInt(v) << 24 >>> 24;
  case $kindUint16:
    return parseInt(v) << 16 >>> 16;
  case $kindUint32:
  case $kindUintptr:
    return parseInt(v) >>> 0;
  case $kindInt64:
  case $kindUint64:
    return new t(0, v);
  case $kindFloat32:
  case $kindFloat64:
    return parseFloat(v);
  case $kindArray:
    if (v.length !== t.len) {
      $throwRuntimeError("got array with wrong size from JavaScript native");
    }
    return $mapArray(v, function(e) { return $internalize(e, t.elem); });
  case $kindFunc:
    return function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = arguments[i];
          for (var j = 0; j < varargs.$length; j++) {
            args.push($externalize(varargs.$array[varargs.$offset + j], vt));
          }
          break;
        }
        args.push($externalize(arguments[i], t.params[i]));
      }
      var result = v.apply(recv, args);
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $internalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $internalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  case $kindInterface:
    if (t.methods.length !== 0) {
      $throwRuntimeError("cannot internalize " + t.string);
    }
    if (v === null) {
      return $ifaceNil;
    }
    if (v === undefined) {
      return new $jsObjectPtr(undefined);
    }
    switch (v.constructor) {
    case Int8Array:
      return new ($sliceType($Int8))(v);
    case Int16Array:
      return new ($sliceType($Int16))(v);
    case Int32Array:
      return new ($sliceType($Int))(v);
    case Uint8Array:
      return new ($sliceType($Uint8))(v);
    case Uint16Array:
      return new ($sliceType($Uint16))(v);
    case Uint32Array:
      return new ($sliceType($Uint))(v);
    case Float32Array:
      return new ($sliceType($Float32))(v);
    case Float64Array:
      return new ($sliceType($Float64))(v);
    case Array:
      return $internalize(v, $sliceType($emptyInterface));
    case Boolean:
      return new $Bool(!!v);
    case Date:
      if (timePkg === undefined) {
        /* time package is not present, internalize as &js.Object{Date} so it can be externalized into original Date. */
        return new $jsObjectPtr(v);
      }
      return new timePkg.Time($internalize(v, timePkg.Time));
    case Function:
      var funcType = $funcType([$sliceType($emptyInterface)], [$jsObjectPtr], true);
      return new funcType($internalize(v, funcType));
    case Number:
      return new $Float64(parseFloat(v));
    case String:
      return new $String($internalize(v, $String));
    default:
      if ($global.Node && v instanceof $global.Node) {
        return new $jsObjectPtr(v);
      }
      var mapType = $mapType($String, $emptyInterface);
      return new mapType($internalize(v, mapType));
    }
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var k = $internalize(keys[i], t.key);
      m[t.key.keyFor(k)] = { k: k, v: $internalize(v[keys[i]], t.elem) };
    }
    return m;
  case $kindPtr:
    if (t.elem.kind === $kindStruct) {
      return $internalize(v, t.elem);
    }
  case $kindSlice:
    return new t($mapArray(v, function(e) { return $internalize(e, t.elem); }));
  case $kindString:
    v = String(v);
    if ($isASCII(v)) {
      return v;
    }
    var s = "";
    var i = 0;
    while (i < v.length) {
      var h = v.charCodeAt(i);
      if (0xD800 <= h && h <= 0xDBFF) {
        var l = v.charCodeAt(i + 1);
        var c = (h - 0xD800) * 0x400 + l - 0xDC00 + 0x10000;
        s += $encodeRune(c);
        i += 2;
        continue;
      }
      s += $encodeRune(h);
      i++;
    }
    return s;
  case $kindStruct:
    var noJsObject = {};
    var searchJsObject = function(t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      if (t === $jsObjectPtr.elem) {
        $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
      }
      switch (t.kind) {
      case $kindPtr:
        return searchJsObject(t.elem);
      case $kindStruct:
        var f = t.fields[0];
        var o = searchJsObject(f.typ);
        if (o !== noJsObject) {
          var n = new t.ptr();
          n[f.prop] = o;
          return n;
        }
        return noJsObject;
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(t);
    if (o !== noJsObject) {
      return o;
    }
  }
  $throwRuntimeError("cannot internalize " + t.string);
};

/* $isASCII reports whether string s contains only ASCII characters. */
var $isASCII = function(s) {
  for (var i = 0; i < s.length; i++) {
    if (s.charCodeAt(i) >= 128) {
      return false;
    }
  }
  return true;
};

$packages["github.com/gopherjs/gopherjs/js"] = (function() {
	var $pkg = {}, $init, Object, Error, sliceType, ptrType, sliceType$2, funcType, ptrType$1, MakeWrapper, init;
	Object = $pkg.Object = $newType(0, $kindStruct, "js.Object", true, "github.com/gopherjs/gopherjs/js", true, function(object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.object = null;
			return;
		}
		this.object = object_;
	});
	Error = $pkg.Error = $newType(0, $kindStruct, "js.Error", true, "github.com/gopherjs/gopherjs/js", true, function(Object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Object = null;
			return;
		}
		this.Object = Object_;
	});
	sliceType = $sliceType($emptyInterface);
	ptrType = $ptrType(Object);
	sliceType$2 = $sliceType(ptrType);
	funcType = $funcType([sliceType$2], [ptrType], true);
	ptrType$1 = $ptrType(Error);
	Object.ptr.prototype.Get = function(key) {
		var key, o;
		o = this;
		return o.object[$externalize(key, $String)];
	};
	Object.prototype.Get = function(key) { return this.$val.Get(key); };
	Object.ptr.prototype.Set = function(key, value) {
		var key, o, value;
		o = this;
		o.object[$externalize(key, $String)] = $externalize(value, $emptyInterface);
	};
	Object.prototype.Set = function(key, value) { return this.$val.Set(key, value); };
	Object.ptr.prototype.Delete = function(key) {
		var key, o;
		o = this;
		delete o.object[$externalize(key, $String)];
	};
	Object.prototype.Delete = function(key) { return this.$val.Delete(key); };
	Object.ptr.prototype.Length = function() {
		var o;
		o = this;
		return $parseInt(o.object.length);
	};
	Object.prototype.Length = function() { return this.$val.Length(); };
	Object.ptr.prototype.Index = function(i) {
		var i, o;
		o = this;
		return o.object[i];
	};
	Object.prototype.Index = function(i) { return this.$val.Index(i); };
	Object.ptr.prototype.SetIndex = function(i, value) {
		var i, o, value;
		o = this;
		o.object[i] = $externalize(value, $emptyInterface);
	};
	Object.prototype.SetIndex = function(i, value) { return this.$val.SetIndex(i, value); };
	Object.ptr.prototype.Call = function(name, args) {
		var args, name, o, obj;
		o = this;
		return (obj = o.object, obj[$externalize(name, $String)].apply(obj, $externalize(args, sliceType)));
	};
	Object.prototype.Call = function(name, args) { return this.$val.Call(name, args); };
	Object.ptr.prototype.Invoke = function(args) {
		var args, o;
		o = this;
		return o.object.apply(undefined, $externalize(args, sliceType));
	};
	Object.prototype.Invoke = function(args) { return this.$val.Invoke(args); };
	Object.ptr.prototype.New = function(args) {
		var args, o;
		o = this;
		return new ($global.Function.prototype.bind.apply(o.object, [undefined].concat($externalize(args, sliceType))));
	};
	Object.prototype.New = function(args) { return this.$val.New(args); };
	Object.ptr.prototype.Bool = function() {
		var o;
		o = this;
		return !!(o.object);
	};
	Object.prototype.Bool = function() { return this.$val.Bool(); };
	Object.ptr.prototype.String = function() {
		var o;
		o = this;
		return $internalize(o.object, $String);
	};
	Object.prototype.String = function() { return this.$val.String(); };
	Object.ptr.prototype.Int = function() {
		var o;
		o = this;
		return $parseInt(o.object) >> 0;
	};
	Object.prototype.Int = function() { return this.$val.Int(); };
	Object.ptr.prototype.Int64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Int64);
	};
	Object.prototype.Int64 = function() { return this.$val.Int64(); };
	Object.ptr.prototype.Uint64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Uint64);
	};
	Object.prototype.Uint64 = function() { return this.$val.Uint64(); };
	Object.ptr.prototype.Float = function() {
		var o;
		o = this;
		return $parseFloat(o.object);
	};
	Object.prototype.Float = function() { return this.$val.Float(); };
	Object.ptr.prototype.Interface = function() {
		var o;
		o = this;
		return $internalize(o.object, $emptyInterface);
	};
	Object.prototype.Interface = function() { return this.$val.Interface(); };
	Object.ptr.prototype.Unsafe = function() {
		var o;
		o = this;
		return o.object;
	};
	Object.prototype.Unsafe = function() { return this.$val.Unsafe(); };
	Error.ptr.prototype.Error = function() {
		var err;
		err = this;
		return "JavaScript error: " + $internalize(err.Object.message, $String);
	};
	Error.prototype.Error = function() { return this.$val.Error(); };
	Error.ptr.prototype.Stack = function() {
		var err;
		err = this;
		return $internalize(err.Object.stack, $String);
	};
	Error.prototype.Stack = function() { return this.$val.Stack(); };
	MakeWrapper = function(i) {
		var i, i$1, m, methods, o, v;
		v = i;
		o = new ($global.Object)();
		o.__internal_object__ = v;
		methods = v.constructor.methods;
		i$1 = 0;
		while (true) {
			if (!(i$1 < $parseInt(methods.length))) { break; }
			m = [m];
			m[0] = methods[i$1];
			if (!($internalize(m[0].pkg, $String) === "")) {
				i$1 = i$1 + (1) >> 0;
				continue;
			}
			o[$externalize($internalize(m[0].name, $String), $String)] = $externalize((function(m) { return function(args) {
				var args;
				return $externalizeFunction(v[$externalize($internalize(m[0].prop, $String), $String)], m[0].typ, $externalize(true, $Bool)).apply(v, $externalize(args, sliceType$2));
			}; })(m), funcType);
			i$1 = i$1 + (1) >> 0;
		}
		return o;
	};
	$pkg.MakeWrapper = MakeWrapper;
	init = function() {
		var e;
		e = new Error.ptr(null);
		$unused(e);
	};
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([$String], [ptrType], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$String, $emptyInterface], [], false)}, {prop: "Delete", name: "Delete", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Length", name: "Length", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([$Int], [ptrType], false)}, {prop: "SetIndex", name: "SetIndex", pkg: "", typ: $funcType([$Int, $emptyInterface], [], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([$String, sliceType], [ptrType], true)}, {prop: "Invoke", name: "Invoke", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "New", name: "New", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "Bool", name: "Bool", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Int64", name: "Int64", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Float", name: "Float", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Interface", name: "Interface", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Unsafe", name: "Unsafe", pkg: "", typ: $funcType([], [$Uintptr], false)}];
	ptrType$1.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Stack", name: "Stack", pkg: "", typ: $funcType([], [$String], false)}];
	Object.init("github.com/gopherjs/gopherjs/js", [{prop: "object", name: "object", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	Error.init("", [{prop: "Object", name: "Object", embedded: true, exported: true, typ: ptrType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/cpu"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/bytealg"] = (function() {
	var $pkg = {}, $init, cpu, Count, Index, Cutover;
	cpu = $packages["internal/cpu"];
	Count = function(b, c) {
		var _i, _ref, b, c, n, x;
		n = 0;
		_ref = b;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (x === c) {
				n = n + (1) >> 0;
			}
			_i++;
		}
		return n;
	};
	$pkg.Count = Count;
	Index = function(a, b) {
		var a, b;
		$panic(new $String("unimplemented"));
	};
	$pkg.Index = Index;
	Cutover = function(n) {
		var n;
		$panic(new $String("unimplemented"));
	};
	$pkg.Cutover = Cutover;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = cpu.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.MaxLen = 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime/internal/sys"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime"] = (function() {
	var $pkg = {}, $init, js, bytealg, sys, _type, TypeAssertionError, errorString, ptrType, ptrType$4, init, throw$1;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bytealg = $packages["internal/bytealg"];
	sys = $packages["runtime/internal/sys"];
	_type = $pkg._type = $newType(0, $kindStruct, "runtime._type", true, "runtime", false, function(str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.str = "";
			return;
		}
		this.str = str_;
	});
	TypeAssertionError = $pkg.TypeAssertionError = $newType(0, $kindStruct, "runtime.TypeAssertionError", true, "runtime", true, function(_interface_, concrete_, asserted_, missingMethod_) {
		this.$val = this;
		if (arguments.length === 0) {
			this._interface = ptrType.nil;
			this.concrete = ptrType.nil;
			this.asserted = ptrType.nil;
			this.missingMethod = "";
			return;
		}
		this._interface = _interface_;
		this.concrete = concrete_;
		this.asserted = asserted_;
		this.missingMethod = missingMethod_;
	});
	errorString = $pkg.errorString = $newType(8, $kindString, "runtime.errorString", true, "runtime", false, null);
	ptrType = $ptrType(_type);
	ptrType$4 = $ptrType(TypeAssertionError);
	_type.ptr.prototype.string = function() {
		var t;
		t = this;
		return t.str;
	};
	_type.prototype.string = function() { return this.$val.string(); };
	_type.ptr.prototype.pkgpath = function() {
		var t;
		t = this;
		return "";
	};
	_type.prototype.pkgpath = function() { return this.$val.pkgpath(); };
	init = function() {
		var e, jsPkg;
		jsPkg = $packages[$externalize("github.com/gopherjs/gopherjs/js", $String)];
		$jsObjectPtr = jsPkg.Object.ptr;
		$jsErrorPtr = jsPkg.Error.ptr;
		$throwRuntimeError = throw$1;
		e = $ifaceNil;
		e = new TypeAssertionError.ptr(ptrType.nil, ptrType.nil, ptrType.nil, "");
		$unused(e);
	};
	throw$1 = function(s) {
		var s;
		$panic(new errorString((s)));
	};
	TypeAssertionError.ptr.prototype.RuntimeError = function() {
	};
	TypeAssertionError.prototype.RuntimeError = function() { return this.$val.RuntimeError(); };
	TypeAssertionError.ptr.prototype.Error = function() {
		var as, cs, e, inter, msg;
		e = this;
		inter = "interface";
		if (!(e._interface === ptrType.nil)) {
			inter = e._interface.string();
		}
		as = e.asserted.string();
		if (e.concrete === ptrType.nil) {
			return "interface conversion: " + inter + " is nil, not " + as;
		}
		cs = e.concrete.string();
		if (e.missingMethod === "") {
			msg = "interface conversion: " + inter + " is " + cs + ", not " + as;
			if (cs === as) {
				if (!(e.concrete.pkgpath() === e.asserted.pkgpath())) {
					msg = msg + (" (types from different packages)");
				} else {
					msg = msg + (" (types from different scopes)");
				}
			}
			return msg;
		}
		return "interface conversion: " + cs + " is not " + as + ": missing method " + e.missingMethod;
	};
	TypeAssertionError.prototype.Error = function() { return this.$val.Error(); };
	errorString.prototype.RuntimeError = function() {
		var e;
		e = this.$val;
	};
	$ptrType(errorString).prototype.RuntimeError = function() { return new errorString(this.$get()).RuntimeError(); };
	errorString.prototype.Error = function() {
		var e;
		e = this.$val;
		return "runtime error: " + (e);
	};
	$ptrType(errorString).prototype.Error = function() { return new errorString(this.$get()).Error(); };
	ptrType.methods = [{prop: "string", name: "string", pkg: "runtime", typ: $funcType([], [$String], false)}, {prop: "pkgpath", name: "pkgpath", pkg: "runtime", typ: $funcType([], [$String], false)}];
	ptrType$4.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	_type.init("runtime", [{prop: "str", name: "str", embedded: false, exported: false, typ: $String, tag: ""}]);
	TypeAssertionError.init("runtime", [{prop: "_interface", name: "_interface", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "concrete", name: "concrete", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "asserted", name: "asserted", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "missingMethod", name: "missingMethod", embedded: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sys.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["errors"] = (function() {
	var $pkg = {}, $init, errorString, ptrType, New;
	errorString = $pkg.errorString = $newType(0, $kindStruct, "errors.errorString", true, "errors", false, function(s_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = "";
			return;
		}
		this.s = s_;
	});
	ptrType = $ptrType(errorString);
	New = function(text) {
		var text;
		return new errorString.ptr(text);
	};
	$pkg.New = New;
	errorString.ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.s;
	};
	errorString.prototype.Error = function() { return this.$val.Error(); };
	ptrType.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.init("errors", [{prop: "s", name: "s", embedded: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/race"] = (function() {
	var $pkg = {}, $init, Acquire, Release;
	Acquire = function(addr) {
		var addr;
	};
	$pkg.Acquire = Acquire;
	Release = function(addr) {
		var addr;
	};
	$pkg.Release = Release;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync/atomic"] = (function() {
	var $pkg = {}, $init, js, CompareAndSwapInt32, AddInt32;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	CompareAndSwapInt32 = function(addr, old, new$1) {
		var addr, new$1, old;
		if (addr.$get() === old) {
			addr.$set(new$1);
			return true;
		}
		return false;
	};
	$pkg.CompareAndSwapInt32 = CompareAndSwapInt32;
	AddInt32 = function(addr, delta) {
		var addr, delta, new$1;
		new$1 = addr.$get() + delta >> 0;
		addr.$set(new$1);
		return new$1;
	};
	$pkg.AddInt32 = AddInt32;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync"] = (function() {
	var $pkg = {}, $init, js, race, runtime, atomic, Pool, WaitGroup, Mutex, poolLocalInternal, poolLocal, notifyList, ptrType, sliceType, ptrType$1, chanType, sliceType$1, structType, ptrType$6, ptrType$7, sliceType$4, ptrType$10, funcType, arrayType$1, ptrType$12, chanType$1, ptrType$16, arrayType$2, semWaiters, semAwoken, expunged, allPools, runtime_registerPoolCleanup, runtime_SemacquireMutex, runtime_Semrelease, runtime_notifyListCheck, runtime_canSpin, runtime_nanotime, throw$1, poolCleanup, init, indexLocal, init$1, runtime_doSpin;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	race = $packages["internal/race"];
	runtime = $packages["runtime"];
	atomic = $packages["sync/atomic"];
	Pool = $pkg.Pool = $newType(0, $kindStruct, "sync.Pool", true, "sync", true, function(local_, localSize_, store_, New_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.local = 0;
			this.localSize = 0;
			this.store = sliceType$4.nil;
			this.New = $throwNilPointerError;
			return;
		}
		this.local = local_;
		this.localSize = localSize_;
		this.store = store_;
		this.New = New_;
	});
	WaitGroup = $pkg.WaitGroup = $newType(0, $kindStruct, "sync.WaitGroup", true, "sync", true, function(counter_, ch_, state1_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.counter = 0;
			this.ch = $chanNil;
			this.state1 = arrayType$1.zero();
			return;
		}
		this.counter = counter_;
		this.ch = ch_;
		this.state1 = state1_;
	});
	Mutex = $pkg.Mutex = $newType(0, $kindStruct, "sync.Mutex", true, "sync", true, function(state_, sema_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.state = 0;
			this.sema = 0;
			return;
		}
		this.state = state_;
		this.sema = sema_;
	});
	poolLocalInternal = $pkg.poolLocalInternal = $newType(0, $kindStruct, "sync.poolLocalInternal", true, "sync", false, function(private$0_, shared_, Mutex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.private$0 = $ifaceNil;
			this.shared = sliceType$4.nil;
			this.Mutex = new Mutex.ptr(0, 0);
			return;
		}
		this.private$0 = private$0_;
		this.shared = shared_;
		this.Mutex = Mutex_;
	});
	poolLocal = $pkg.poolLocal = $newType(0, $kindStruct, "sync.poolLocal", true, "sync", false, function(poolLocalInternal_, pad_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.poolLocalInternal = new poolLocalInternal.ptr($ifaceNil, sliceType$4.nil, new Mutex.ptr(0, 0));
			this.pad = arrayType$2.zero();
			return;
		}
		this.poolLocalInternal = poolLocalInternal_;
		this.pad = pad_;
	});
	notifyList = $pkg.notifyList = $newType(0, $kindStruct, "sync.notifyList", true, "sync", false, function(wait_, notify_, lock_, head_, tail_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.wait = 0;
			this.notify = 0;
			this.lock = 0;
			this.head = 0;
			this.tail = 0;
			return;
		}
		this.wait = wait_;
		this.notify = notify_;
		this.lock = lock_;
		this.head = head_;
		this.tail = tail_;
	});
	ptrType = $ptrType(Pool);
	sliceType = $sliceType(ptrType);
	ptrType$1 = $ptrType($Uint32);
	chanType = $chanType($Bool, false, false);
	sliceType$1 = $sliceType(chanType);
	structType = $structType("", []);
	ptrType$6 = $ptrType($Int32);
	ptrType$7 = $ptrType(poolLocal);
	sliceType$4 = $sliceType($emptyInterface);
	ptrType$10 = $ptrType($Uint64);
	funcType = $funcType([], [$emptyInterface], false);
	arrayType$1 = $arrayType($Uint32, 3);
	ptrType$12 = $ptrType(WaitGroup);
	chanType$1 = $chanType(structType, false, false);
	ptrType$16 = $ptrType(Mutex);
	arrayType$2 = $arrayType($Uint8, 100);
	Pool.ptr.prototype.Get = function() {
		var _r, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (p.store.$length === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (p.store.$length === 0) { */ case 1:
			/* */ if (!(p.New === $throwNilPointerError)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(p.New === $throwNilPointerError)) { */ case 3:
				_r = p.New(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } */ case 4:
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		x$2 = (x = p.store, x$1 = p.store.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		p.store = $subslice(p.store, 0, (p.store.$length - 1 >> 0));
		$s = -1; return x$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Pool.ptr.prototype.Get }; } $f._r = _r; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Pool.prototype.Get = function() { return this.$val.Get(); };
	Pool.ptr.prototype.Put = function(x) {
		var p, x;
		p = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			return;
		}
		p.store = $append(p.store, x);
	};
	Pool.prototype.Put = function(x) { return this.$val.Put(x); };
	runtime_registerPoolCleanup = function(cleanup) {
		var cleanup;
	};
	runtime_SemacquireMutex = function(s, lifo) {
		var _entry, _entry$1, _entry$2, _entry$3, _entry$4, _key, _key$1, _key$2, _r, ch, lifo, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _r = $f._r; ch = $f.ch; lifo = $f.lifo; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if (((s.$get() - (_entry = semAwoken[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : 0) >>> 0)) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (((s.$get() - (_entry = semAwoken[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : 0) >>> 0)) === 0) { */ case 1:
			ch = new $Chan($Bool, 0);
			if (lifo) {
				_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: $appendSlice(new sliceType$1([ch]), (_entry$1 = semWaiters[ptrType$1.keyFor(s)], _entry$1 !== undefined ? _entry$1.v : sliceType$1.nil)) };
			} else {
				_key$1 = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$1)] = { k: _key$1, v: $append((_entry$2 = semWaiters[ptrType$1.keyFor(s)], _entry$2 !== undefined ? _entry$2.v : sliceType$1.nil), ch) };
			}
			_r = $recv(ch); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r[0];
			_key$2 = s; (semAwoken || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$2)] = { k: _key$2, v: (_entry$3 = semAwoken[ptrType$1.keyFor(s)], _entry$3 !== undefined ? _entry$3.v : 0) - (1) >>> 0 };
			if ((_entry$4 = semAwoken[ptrType$1.keyFor(s)], _entry$4 !== undefined ? _entry$4.v : 0) === 0) {
				delete semAwoken[ptrType$1.keyFor(s)];
			}
		/* } */ case 2:
		s.$set(s.$get() - (1) >>> 0);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_SemacquireMutex }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._r = _r; $f.ch = ch; $f.lifo = lifo; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_Semrelease = function(s, handoff) {
		var _entry, _entry$1, _key, _key$1, ch, handoff, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _key = $f._key; _key$1 = $f._key$1; ch = $f.ch; handoff = $f.handoff; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s.$set(s.$get() + (1) >>> 0);
		w = (_entry = semWaiters[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : sliceType$1.nil);
		if (w.$length === 0) {
			$s = -1; return;
		}
		ch = (0 >= w.$length ? ($throwRuntimeError("index out of range"), undefined) : w.$array[w.$offset + 0]);
		w = $subslice(w, 1);
		_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: w };
		if (w.$length === 0) {
			delete semWaiters[ptrType$1.keyFor(s)];
		}
		_key$1 = s; (semAwoken || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$1)] = { k: _key$1, v: (_entry$1 = semAwoken[ptrType$1.keyFor(s)], _entry$1 !== undefined ? _entry$1.v : 0) + (1) >>> 0 };
		$r = $send(ch, true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semrelease }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._key = _key; $f._key$1 = _key$1; $f.ch = ch; $f.handoff = handoff; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_notifyListCheck = function(size) {
		var size;
	};
	runtime_canSpin = function(i) {
		var i;
		return false;
	};
	runtime_nanotime = function() {
		return $mul64($internalize(new ($global.Date)().getTime(), $Int64), new $Int64(0, 1000000));
	};
	throw$1 = function(s) {
		var s;
		$throwRuntimeError($externalize(s, $String));
	};
	WaitGroup.ptr.prototype.Add = function(delta) {
		var delta, wg;
		wg = this;
		wg.counter = wg.counter + (delta) >> 0;
		if (wg.counter < 0) {
			$panic(new $String("sync: negative WaitGroup counter"));
		}
		if (wg.counter > 0 && wg.ch === $chanNil) {
			wg.ch = new $Chan(structType, 0);
		}
		if ((wg.counter === 0) && !(wg.ch === $chanNil)) {
			$close(wg.ch);
			wg.ch = $chanNil;
		}
	};
	WaitGroup.prototype.Add = function(delta) { return this.$val.Add(delta); };
	WaitGroup.ptr.prototype.Wait = function() {
		var _r, wg, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; wg = $f.wg; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		wg = this;
		/* */ if (wg.counter > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (wg.counter > 0) { */ case 1:
			_r = $recv(wg.ch); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r[0];
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: WaitGroup.ptr.prototype.Wait }; } $f._r = _r; $f.wg = wg; $f.$s = $s; $f.$r = $r; return $f;
	};
	WaitGroup.prototype.Wait = function() { return this.$val.Wait(); };
	Mutex.ptr.prototype.Lock = function() {
		var awoke, delta, iter, m, new$1, old, queueLifo, starving, waitStartTime, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; awoke = $f.awoke; delta = $f.delta; iter = $f.iter; m = $f.m; new$1 = $f.new$1; old = $f.old; queueLifo = $f.queueLifo; starving = $f.starving; waitStartTime = $f.waitStartTime; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), 0, 1)) {
			if (false) {
				race.Acquire((m));
			}
			$s = -1; return;
		}
		waitStartTime = new $Int64(0, 0);
		starving = false;
		awoke = false;
		iter = 0;
		old = m.state;
		/* while (true) { */ case 1:
			/* */ if (((old & 5) === 1) && runtime_canSpin(iter)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (((old & 5) === 1) && runtime_canSpin(iter)) { */ case 3:
				if (!awoke && ((old & 2) === 0) && !(((old >> 3 >> 0) === 0)) && atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, old | 2)) {
					awoke = true;
				}
				runtime_doSpin();
				iter = iter + (1) >> 0;
				old = m.state;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			new$1 = old;
			if ((old & 4) === 0) {
				new$1 = new$1 | (1);
			}
			if (!(((old & 5) === 0))) {
				new$1 = new$1 + (8) >> 0;
			}
			if (starving && !(((old & 1) === 0))) {
				new$1 = new$1 | (4);
			}
			if (awoke) {
				if ((new$1 & 2) === 0) {
					throw$1("sync: inconsistent mutex state");
				}
				new$1 = (new$1 & ~(2)) >> 0;
			}
			/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 5:
				if ((old & 5) === 0) {
					/* break; */ $s = 2; continue;
				}
				queueLifo = !((waitStartTime.$high === 0 && waitStartTime.$low === 0));
				if ((waitStartTime.$high === 0 && waitStartTime.$low === 0)) {
					waitStartTime = runtime_nanotime();
				}
				$r = runtime_SemacquireMutex((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), queueLifo); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				starving = starving || (x = (x$1 = runtime_nanotime(), new $Int64(x$1.$high - waitStartTime.$high, x$1.$low - waitStartTime.$low)), (x.$high > 0 || (x.$high === 0 && x.$low > 1000000)));
				old = m.state;
				if (!(((old & 4) === 0))) {
					if (!(((old & 3) === 0)) || ((old >> 3 >> 0) === 0)) {
						throw$1("sync: inconsistent mutex state");
					}
					delta = -7;
					if (!starving || ((old >> 3 >> 0) === 1)) {
						delta = delta - (4) >> 0;
					}
					atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), delta);
					/* break; */ $s = 2; continue;
				}
				awoke = true;
				iter = 0;
				$s = 7; continue;
			/* } else { */ case 6:
				old = m.state;
			/* } */ case 7:
		/* } */ $s = 1; continue; case 2:
		if (false) {
			race.Acquire((m));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Lock }; } $f.awoke = awoke; $f.delta = delta; $f.iter = iter; $f.m = m; $f.new$1 = new$1; $f.old = old; $f.queueLifo = queueLifo; $f.starving = starving; $f.waitStartTime = waitStartTime; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Lock = function() { return this.$val.Lock(); };
	Mutex.ptr.prototype.Unlock = function() {
		var m, new$1, old, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; m = $f.m; new$1 = $f.new$1; old = $f.old; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (false) {
			$unused(m.state);
			race.Release((m));
		}
		new$1 = atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), -1);
		if ((((new$1 + 1 >> 0)) & 1) === 0) {
			throw$1("sync: unlock of unlocked mutex");
		}
		/* */ if ((new$1 & 4) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((new$1 & 4) === 0) { */ case 1:
			old = new$1;
			/* while (true) { */ case 4:
				if (((old >> 3 >> 0) === 0) || !(((old & 7) === 0))) {
					$s = -1; return;
				}
				new$1 = ((old - 8 >> 0)) | 2;
				/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 6:
					$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), false); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					$s = -1; return;
				/* } */ case 7:
				old = m.state;
			/* } */ $s = 4; continue; case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), true); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Unlock }; } $f.m = m; $f.new$1 = new$1; $f.old = old; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Unlock = function() { return this.$val.Unlock(); };
	poolCleanup = function() {
		var _i, _i$1, _ref, _ref$1, i, i$1, j, l, p, x;
		_ref = allPools;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			p = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			((i < 0 || i >= allPools.$length) ? ($throwRuntimeError("index out of range"), undefined) : allPools.$array[allPools.$offset + i] = ptrType.nil);
			i$1 = 0;
			while (true) {
				if (!(i$1 < ((p.localSize >> 0)))) { break; }
				l = indexLocal(p.local, i$1);
				l.poolLocalInternal.private$0 = $ifaceNil;
				_ref$1 = l.poolLocalInternal.shared;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					j = _i$1;
					(x = l.poolLocalInternal.shared, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j] = $ifaceNil));
					_i$1++;
				}
				l.poolLocalInternal.shared = sliceType$4.nil;
				i$1 = i$1 + (1) >> 0;
			}
			p.local = 0;
			p.localSize = 0;
			_i++;
		}
		allPools = new sliceType([]);
	};
	init = function() {
		runtime_registerPoolCleanup(poolCleanup);
	};
	indexLocal = function(l, i) {
		var i, l, lp;
		lp = (((l) + ($imul(((i >>> 0)), 128) >>> 0) >>> 0));
		return ($pointerOfStructConversion(lp, ptrType$7));
	};
	init$1 = function() {
		var n;
		n = new notifyList.ptr(0, 0, 0, 0, 0);
		runtime_notifyListCheck(20);
	};
	runtime_doSpin = function() {
		$throwRuntimeError("native function not implemented: sync.runtime_doSpin");
	};
	WaitGroup.ptr.prototype.Done = function() {
		var wg;
		wg = this;
		wg.Add(-1);
	};
	WaitGroup.prototype.Done = function() { return this.$val.Done(); };
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Put", name: "Put", pkg: "", typ: $funcType([$emptyInterface], [], false)}, {prop: "getSlow", name: "getSlow", pkg: "sync", typ: $funcType([], [$emptyInterface], false)}, {prop: "pin", name: "pin", pkg: "sync", typ: $funcType([], [ptrType$7], false)}, {prop: "pinSlow", name: "pinSlow", pkg: "sync", typ: $funcType([], [ptrType$7], false)}];
	ptrType$12.methods = [{prop: "Add", name: "Add", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Wait", name: "Wait", pkg: "", typ: $funcType([], [], false)}, {prop: "state", name: "state", pkg: "sync", typ: $funcType([], [ptrType$10, ptrType$1], false)}, {prop: "Done", name: "Done", pkg: "", typ: $funcType([], [], false)}];
	ptrType$16.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}];
	Pool.init("sync", [{prop: "local", name: "local", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "localSize", name: "localSize", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "store", name: "store", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "New", name: "New", embedded: false, exported: true, typ: funcType, tag: ""}]);
	WaitGroup.init("sync", [{prop: "counter", name: "counter", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "ch", name: "ch", embedded: false, exported: false, typ: chanType$1, tag: ""}, {prop: "state1", name: "state1", embedded: false, exported: false, typ: arrayType$1, tag: ""}]);
	Mutex.init("sync", [{prop: "state", name: "state", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "sema", name: "sema", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	poolLocalInternal.init("sync", [{prop: "private$0", name: "private", embedded: false, exported: false, typ: $emptyInterface, tag: ""}, {prop: "shared", name: "shared", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "Mutex", name: "Mutex", embedded: true, exported: true, typ: Mutex, tag: ""}]);
	poolLocal.init("sync", [{prop: "poolLocalInternal", name: "poolLocalInternal", embedded: true, exported: false, typ: poolLocalInternal, tag: ""}, {prop: "pad", name: "pad", embedded: false, exported: false, typ: arrayType$2, tag: ""}]);
	notifyList.init("sync", [{prop: "wait", name: "wait", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "notify", name: "notify", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "lock", name: "lock", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "head", name: "head", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "tail", name: "tail", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = race.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		allPools = sliceType.nil;
		semWaiters = {};
		semAwoken = {};
		expunged = (new Uint8Array(8));
		init();
		init$1();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["io"] = (function() {
	var $pkg = {}, $init, errors, sync, atomic, Reader, Writer, StringWriter, sliceType, errWhence, errOffset, WriteString;
	errors = $packages["errors"];
	sync = $packages["sync"];
	atomic = $packages["sync/atomic"];
	Reader = $pkg.Reader = $newType(8, $kindInterface, "io.Reader", true, "io", true, null);
	Writer = $pkg.Writer = $newType(8, $kindInterface, "io.Writer", true, "io", true, null);
	StringWriter = $pkg.StringWriter = $newType(8, $kindInterface, "io.StringWriter", true, "io", true, null);
	sliceType = $sliceType($Uint8);
	WriteString = function(w, s) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, err, n, ok, s, sw, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; n = $f.n; ok = $f.ok; s = $f.s; sw = $f.sw; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_tuple = $assertType(w, StringWriter, true);
		sw = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			_r = sw.WriteString(s); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple$1 = _r;
			n = _tuple$1[0];
			err = _tuple$1[1];
			$s = -1; return [n, err];
		/* } */ case 2:
		_r$1 = w.Write((new sliceType($stringToBytes(s)))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$2 = _r$1;
		n = _tuple$2[0];
		err = _tuple$2[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: WriteString }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.n = n; $f.ok = ok; $f.s = s; $f.sw = sw; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.WriteString = WriteString;
	Reader.init([{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	Writer.init([{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	StringWriter.init([{prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrShortWrite = errors.New("short write");
		$pkg.ErrShortBuffer = errors.New("short buffer");
		$pkg.EOF = errors.New("EOF");
		$pkg.ErrUnexpectedEOF = errors.New("unexpected EOF");
		$pkg.ErrNoProgress = errors.New("multiple Read calls return no data or error");
		errWhence = errors.New("Seek: invalid whence");
		errOffset = errors.New("Seek: invalid offset");
		$pkg.ErrClosedPipe = errors.New("io: read/write on closed pipe");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode"] = (function() {
	var $pkg = {}, $init, RangeTable, Range16, Range32, CaseRange, d, foldPair, arrayType, sliceType, sliceType$1, ptrType, sliceType$2, sliceType$3, sliceType$4, _L, _M, _N, _P, _S, _Zs, _White_Space, _CaseRanges, properties, asciiFold, caseOrbit, to, IsPrint, In, IsControl, IsLetter, IsPunct, IsSpace, IsSymbol, is16, is32, Is, isExcludingLatin, To, ToUpper, ToLower, SimpleFold;
	RangeTable = $pkg.RangeTable = $newType(0, $kindStruct, "unicode.RangeTable", true, "unicode", true, function(R16_, R32_, LatinOffset_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R16 = sliceType.nil;
			this.R32 = sliceType$1.nil;
			this.LatinOffset = 0;
			return;
		}
		this.R16 = R16_;
		this.R32 = R32_;
		this.LatinOffset = LatinOffset_;
	});
	Range16 = $pkg.Range16 = $newType(0, $kindStruct, "unicode.Range16", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	Range32 = $pkg.Range32 = $newType(0, $kindStruct, "unicode.Range32", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	CaseRange = $pkg.CaseRange = $newType(0, $kindStruct, "unicode.CaseRange", true, "unicode", true, function(Lo_, Hi_, Delta_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Delta = arrayType.zero();
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Delta = Delta_;
	});
	d = $pkg.d = $newType(12, $kindArray, "unicode.d", true, "unicode", false, null);
	foldPair = $pkg.foldPair = $newType(0, $kindStruct, "unicode.foldPair", true, "unicode", false, function(From_, To_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.From = 0;
			this.To = 0;
			return;
		}
		this.From = From_;
		this.To = To_;
	});
	arrayType = $arrayType($Int32, 3);
	sliceType = $sliceType(Range16);
	sliceType$1 = $sliceType(Range32);
	ptrType = $ptrType(RangeTable);
	sliceType$2 = $sliceType(ptrType);
	sliceType$3 = $sliceType(CaseRange);
	sliceType$4 = $sliceType(foldPair);
	to = function(_case, r, caseRange) {
		var _case, _q, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, caseRange, cr, delta, foundMapping, hi, lo, m, mappedRune, r, x;
		mappedRune = 0;
		foundMapping = false;
		if (_case < 0 || 3 <= _case) {
			_tmp = 65533;
			_tmp$1 = false;
			mappedRune = _tmp;
			foundMapping = _tmp$1;
			return [mappedRune, foundMapping];
		}
		lo = 0;
		hi = caseRange.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			cr = ((m < 0 || m >= caseRange.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseRange.$array[caseRange.$offset + m]);
			if (((cr.Lo >> 0)) <= r && r <= ((cr.Hi >> 0))) {
				delta = ((x = cr.Delta, ((_case < 0 || _case >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[_case])));
				if (delta > 1114111) {
					_tmp$2 = ((cr.Lo >> 0)) + ((((((r - ((cr.Lo >> 0)) >> 0)) & ~1) >> 0) | (((_case & 1) >> 0)))) >> 0;
					_tmp$3 = true;
					mappedRune = _tmp$2;
					foundMapping = _tmp$3;
					return [mappedRune, foundMapping];
				}
				_tmp$4 = r + delta >> 0;
				_tmp$5 = true;
				mappedRune = _tmp$4;
				foundMapping = _tmp$5;
				return [mappedRune, foundMapping];
			}
			if (r < ((cr.Lo >> 0))) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		_tmp$6 = r;
		_tmp$7 = false;
		mappedRune = _tmp$6;
		foundMapping = _tmp$7;
		return [mappedRune, foundMapping];
	};
	IsPrint = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 128) >>> 0) === 0));
		}
		return In(r, $pkg.PrintRanges);
	};
	$pkg.IsPrint = IsPrint;
	In = function(r, ranges) {
		var _i, _ref, inside, r, ranges;
		_ref = ranges;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			inside = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (Is(inside, r)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	$pkg.In = In;
	IsControl = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 1) >>> 0) === 0));
		}
		return false;
	};
	$pkg.IsControl = IsControl;
	IsLetter = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 96) >>> 0) === 0));
		}
		return isExcludingLatin($pkg.Letter, r);
	};
	$pkg.IsLetter = IsLetter;
	IsPunct = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 2) >>> 0) === 0));
		}
		return Is($pkg.Punct, r);
	};
	$pkg.IsPunct = IsPunct;
	IsSpace = function(r) {
		var _1, r;
		if (((r >>> 0)) <= 255) {
			_1 = r;
			if ((_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12)) || (_1 === (13)) || (_1 === (32)) || (_1 === (133)) || (_1 === (160))) {
				return true;
			}
			return false;
		}
		return isExcludingLatin($pkg.White_Space, r);
	};
	$pkg.IsSpace = IsSpace;
	IsSymbol = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 8) >>> 0) === 0));
		}
		return isExcludingLatin($pkg.Symbol, r);
	};
	$pkg.IsSymbol = IsSymbol;
	is16 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18 || r <= 255) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (range_.Stride === 1) || ((_r = ((r - range_.Lo << 16 >>> 16)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0);
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = ((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (range_$1.Stride === 1) || ((_r$1 = ((r - range_$1.Lo << 16 >>> 16)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	is32 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (range_.Stride === 1) || ((_r = ((r - range_.Lo >>> 0)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0);
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = $clone(((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]), Range32);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (range_$1.Stride === 1) || ((_r$1 = ((r - range_$1.Lo >>> 0)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	Is = function(rangeTab, r) {
		var r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		if (r16.$length > 0 && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16(r16, ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	$pkg.Is = Is;
	isExcludingLatin = function(rangeTab, r) {
		var off, r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		off = rangeTab.LatinOffset;
		if (r16.$length > off && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16($subslice(r16, off), ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	To = function(_case, r) {
		var _case, _tuple, r;
		_tuple = to(_case, r, $pkg.CaseRanges);
		r = _tuple[0];
		return r;
	};
	$pkg.To = To;
	ToUpper = function(r) {
		var r;
		if (r <= 127) {
			if (97 <= r && r <= 122) {
				r = r - (32) >> 0;
			}
			return r;
		}
		return To(0, r);
	};
	$pkg.ToUpper = ToUpper;
	ToLower = function(r) {
		var r;
		if (r <= 127) {
			if (65 <= r && r <= 90) {
				r = r + (32) >> 0;
			}
			return r;
		}
		return To(1, r);
	};
	$pkg.ToLower = ToLower;
	SimpleFold = function(r) {
		var _q, hi, l, lo, m, r;
		if (r < 0 || r > 1114111) {
			return r;
		}
		if (((r >> 0)) < 128) {
			return ((((r < 0 || r >= asciiFold.length) ? ($throwRuntimeError("index out of range"), undefined) : asciiFold[r]) >> 0));
		}
		lo = 0;
		hi = caseOrbit.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((((m < 0 || m >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + m]).From >> 0)) < r) {
				lo = m + 1 >> 0;
			} else {
				hi = m;
			}
		}
		if (lo < caseOrbit.$length && (((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).From >> 0)) === r)) {
			return ((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).To >> 0));
		}
		l = ToLower(r);
		if (!((l === r))) {
			return l;
		}
		return ToUpper(r);
	};
	$pkg.SimpleFold = SimpleFold;
	RangeTable.init("", [{prop: "R16", name: "R16", embedded: false, exported: true, typ: sliceType, tag: ""}, {prop: "R32", name: "R32", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "LatinOffset", name: "LatinOffset", embedded: false, exported: true, typ: $Int, tag: ""}]);
	Range16.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	Range32.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Uint32, tag: ""}]);
	CaseRange.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Delta", name: "Delta", embedded: false, exported: true, typ: d, tag: ""}]);
	d.init($Int32, 3);
	foldPair.init("", [{prop: "From", name: "From", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "To", name: "To", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_L = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(97, 122, 1), new Range16.ptr(170, 181, 11), new Range16.ptr(186, 192, 6), new Range16.ptr(193, 214, 1), new Range16.ptr(216, 246, 1), new Range16.ptr(248, 705, 1), new Range16.ptr(710, 721, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(748, 750, 2), new Range16.ptr(880, 884, 1), new Range16.ptr(886, 887, 1), new Range16.ptr(890, 893, 1), new Range16.ptr(895, 902, 7), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 929, 1), new Range16.ptr(931, 1013, 1), new Range16.ptr(1015, 1153, 1), new Range16.ptr(1162, 1327, 1), new Range16.ptr(1329, 1366, 1), new Range16.ptr(1369, 1377, 8), new Range16.ptr(1378, 1415, 1), new Range16.ptr(1488, 1514, 1), new Range16.ptr(1520, 1522, 1), new Range16.ptr(1568, 1610, 1), new Range16.ptr(1646, 1647, 1), new Range16.ptr(1649, 1747, 1), new Range16.ptr(1749, 1765, 16), new Range16.ptr(1766, 1774, 8), new Range16.ptr(1775, 1786, 11), new Range16.ptr(1787, 1788, 1), new Range16.ptr(1791, 1808, 17), new Range16.ptr(1810, 1839, 1), new Range16.ptr(1869, 1957, 1), new Range16.ptr(1969, 1994, 25), new Range16.ptr(1995, 2026, 1), new Range16.ptr(2036, 2037, 1), new Range16.ptr(2042, 2048, 6), new Range16.ptr(2049, 2069, 1), new Range16.ptr(2074, 2084, 10), new Range16.ptr(2088, 2112, 24), new Range16.ptr(2113, 2136, 1), new Range16.ptr(2144, 2154, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2308, 2361, 1), new Range16.ptr(2365, 2384, 19), new Range16.ptr(2392, 2401, 1), new Range16.ptr(2417, 2432, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2486, 4), new Range16.ptr(2487, 2489, 1), new Range16.ptr(2493, 2510, 17), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2529, 1), new Range16.ptr(2544, 2545, 1), new Range16.ptr(2556, 2565, 9), new Range16.ptr(2566, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2674, 20), new Range16.ptr(2675, 2676, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2749, 2768, 19), new Range16.ptr(2784, 2785, 1), new Range16.ptr(2809, 2821, 12), new Range16.ptr(2822, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2877, 2908, 31), new Range16.ptr(2909, 2911, 2), new Range16.ptr(2912, 2913, 1), new Range16.ptr(2929, 2947, 18), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2974, 2), new Range16.ptr(2975, 2979, 4), new Range16.ptr(2980, 2984, 4), new Range16.ptr(2985, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3024, 3077, 53), new Range16.ptr(3078, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3160, 27), new Range16.ptr(3161, 3162, 1), new Range16.ptr(3168, 3169, 1), new Range16.ptr(3200, 3205, 5), new Range16.ptr(3206, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3261, 3294, 33), new Range16.ptr(3296, 3297, 1), new Range16.ptr(3313, 3314, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3386, 1), new Range16.ptr(3389, 3406, 17), new Range16.ptr(3412, 3414, 1), new Range16.ptr(3423, 3425, 1), new Range16.ptr(3450, 3455, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3520, 3), new Range16.ptr(3521, 3526, 1), new Range16.ptr(3585, 3632, 1), new Range16.ptr(3634, 3635, 1), new Range16.ptr(3648, 3654, 1), new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3719, 3), new Range16.ptr(3720, 3722, 2), new Range16.ptr(3725, 3732, 7), new Range16.ptr(3733, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3751, 2), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3760, 1), new Range16.ptr(3762, 3763, 1), new Range16.ptr(3773, 3776, 3), new Range16.ptr(3777, 3780, 1), new Range16.ptr(3782, 3804, 22), new Range16.ptr(3805, 3807, 1), new Range16.ptr(3840, 3904, 64), new Range16.ptr(3905, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3976, 3980, 1), new Range16.ptr(4096, 4138, 1), new Range16.ptr(4159, 4176, 17), new Range16.ptr(4177, 4181, 1), new Range16.ptr(4186, 4189, 1), new Range16.ptr(4193, 4197, 4), new Range16.ptr(4198, 4206, 8), new Range16.ptr(4207, 4208, 1), new Range16.ptr(4213, 4225, 1), new Range16.ptr(4238, 4256, 18), new Range16.ptr(4257, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(4304, 4346, 1), new Range16.ptr(4348, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4698, 2), new Range16.ptr(4699, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4802, 2), new Range16.ptr(4803, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4992, 5007, 1), new Range16.ptr(5024, 5109, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(5121, 5740, 1), new Range16.ptr(5743, 5759, 1), new Range16.ptr(5761, 5786, 1), new Range16.ptr(5792, 5866, 1), new Range16.ptr(5873, 5880, 1), new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5905, 1), new Range16.ptr(5920, 5937, 1), new Range16.ptr(5952, 5969, 1), new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6016, 6067, 1), new Range16.ptr(6103, 6108, 5), new Range16.ptr(6176, 6263, 1), new Range16.ptr(6272, 6276, 1), new Range16.ptr(6279, 6312, 1), new Range16.ptr(6314, 6320, 6), new Range16.ptr(6321, 6389, 1), new Range16.ptr(6400, 6430, 1), new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1), new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6656, 6678, 1), new Range16.ptr(6688, 6740, 1), new Range16.ptr(6823, 6917, 94), new Range16.ptr(6918, 6963, 1), new Range16.ptr(6981, 6987, 1), new Range16.ptr(7043, 7072, 1), new Range16.ptr(7086, 7087, 1), new Range16.ptr(7098, 7141, 1), new Range16.ptr(7168, 7203, 1), new Range16.ptr(7245, 7247, 1), new Range16.ptr(7258, 7293, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7409, 1), new Range16.ptr(7413, 7414, 1), new Range16.ptr(7424, 7615, 1), new Range16.ptr(7680, 7957, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7968, 8005, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8032, 8061, 1), new Range16.ptr(8064, 8116, 1), new Range16.ptr(8118, 8124, 1), new Range16.ptr(8126, 8130, 4), new Range16.ptr(8131, 8132, 1), new Range16.ptr(8134, 8140, 1), new Range16.ptr(8144, 8147, 1), new Range16.ptr(8150, 8155, 1), new Range16.ptr(8160, 8172, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8188, 1), new Range16.ptr(8305, 8319, 14), new Range16.ptr(8336, 8348, 1), new Range16.ptr(8450, 8455, 5), new Range16.ptr(8458, 8467, 1), new Range16.ptr(8469, 8473, 4), new Range16.ptr(8474, 8477, 1), new Range16.ptr(8484, 8490, 2), new Range16.ptr(8491, 8493, 1), new Range16.ptr(8495, 8505, 1), new Range16.ptr(8508, 8511, 1), new Range16.ptr(8517, 8521, 1), new Range16.ptr(8526, 8579, 53), new Range16.ptr(8580, 11264, 2684), new Range16.ptr(11265, 11310, 1), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11360, 11492, 1), new Range16.ptr(11499, 11502, 1), new Range16.ptr(11506, 11507, 1), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(11568, 11623, 1), new Range16.ptr(11631, 11648, 17), new Range16.ptr(11649, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(11823, 12293, 470), new Range16.ptr(12294, 12337, 43), new Range16.ptr(12338, 12341, 1), new Range16.ptr(12347, 12348, 1), new Range16.ptr(12353, 12438, 1), new Range16.ptr(12445, 12447, 1), new Range16.ptr(12449, 12538, 1), new Range16.ptr(12540, 12543, 1), new Range16.ptr(12549, 12590, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12704, 12730, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40938, 1), new Range16.ptr(40960, 42124, 1), new Range16.ptr(42192, 42237, 1), new Range16.ptr(42240, 42508, 1), new Range16.ptr(42512, 42527, 1), new Range16.ptr(42538, 42539, 1), new Range16.ptr(42560, 42606, 1), new Range16.ptr(42623, 42653, 1), new Range16.ptr(42656, 42725, 1), new Range16.ptr(42775, 42783, 1), new Range16.ptr(42786, 42888, 1), new Range16.ptr(42891, 42926, 1), new Range16.ptr(42928, 42935, 1), new Range16.ptr(42999, 43009, 1), new Range16.ptr(43011, 43013, 1), new Range16.ptr(43015, 43018, 1), new Range16.ptr(43020, 43042, 1), new Range16.ptr(43072, 43123, 1), new Range16.ptr(43138, 43187, 1), new Range16.ptr(43250, 43255, 1), new Range16.ptr(43259, 43261, 2), new Range16.ptr(43274, 43301, 1), new Range16.ptr(43312, 43334, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(43396, 43442, 1), new Range16.ptr(43471, 43488, 17), new Range16.ptr(43489, 43492, 1), new Range16.ptr(43494, 43503, 1), new Range16.ptr(43514, 43518, 1), new Range16.ptr(43520, 43560, 1), new Range16.ptr(43584, 43586, 1), new Range16.ptr(43588, 43595, 1), new Range16.ptr(43616, 43638, 1), new Range16.ptr(43642, 43646, 4), new Range16.ptr(43647, 43695, 1), new Range16.ptr(43697, 43701, 4), new Range16.ptr(43702, 43705, 3), new Range16.ptr(43706, 43709, 1), new Range16.ptr(43712, 43714, 2), new Range16.ptr(43739, 43741, 1), new Range16.ptr(43744, 43754, 1), new Range16.ptr(43762, 43764, 1), new Range16.ptr(43777, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1), new Range16.ptr(43824, 43866, 1), new Range16.ptr(43868, 43877, 1), new Range16.ptr(43888, 44002, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(64275, 64279, 1), new Range16.ptr(64285, 64287, 2), new Range16.ptr(64288, 64296, 1), new Range16.ptr(64298, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64320, 2), new Range16.ptr(64321, 64323, 2), new Range16.ptr(64324, 64326, 2), new Range16.ptr(64327, 64433, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65019, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1), new Range16.ptr(65313, 65338, 1), new Range16.ptr(65345, 65370, 1), new Range16.ptr(65382, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1), new Range32.ptr(66176, 66204, 1), new Range32.ptr(66208, 66256, 1), new Range32.ptr(66304, 66335, 1), new Range32.ptr(66349, 66368, 1), new Range32.ptr(66370, 66377, 1), new Range32.ptr(66384, 66421, 1), new Range32.ptr(66432, 66461, 1), new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66511, 1), new Range32.ptr(66560, 66717, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(66816, 66855, 1), new Range32.ptr(66864, 66915, 1), new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1), new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67594, 2), new Range32.ptr(67595, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67647, 3), new Range32.ptr(67648, 67669, 1), new Range32.ptr(67680, 67702, 1), new Range32.ptr(67712, 67742, 1), new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67840, 67861, 1), new Range32.ptr(67872, 67897, 1), new Range32.ptr(67968, 68023, 1), new Range32.ptr(68030, 68031, 1), new Range32.ptr(68096, 68112, 16), new Range32.ptr(68113, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68192, 68220, 1), new Range32.ptr(68224, 68252, 1), new Range32.ptr(68288, 68295, 1), new Range32.ptr(68297, 68324, 1), new Range32.ptr(68352, 68405, 1), new Range32.ptr(68416, 68437, 1), new Range32.ptr(68448, 68466, 1), new Range32.ptr(68480, 68497, 1), new Range32.ptr(68608, 68680, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(69635, 69687, 1), new Range32.ptr(69763, 69807, 1), new Range32.ptr(69840, 69864, 1), new Range32.ptr(69891, 69926, 1), new Range32.ptr(69968, 70002, 1), new Range32.ptr(70006, 70019, 13), new Range32.ptr(70020, 70066, 1), new Range32.ptr(70081, 70084, 1), new Range32.ptr(70106, 70108, 2), new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70187, 1), new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70282, 2), new Range32.ptr(70283, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70312, 1), new Range32.ptr(70320, 70366, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70461, 70480, 19), new Range32.ptr(70493, 70497, 1), new Range32.ptr(70656, 70708, 1), new Range32.ptr(70727, 70730, 1), new Range32.ptr(70784, 70831, 1), new Range32.ptr(70852, 70853, 1), new Range32.ptr(70855, 71040, 185), new Range32.ptr(71041, 71086, 1), new Range32.ptr(71128, 71131, 1), new Range32.ptr(71168, 71215, 1), new Range32.ptr(71236, 71296, 60), new Range32.ptr(71297, 71338, 1), new Range32.ptr(71424, 71449, 1), new Range32.ptr(71840, 71903, 1), new Range32.ptr(71935, 72192, 257), new Range32.ptr(72203, 72242, 1), new Range32.ptr(72250, 72272, 22), new Range32.ptr(72284, 72323, 1), new Range32.ptr(72326, 72329, 1), new Range32.ptr(72384, 72440, 1), new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72750, 1), new Range32.ptr(72768, 72818, 50), new Range32.ptr(72819, 72847, 1), new Range32.ptr(72960, 72966, 1), new Range32.ptr(72968, 72969, 1), new Range32.ptr(72971, 73008, 1), new Range32.ptr(73030, 73728, 698), new Range32.ptr(73729, 74649, 1), new Range32.ptr(74880, 75075, 1), new Range32.ptr(77824, 78894, 1), new Range32.ptr(82944, 83526, 1), new Range32.ptr(92160, 92728, 1), new Range32.ptr(92736, 92766, 1), new Range32.ptr(92880, 92909, 1), new Range32.ptr(92928, 92975, 1), new Range32.ptr(92992, 92995, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1), new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94099, 67), new Range32.ptr(94100, 94111, 1), new Range32.ptr(94176, 94177, 1), new Range32.ptr(94208, 100332, 1), new Range32.ptr(100352, 101106, 1), new Range32.ptr(110592, 110878, 1), new Range32.ptr(110960, 111355, 1), new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(119808, 119892, 1), new Range32.ptr(119894, 119964, 1), new Range32.ptr(119966, 119967, 1), new Range32.ptr(119970, 119973, 3), new Range32.ptr(119974, 119977, 3), new Range32.ptr(119978, 119980, 1), new Range32.ptr(119982, 119993, 1), new Range32.ptr(119995, 119997, 2), new Range32.ptr(119998, 120003, 1), new Range32.ptr(120005, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120094, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120138, 4), new Range32.ptr(120139, 120144, 1), new Range32.ptr(120146, 120485, 1), new Range32.ptr(120488, 120512, 1), new Range32.ptr(120514, 120538, 1), new Range32.ptr(120540, 120570, 1), new Range32.ptr(120572, 120596, 1), new Range32.ptr(120598, 120628, 1), new Range32.ptr(120630, 120654, 1), new Range32.ptr(120656, 120686, 1), new Range32.ptr(120688, 120712, 1), new Range32.ptr(120714, 120744, 1), new Range32.ptr(120746, 120770, 1), new Range32.ptr(120772, 120779, 1), new Range32.ptr(124928, 125124, 1), new Range32.ptr(125184, 125251, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126503, 3), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126523, 2), new Range32.ptr(126530, 126535, 5), new Range32.ptr(126537, 126541, 2), new Range32.ptr(126542, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126551, 3), new Range32.ptr(126553, 126561, 2), new Range32.ptr(126562, 126564, 2), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126592, 2), new Range32.ptr(126593, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(183984, 191456, 1), new Range32.ptr(194560, 195101, 1)]), 6);
		_M = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1155, 1161, 1), new Range16.ptr(1425, 1469, 1), new Range16.ptr(1471, 1473, 2), new Range16.ptr(1474, 1476, 2), new Range16.ptr(1477, 1479, 2), new Range16.ptr(1552, 1562, 1), new Range16.ptr(1611, 1631, 1), new Range16.ptr(1648, 1750, 102), new Range16.ptr(1751, 1756, 1), new Range16.ptr(1759, 1764, 1), new Range16.ptr(1767, 1768, 1), new Range16.ptr(1770, 1773, 1), new Range16.ptr(1809, 1840, 31), new Range16.ptr(1841, 1866, 1), new Range16.ptr(1958, 1968, 1), new Range16.ptr(2027, 2035, 1), new Range16.ptr(2070, 2073, 1), new Range16.ptr(2075, 2083, 1), new Range16.ptr(2085, 2087, 1), new Range16.ptr(2089, 2093, 1), new Range16.ptr(2137, 2139, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2307, 1), new Range16.ptr(2362, 2364, 1), new Range16.ptr(2366, 2383, 1), new Range16.ptr(2385, 2391, 1), new Range16.ptr(2402, 2403, 1), new Range16.ptr(2433, 2435, 1), new Range16.ptr(2492, 2494, 2), new Range16.ptr(2495, 2500, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2509, 1), new Range16.ptr(2519, 2530, 11), new Range16.ptr(2531, 2561, 30), new Range16.ptr(2562, 2563, 1), new Range16.ptr(2620, 2622, 2), new Range16.ptr(2623, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2672, 31), new Range16.ptr(2673, 2677, 4), new Range16.ptr(2689, 2691, 1), new Range16.ptr(2748, 2750, 2), new Range16.ptr(2751, 2757, 1), new Range16.ptr(2759, 2761, 1), new Range16.ptr(2763, 2765, 1), new Range16.ptr(2786, 2787, 1), new Range16.ptr(2810, 2815, 1), new Range16.ptr(2817, 2819, 1), new Range16.ptr(2876, 2878, 2), new Range16.ptr(2879, 2884, 1), new Range16.ptr(2887, 2888, 1), new Range16.ptr(2891, 2893, 1), new Range16.ptr(2902, 2903, 1), new Range16.ptr(2914, 2915, 1), new Range16.ptr(2946, 3006, 60), new Range16.ptr(3007, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3021, 1), new Range16.ptr(3031, 3072, 41), new Range16.ptr(3073, 3075, 1), new Range16.ptr(3134, 3140, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3170, 3171, 1), new Range16.ptr(3201, 3203, 1), new Range16.ptr(3260, 3262, 2), new Range16.ptr(3263, 3268, 1), new Range16.ptr(3270, 3272, 1), new Range16.ptr(3274, 3277, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3298, 3299, 1), new Range16.ptr(3328, 3331, 1), new Range16.ptr(3387, 3388, 1), new Range16.ptr(3390, 3396, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3405, 1), new Range16.ptr(3415, 3426, 11), new Range16.ptr(3427, 3458, 31), new Range16.ptr(3459, 3530, 71), new Range16.ptr(3535, 3540, 1), new Range16.ptr(3542, 3544, 2), new Range16.ptr(3545, 3551, 1), new Range16.ptr(3570, 3571, 1), new Range16.ptr(3633, 3636, 3), new Range16.ptr(3637, 3642, 1), new Range16.ptr(3655, 3662, 1), new Range16.ptr(3761, 3764, 3), new Range16.ptr(3765, 3769, 1), new Range16.ptr(3771, 3772, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3864, 3865, 1), new Range16.ptr(3893, 3897, 2), new Range16.ptr(3902, 3903, 1), new Range16.ptr(3953, 3972, 1), new Range16.ptr(3974, 3975, 1), new Range16.ptr(3981, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4038, 4139, 101), new Range16.ptr(4140, 4158, 1), new Range16.ptr(4182, 4185, 1), new Range16.ptr(4190, 4192, 1), new Range16.ptr(4194, 4196, 1), new Range16.ptr(4199, 4205, 1), new Range16.ptr(4209, 4212, 1), new Range16.ptr(4226, 4237, 1), new Range16.ptr(4239, 4250, 11), new Range16.ptr(4251, 4253, 1), new Range16.ptr(4957, 4959, 1), new Range16.ptr(5906, 5908, 1), new Range16.ptr(5938, 5940, 1), new Range16.ptr(5970, 5971, 1), new Range16.ptr(6002, 6003, 1), new Range16.ptr(6068, 6099, 1), new Range16.ptr(6109, 6155, 46), new Range16.ptr(6156, 6157, 1), new Range16.ptr(6277, 6278, 1), new Range16.ptr(6313, 6432, 119), new Range16.ptr(6433, 6443, 1), new Range16.ptr(6448, 6459, 1), new Range16.ptr(6679, 6683, 1), new Range16.ptr(6741, 6750, 1), new Range16.ptr(6752, 6780, 1), new Range16.ptr(6783, 6832, 49), new Range16.ptr(6833, 6846, 1), new Range16.ptr(6912, 6916, 1), new Range16.ptr(6964, 6980, 1), new Range16.ptr(7019, 7027, 1), new Range16.ptr(7040, 7042, 1), new Range16.ptr(7073, 7085, 1), new Range16.ptr(7142, 7155, 1), new Range16.ptr(7204, 7223, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7400, 1), new Range16.ptr(7405, 7410, 5), new Range16.ptr(7411, 7412, 1), new Range16.ptr(7415, 7417, 1), new Range16.ptr(7616, 7673, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8400, 8432, 1), new Range16.ptr(11503, 11505, 1), new Range16.ptr(11647, 11744, 97), new Range16.ptr(11745, 11775, 1), new Range16.ptr(12330, 12335, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(42607, 42610, 1), new Range16.ptr(42612, 42621, 1), new Range16.ptr(42654, 42655, 1), new Range16.ptr(42736, 42737, 1), new Range16.ptr(43010, 43014, 4), new Range16.ptr(43019, 43043, 24), new Range16.ptr(43044, 43047, 1), new Range16.ptr(43136, 43137, 1), new Range16.ptr(43188, 43205, 1), new Range16.ptr(43232, 43249, 1), new Range16.ptr(43302, 43309, 1), new Range16.ptr(43335, 43347, 1), new Range16.ptr(43392, 43395, 1), new Range16.ptr(43443, 43456, 1), new Range16.ptr(43493, 43561, 68), new Range16.ptr(43562, 43574, 1), new Range16.ptr(43587, 43596, 9), new Range16.ptr(43597, 43643, 46), new Range16.ptr(43644, 43645, 1), new Range16.ptr(43696, 43698, 2), new Range16.ptr(43699, 43700, 1), new Range16.ptr(43703, 43704, 1), new Range16.ptr(43710, 43711, 1), new Range16.ptr(43713, 43755, 42), new Range16.ptr(43756, 43759, 1), new Range16.ptr(43765, 43766, 1), new Range16.ptr(44003, 44010, 1), new Range16.ptr(44012, 44013, 1), new Range16.ptr(64286, 65024, 738), new Range16.ptr(65025, 65039, 1), new Range16.ptr(65056, 65071, 1)]), new sliceType$1([new Range32.ptr(66045, 66272, 227), new Range32.ptr(66422, 66426, 1), new Range32.ptr(68097, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68111, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68325, 166), new Range32.ptr(68326, 69632, 1306), new Range32.ptr(69633, 69634, 1), new Range32.ptr(69688, 69702, 1), new Range32.ptr(69759, 69762, 1), new Range32.ptr(69808, 69818, 1), new Range32.ptr(69888, 69890, 1), new Range32.ptr(69927, 69940, 1), new Range32.ptr(70003, 70016, 13), new Range32.ptr(70017, 70018, 1), new Range32.ptr(70067, 70080, 1), new Range32.ptr(70090, 70092, 1), new Range32.ptr(70188, 70199, 1), new Range32.ptr(70206, 70367, 161), new Range32.ptr(70368, 70378, 1), new Range32.ptr(70400, 70403, 1), new Range32.ptr(70460, 70462, 2), new Range32.ptr(70463, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70487, 70498, 11), new Range32.ptr(70499, 70502, 3), new Range32.ptr(70503, 70508, 1), new Range32.ptr(70512, 70516, 1), new Range32.ptr(70709, 70726, 1), new Range32.ptr(70832, 70851, 1), new Range32.ptr(71087, 71093, 1), new Range32.ptr(71096, 71104, 1), new Range32.ptr(71132, 71133, 1), new Range32.ptr(71216, 71232, 1), new Range32.ptr(71339, 71351, 1), new Range32.ptr(71453, 71467, 1), new Range32.ptr(72193, 72202, 1), new Range32.ptr(72243, 72249, 1), new Range32.ptr(72251, 72254, 1), new Range32.ptr(72263, 72273, 10), new Range32.ptr(72274, 72283, 1), new Range32.ptr(72330, 72345, 1), new Range32.ptr(72751, 72758, 1), new Range32.ptr(72760, 72767, 1), new Range32.ptr(72850, 72871, 1), new Range32.ptr(72873, 72886, 1), new Range32.ptr(73009, 73014, 1), new Range32.ptr(73018, 73020, 2), new Range32.ptr(73021, 73023, 2), new Range32.ptr(73024, 73029, 1), new Range32.ptr(73031, 92912, 19881), new Range32.ptr(92913, 92916, 1), new Range32.ptr(92976, 92982, 1), new Range32.ptr(94033, 94078, 1), new Range32.ptr(94095, 94098, 1), new Range32.ptr(113821, 113822, 1), new Range32.ptr(119141, 119145, 1), new Range32.ptr(119149, 119154, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(119362, 119364, 1), new Range32.ptr(121344, 121398, 1), new Range32.ptr(121403, 121452, 1), new Range32.ptr(121461, 121476, 15), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1), new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1), new Range32.ptr(125136, 125142, 1), new Range32.ptr(125252, 125258, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_N = new RangeTable.ptr(new sliceType([new Range16.ptr(48, 57, 1), new Range16.ptr(178, 179, 1), new Range16.ptr(185, 188, 3), new Range16.ptr(189, 190, 1), new Range16.ptr(1632, 1641, 1), new Range16.ptr(1776, 1785, 1), new Range16.ptr(1984, 1993, 1), new Range16.ptr(2406, 2415, 1), new Range16.ptr(2534, 2543, 1), new Range16.ptr(2548, 2553, 1), new Range16.ptr(2662, 2671, 1), new Range16.ptr(2790, 2799, 1), new Range16.ptr(2918, 2927, 1), new Range16.ptr(2930, 2935, 1), new Range16.ptr(3046, 3058, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3192, 3198, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3416, 3422, 1), new Range16.ptr(3430, 3448, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3664, 3673, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3872, 3891, 1), new Range16.ptr(4160, 4169, 1), new Range16.ptr(4240, 4249, 1), new Range16.ptr(4969, 4988, 1), new Range16.ptr(5870, 5872, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6470, 6479, 1), new Range16.ptr(6608, 6618, 1), new Range16.ptr(6784, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6992, 7001, 1), new Range16.ptr(7088, 7097, 1), new Range16.ptr(7232, 7241, 1), new Range16.ptr(7248, 7257, 1), new Range16.ptr(8304, 8308, 4), new Range16.ptr(8309, 8313, 1), new Range16.ptr(8320, 8329, 1), new Range16.ptr(8528, 8578, 1), new Range16.ptr(8581, 8585, 1), new Range16.ptr(9312, 9371, 1), new Range16.ptr(9450, 9471, 1), new Range16.ptr(10102, 10131, 1), new Range16.ptr(11517, 12295, 778), new Range16.ptr(12321, 12329, 1), new Range16.ptr(12344, 12346, 1), new Range16.ptr(12690, 12693, 1), new Range16.ptr(12832, 12841, 1), new Range16.ptr(12872, 12879, 1), new Range16.ptr(12881, 12895, 1), new Range16.ptr(12928, 12937, 1), new Range16.ptr(12977, 12991, 1), new Range16.ptr(42528, 42537, 1), new Range16.ptr(42726, 42735, 1), new Range16.ptr(43056, 43061, 1), new Range16.ptr(43216, 43225, 1), new Range16.ptr(43264, 43273, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43504, 43513, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(44016, 44025, 1), new Range16.ptr(65296, 65305, 1)]), new sliceType$1([new Range32.ptr(65799, 65843, 1), new Range32.ptr(65856, 65912, 1), new Range32.ptr(65930, 65931, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(66336, 66339, 1), new Range32.ptr(66369, 66378, 9), new Range32.ptr(66513, 66517, 1), new Range32.ptr(66720, 66729, 1), new Range32.ptr(67672, 67679, 1), new Range32.ptr(67705, 67711, 1), new Range32.ptr(67751, 67759, 1), new Range32.ptr(67835, 67839, 1), new Range32.ptr(67862, 67867, 1), new Range32.ptr(68028, 68029, 1), new Range32.ptr(68032, 68047, 1), new Range32.ptr(68050, 68095, 1), new Range32.ptr(68160, 68167, 1), new Range32.ptr(68221, 68222, 1), new Range32.ptr(68253, 68255, 1), new Range32.ptr(68331, 68335, 1), new Range32.ptr(68440, 68447, 1), new Range32.ptr(68472, 68479, 1), new Range32.ptr(68521, 68527, 1), new Range32.ptr(68858, 68863, 1), new Range32.ptr(69216, 69246, 1), new Range32.ptr(69714, 69743, 1), new Range32.ptr(69872, 69881, 1), new Range32.ptr(69942, 69951, 1), new Range32.ptr(70096, 70105, 1), new Range32.ptr(70113, 70132, 1), new Range32.ptr(70384, 70393, 1), new Range32.ptr(70736, 70745, 1), new Range32.ptr(70864, 70873, 1), new Range32.ptr(71248, 71257, 1), new Range32.ptr(71360, 71369, 1), new Range32.ptr(71472, 71483, 1), new Range32.ptr(71904, 71922, 1), new Range32.ptr(72784, 72812, 1), new Range32.ptr(73040, 73049, 1), new Range32.ptr(74752, 74862, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(125127, 125135, 1), new Range32.ptr(125264, 125273, 1), new Range32.ptr(127232, 127244, 1)]), 4);
		_P = new RangeTable.ptr(new sliceType([new Range16.ptr(33, 35, 1), new Range16.ptr(37, 42, 1), new Range16.ptr(44, 47, 1), new Range16.ptr(58, 59, 1), new Range16.ptr(63, 64, 1), new Range16.ptr(91, 93, 1), new Range16.ptr(95, 123, 28), new Range16.ptr(125, 161, 36), new Range16.ptr(167, 171, 4), new Range16.ptr(182, 183, 1), new Range16.ptr(187, 191, 4), new Range16.ptr(894, 903, 9), new Range16.ptr(1370, 1375, 1), new Range16.ptr(1417, 1418, 1), new Range16.ptr(1470, 1472, 2), new Range16.ptr(1475, 1478, 3), new Range16.ptr(1523, 1524, 1), new Range16.ptr(1545, 1546, 1), new Range16.ptr(1548, 1549, 1), new Range16.ptr(1563, 1566, 3), new Range16.ptr(1567, 1642, 75), new Range16.ptr(1643, 1645, 1), new Range16.ptr(1748, 1792, 44), new Range16.ptr(1793, 1805, 1), new Range16.ptr(2039, 2041, 1), new Range16.ptr(2096, 2110, 1), new Range16.ptr(2142, 2404, 262), new Range16.ptr(2405, 2416, 11), new Range16.ptr(2557, 2800, 243), new Range16.ptr(3572, 3663, 91), new Range16.ptr(3674, 3675, 1), new Range16.ptr(3844, 3858, 1), new Range16.ptr(3860, 3898, 38), new Range16.ptr(3899, 3901, 1), new Range16.ptr(3973, 4048, 75), new Range16.ptr(4049, 4052, 1), new Range16.ptr(4057, 4058, 1), new Range16.ptr(4170, 4175, 1), new Range16.ptr(4347, 4960, 613), new Range16.ptr(4961, 4968, 1), new Range16.ptr(5120, 5741, 621), new Range16.ptr(5742, 5787, 45), new Range16.ptr(5788, 5867, 79), new Range16.ptr(5868, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6100, 6102, 1), new Range16.ptr(6104, 6106, 1), new Range16.ptr(6144, 6154, 1), new Range16.ptr(6468, 6469, 1), new Range16.ptr(6686, 6687, 1), new Range16.ptr(6816, 6822, 1), new Range16.ptr(6824, 6829, 1), new Range16.ptr(7002, 7008, 1), new Range16.ptr(7164, 7167, 1), new Range16.ptr(7227, 7231, 1), new Range16.ptr(7294, 7295, 1), new Range16.ptr(7360, 7367, 1), new Range16.ptr(7379, 8208, 829), new Range16.ptr(8209, 8231, 1), new Range16.ptr(8240, 8259, 1), new Range16.ptr(8261, 8273, 1), new Range16.ptr(8275, 8286, 1), new Range16.ptr(8317, 8318, 1), new Range16.ptr(8333, 8334, 1), new Range16.ptr(8968, 8971, 1), new Range16.ptr(9001, 9002, 1), new Range16.ptr(10088, 10101, 1), new Range16.ptr(10181, 10182, 1), new Range16.ptr(10214, 10223, 1), new Range16.ptr(10627, 10648, 1), new Range16.ptr(10712, 10715, 1), new Range16.ptr(10748, 10749, 1), new Range16.ptr(11513, 11516, 1), new Range16.ptr(11518, 11519, 1), new Range16.ptr(11632, 11776, 144), new Range16.ptr(11777, 11822, 1), new Range16.ptr(11824, 11849, 1), new Range16.ptr(12289, 12291, 1), new Range16.ptr(12296, 12305, 1), new Range16.ptr(12308, 12319, 1), new Range16.ptr(12336, 12349, 13), new Range16.ptr(12448, 12539, 91), new Range16.ptr(42238, 42239, 1), new Range16.ptr(42509, 42511, 1), new Range16.ptr(42611, 42622, 11), new Range16.ptr(42738, 42743, 1), new Range16.ptr(43124, 43127, 1), new Range16.ptr(43214, 43215, 1), new Range16.ptr(43256, 43258, 1), new Range16.ptr(43260, 43310, 50), new Range16.ptr(43311, 43359, 48), new Range16.ptr(43457, 43469, 1), new Range16.ptr(43486, 43487, 1), new Range16.ptr(43612, 43615, 1), new Range16.ptr(43742, 43743, 1), new Range16.ptr(43760, 43761, 1), new Range16.ptr(44011, 64830, 20819), new Range16.ptr(64831, 65040, 209), new Range16.ptr(65041, 65049, 1), new Range16.ptr(65072, 65106, 1), new Range16.ptr(65108, 65121, 1), new Range16.ptr(65123, 65128, 5), new Range16.ptr(65130, 65131, 1), new Range16.ptr(65281, 65283, 1), new Range16.ptr(65285, 65290, 1), new Range16.ptr(65292, 65295, 1), new Range16.ptr(65306, 65307, 1), new Range16.ptr(65311, 65312, 1), new Range16.ptr(65339, 65341, 1), new Range16.ptr(65343, 65371, 28), new Range16.ptr(65373, 65375, 2), new Range16.ptr(65376, 65381, 1)]), new sliceType$1([new Range32.ptr(65792, 65794, 1), new Range32.ptr(66463, 66512, 49), new Range32.ptr(66927, 67671, 744), new Range32.ptr(67871, 67903, 32), new Range32.ptr(68176, 68184, 1), new Range32.ptr(68223, 68336, 113), new Range32.ptr(68337, 68342, 1), new Range32.ptr(68409, 68415, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(69703, 69709, 1), new Range32.ptr(69819, 69820, 1), new Range32.ptr(69822, 69825, 1), new Range32.ptr(69952, 69955, 1), new Range32.ptr(70004, 70005, 1), new Range32.ptr(70085, 70089, 1), new Range32.ptr(70093, 70107, 14), new Range32.ptr(70109, 70111, 1), new Range32.ptr(70200, 70205, 1), new Range32.ptr(70313, 70731, 418), new Range32.ptr(70732, 70735, 1), new Range32.ptr(70747, 70749, 2), new Range32.ptr(70854, 71105, 251), new Range32.ptr(71106, 71127, 1), new Range32.ptr(71233, 71235, 1), new Range32.ptr(71264, 71276, 1), new Range32.ptr(71484, 71486, 1), new Range32.ptr(72255, 72262, 1), new Range32.ptr(72346, 72348, 1), new Range32.ptr(72350, 72354, 1), new Range32.ptr(72769, 72773, 1), new Range32.ptr(72816, 72817, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(92782, 92783, 1), new Range32.ptr(92917, 92983, 66), new Range32.ptr(92984, 92987, 1), new Range32.ptr(92996, 113823, 20827), new Range32.ptr(121479, 121483, 1), new Range32.ptr(125278, 125279, 1)]), 11);
		_S = new RangeTable.ptr(new sliceType([new Range16.ptr(36, 43, 7), new Range16.ptr(60, 62, 1), new Range16.ptr(94, 96, 2), new Range16.ptr(124, 126, 2), new Range16.ptr(162, 166, 1), new Range16.ptr(168, 169, 1), new Range16.ptr(172, 174, 2), new Range16.ptr(175, 177, 1), new Range16.ptr(180, 184, 4), new Range16.ptr(215, 247, 32), new Range16.ptr(706, 709, 1), new Range16.ptr(722, 735, 1), new Range16.ptr(741, 747, 1), new Range16.ptr(749, 751, 2), new Range16.ptr(752, 767, 1), new Range16.ptr(885, 900, 15), new Range16.ptr(901, 1014, 113), new Range16.ptr(1154, 1421, 267), new Range16.ptr(1422, 1423, 1), new Range16.ptr(1542, 1544, 1), new Range16.ptr(1547, 1550, 3), new Range16.ptr(1551, 1758, 207), new Range16.ptr(1769, 1789, 20), new Range16.ptr(1790, 2038, 248), new Range16.ptr(2546, 2547, 1), new Range16.ptr(2554, 2555, 1), new Range16.ptr(2801, 2928, 127), new Range16.ptr(3059, 3066, 1), new Range16.ptr(3199, 3407, 208), new Range16.ptr(3449, 3647, 198), new Range16.ptr(3841, 3843, 1), new Range16.ptr(3859, 3861, 2), new Range16.ptr(3862, 3863, 1), new Range16.ptr(3866, 3871, 1), new Range16.ptr(3892, 3896, 2), new Range16.ptr(4030, 4037, 1), new Range16.ptr(4039, 4044, 1), new Range16.ptr(4046, 4047, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4254, 4255, 1), new Range16.ptr(5008, 5017, 1), new Range16.ptr(6107, 6464, 357), new Range16.ptr(6622, 6655, 1), new Range16.ptr(7009, 7018, 1), new Range16.ptr(7028, 7036, 1), new Range16.ptr(8125, 8127, 2), new Range16.ptr(8128, 8129, 1), new Range16.ptr(8141, 8143, 1), new Range16.ptr(8157, 8159, 1), new Range16.ptr(8173, 8175, 1), new Range16.ptr(8189, 8190, 1), new Range16.ptr(8260, 8274, 14), new Range16.ptr(8314, 8316, 1), new Range16.ptr(8330, 8332, 1), new Range16.ptr(8352, 8383, 1), new Range16.ptr(8448, 8449, 1), new Range16.ptr(8451, 8454, 1), new Range16.ptr(8456, 8457, 1), new Range16.ptr(8468, 8470, 2), new Range16.ptr(8471, 8472, 1), new Range16.ptr(8478, 8483, 1), new Range16.ptr(8485, 8489, 2), new Range16.ptr(8494, 8506, 12), new Range16.ptr(8507, 8512, 5), new Range16.ptr(8513, 8516, 1), new Range16.ptr(8522, 8525, 1), new Range16.ptr(8527, 8586, 59), new Range16.ptr(8587, 8592, 5), new Range16.ptr(8593, 8967, 1), new Range16.ptr(8972, 9000, 1), new Range16.ptr(9003, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9372, 9449, 1), new Range16.ptr(9472, 10087, 1), new Range16.ptr(10132, 10180, 1), new Range16.ptr(10183, 10213, 1), new Range16.ptr(10224, 10626, 1), new Range16.ptr(10649, 10711, 1), new Range16.ptr(10716, 10747, 1), new Range16.ptr(10750, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11218, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11493, 11498, 1), new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12292, 12306, 14), new Range16.ptr(12307, 12320, 13), new Range16.ptr(12342, 12343, 1), new Range16.ptr(12350, 12351, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(12688, 12689, 1), new Range16.ptr(12694, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12842, 12871, 1), new Range16.ptr(12880, 12896, 16), new Range16.ptr(12897, 12927, 1), new Range16.ptr(12938, 12976, 1), new Range16.ptr(12992, 13054, 1), new Range16.ptr(13056, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42128, 42182, 1), new Range16.ptr(42752, 42774, 1), new Range16.ptr(42784, 42785, 1), new Range16.ptr(42889, 42890, 1), new Range16.ptr(43048, 43051, 1), new Range16.ptr(43062, 43065, 1), new Range16.ptr(43639, 43641, 1), new Range16.ptr(43867, 64297, 20430), new Range16.ptr(64434, 64449, 1), new Range16.ptr(65020, 65021, 1), new Range16.ptr(65122, 65124, 2), new Range16.ptr(65125, 65126, 1), new Range16.ptr(65129, 65284, 155), new Range16.ptr(65291, 65308, 17), new Range16.ptr(65309, 65310, 1), new Range16.ptr(65342, 65344, 2), new Range16.ptr(65372, 65374, 2), new Range16.ptr(65504, 65510, 1), new Range16.ptr(65512, 65518, 1), new Range16.ptr(65532, 65533, 1)]), new sliceType$1([new Range32.ptr(65847, 65855, 1), new Range32.ptr(65913, 65929, 1), new Range32.ptr(65932, 65934, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(65952, 66000, 48), new Range32.ptr(66001, 66044, 1), new Range32.ptr(67703, 67704, 1), new Range32.ptr(68296, 71487, 3191), new Range32.ptr(92988, 92991, 1), new Range32.ptr(92997, 113820, 20823), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119140, 1), new Range32.ptr(119146, 119148, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119296, 119361, 1), new Range32.ptr(119365, 119552, 187), new Range32.ptr(119553, 119638, 1), new Range32.ptr(120513, 120539, 26), new Range32.ptr(120571, 120597, 26), new Range32.ptr(120629, 120655, 26), new Range32.ptr(120687, 120713, 26), new Range32.ptr(120745, 120771, 26), new Range32.ptr(120832, 121343, 1), new Range32.ptr(121399, 121402, 1), new Range32.ptr(121453, 121460, 1), new Range32.ptr(121462, 121475, 1), new Range32.ptr(121477, 121478, 1), new Range32.ptr(126704, 126705, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127584, 127589, 1), new Range32.ptr(127744, 128724, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128760, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129280, 129291, 1), new Range32.ptr(129296, 129342, 1), new Range32.ptr(129344, 129356, 1), new Range32.ptr(129360, 129387, 1), new Range32.ptr(129408, 129431, 1), new Range32.ptr(129472, 129488, 16), new Range32.ptr(129489, 129510, 1)]), 10);
		_Zs = new RangeTable.ptr(new sliceType([new Range16.ptr(32, 160, 128), new Range16.ptr(5760, 8192, 2432), new Range16.ptr(8193, 8202, 1), new Range16.ptr(8239, 8287, 48), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 1);
		$pkg.Letter = _L;
		$pkg.L = _L;
		$pkg.M = _M;
		$pkg.N = _N;
		$pkg.Punct = _P;
		$pkg.P = _P;
		$pkg.Symbol = _S;
		$pkg.S = _S;
		$pkg.PrintRanges = new sliceType$2([$pkg.L, $pkg.M, $pkg.N, $pkg.P, $pkg.S]);
		$pkg.Zs = _Zs;
		_White_Space = new RangeTable.ptr(new sliceType([new Range16.ptr(9, 13, 1), new Range16.ptr(32, 32, 1), new Range16.ptr(133, 133, 1), new Range16.ptr(160, 160, 1), new Range16.ptr(5760, 5760, 1), new Range16.ptr(8192, 8202, 1), new Range16.ptr(8232, 8233, 1), new Range16.ptr(8239, 8239, 1), new Range16.ptr(8287, 8287, 1), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 4);
		$pkg.White_Space = _White_Space;
		_CaseRanges = new sliceType$3([new CaseRange.ptr(65, 90, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(97, 122, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(181, 181, $toNativeArray($kindInt32, [743, 0, 743])), new CaseRange.ptr(192, 214, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(216, 222, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(224, 246, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(248, 254, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(255, 255, $toNativeArray($kindInt32, [121, 0, 121])), new CaseRange.ptr(256, 303, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(304, 304, $toNativeArray($kindInt32, [0, -199, 0])), new CaseRange.ptr(305, 305, $toNativeArray($kindInt32, [-232, 0, -232])), new CaseRange.ptr(306, 311, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(313, 328, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(330, 375, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(376, 376, $toNativeArray($kindInt32, [0, -121, 0])), new CaseRange.ptr(377, 382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(383, 383, $toNativeArray($kindInt32, [-300, 0, -300])), new CaseRange.ptr(384, 384, $toNativeArray($kindInt32, [195, 0, 195])), new CaseRange.ptr(385, 385, $toNativeArray($kindInt32, [0, 210, 0])), new CaseRange.ptr(386, 389, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(390, 390, $toNativeArray($kindInt32, [0, 206, 0])), new CaseRange.ptr(391, 392, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(393, 394, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(395, 396, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(398, 398, $toNativeArray($kindInt32, [0, 79, 0])), new CaseRange.ptr(399, 399, $toNativeArray($kindInt32, [0, 202, 0])), new CaseRange.ptr(400, 400, $toNativeArray($kindInt32, [0, 203, 0])), new CaseRange.ptr(401, 402, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(403, 403, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(404, 404, $toNativeArray($kindInt32, [0, 207, 0])), new CaseRange.ptr(405, 405, $toNativeArray($kindInt32, [97, 0, 97])), new CaseRange.ptr(406, 406, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(407, 407, $toNativeArray($kindInt32, [0, 209, 0])), new CaseRange.ptr(408, 409, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(410, 410, $toNativeArray($kindInt32, [163, 0, 163])), new CaseRange.ptr(412, 412, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(413, 413, $toNativeArray($kindInt32, [0, 213, 0])), new CaseRange.ptr(414, 414, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(415, 415, $toNativeArray($kindInt32, [0, 214, 0])), new CaseRange.ptr(416, 421, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(422, 422, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(423, 424, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(425, 425, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(428, 429, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(430, 430, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(431, 432, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(433, 434, $toNativeArray($kindInt32, [0, 217, 0])), new CaseRange.ptr(435, 438, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(439, 439, $toNativeArray($kindInt32, [0, 219, 0])), new CaseRange.ptr(440, 441, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(444, 445, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(447, 447, $toNativeArray($kindInt32, [56, 0, 56])), new CaseRange.ptr(452, 452, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(453, 453, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(454, 454, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(455, 455, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(456, 456, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(457, 457, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(458, 458, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(459, 459, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(460, 460, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(461, 476, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(477, 477, $toNativeArray($kindInt32, [-79, 0, -79])), new CaseRange.ptr(478, 495, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(497, 497, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(498, 498, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(499, 499, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(500, 501, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(502, 502, $toNativeArray($kindInt32, [0, -97, 0])), new CaseRange.ptr(503, 503, $toNativeArray($kindInt32, [0, -56, 0])), new CaseRange.ptr(504, 543, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(544, 544, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(546, 563, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(570, 570, $toNativeArray($kindInt32, [0, 10795, 0])), new CaseRange.ptr(571, 572, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(573, 573, $toNativeArray($kindInt32, [0, -163, 0])), new CaseRange.ptr(574, 574, $toNativeArray($kindInt32, [0, 10792, 0])), new CaseRange.ptr(575, 576, $toNativeArray($kindInt32, [10815, 0, 10815])), new CaseRange.ptr(577, 578, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(579, 579, $toNativeArray($kindInt32, [0, -195, 0])), new CaseRange.ptr(580, 580, $toNativeArray($kindInt32, [0, 69, 0])), new CaseRange.ptr(581, 581, $toNativeArray($kindInt32, [0, 71, 0])), new CaseRange.ptr(582, 591, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(592, 592, $toNativeArray($kindInt32, [10783, 0, 10783])), new CaseRange.ptr(593, 593, $toNativeArray($kindInt32, [10780, 0, 10780])), new CaseRange.ptr(594, 594, $toNativeArray($kindInt32, [10782, 0, 10782])), new CaseRange.ptr(595, 595, $toNativeArray($kindInt32, [-210, 0, -210])), new CaseRange.ptr(596, 596, $toNativeArray($kindInt32, [-206, 0, -206])), new CaseRange.ptr(598, 599, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(601, 601, $toNativeArray($kindInt32, [-202, 0, -202])), new CaseRange.ptr(603, 603, $toNativeArray($kindInt32, [-203, 0, -203])), new CaseRange.ptr(604, 604, $toNativeArray($kindInt32, [42319, 0, 42319])), new CaseRange.ptr(608, 608, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(609, 609, $toNativeArray($kindInt32, [42315, 0, 42315])), new CaseRange.ptr(611, 611, $toNativeArray($kindInt32, [-207, 0, -207])), new CaseRange.ptr(613, 613, $toNativeArray($kindInt32, [42280, 0, 42280])), new CaseRange.ptr(614, 614, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(616, 616, $toNativeArray($kindInt32, [-209, 0, -209])), new CaseRange.ptr(617, 617, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(618, 618, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(619, 619, $toNativeArray($kindInt32, [10743, 0, 10743])), new CaseRange.ptr(620, 620, $toNativeArray($kindInt32, [42305, 0, 42305])), new CaseRange.ptr(623, 623, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(625, 625, $toNativeArray($kindInt32, [10749, 0, 10749])), new CaseRange.ptr(626, 626, $toNativeArray($kindInt32, [-213, 0, -213])), new CaseRange.ptr(629, 629, $toNativeArray($kindInt32, [-214, 0, -214])), new CaseRange.ptr(637, 637, $toNativeArray($kindInt32, [10727, 0, 10727])), new CaseRange.ptr(640, 640, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(643, 643, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(647, 647, $toNativeArray($kindInt32, [42282, 0, 42282])), new CaseRange.ptr(648, 648, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(649, 649, $toNativeArray($kindInt32, [-69, 0, -69])), new CaseRange.ptr(650, 651, $toNativeArray($kindInt32, [-217, 0, -217])), new CaseRange.ptr(652, 652, $toNativeArray($kindInt32, [-71, 0, -71])), new CaseRange.ptr(658, 658, $toNativeArray($kindInt32, [-219, 0, -219])), new CaseRange.ptr(669, 669, $toNativeArray($kindInt32, [42261, 0, 42261])), new CaseRange.ptr(670, 670, $toNativeArray($kindInt32, [42258, 0, 42258])), new CaseRange.ptr(837, 837, $toNativeArray($kindInt32, [84, 0, 84])), new CaseRange.ptr(880, 883, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(886, 887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(891, 893, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(895, 895, $toNativeArray($kindInt32, [0, 116, 0])), new CaseRange.ptr(902, 902, $toNativeArray($kindInt32, [0, 38, 0])), new CaseRange.ptr(904, 906, $toNativeArray($kindInt32, [0, 37, 0])), new CaseRange.ptr(908, 908, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(910, 911, $toNativeArray($kindInt32, [0, 63, 0])), new CaseRange.ptr(913, 929, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(931, 939, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(940, 940, $toNativeArray($kindInt32, [-38, 0, -38])), new CaseRange.ptr(941, 943, $toNativeArray($kindInt32, [-37, 0, -37])), new CaseRange.ptr(945, 961, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(962, 962, $toNativeArray($kindInt32, [-31, 0, -31])), new CaseRange.ptr(963, 971, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(972, 972, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(973, 974, $toNativeArray($kindInt32, [-63, 0, -63])), new CaseRange.ptr(975, 975, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(976, 976, $toNativeArray($kindInt32, [-62, 0, -62])), new CaseRange.ptr(977, 977, $toNativeArray($kindInt32, [-57, 0, -57])), new CaseRange.ptr(981, 981, $toNativeArray($kindInt32, [-47, 0, -47])), new CaseRange.ptr(982, 982, $toNativeArray($kindInt32, [-54, 0, -54])), new CaseRange.ptr(983, 983, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(984, 1007, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1008, 1008, $toNativeArray($kindInt32, [-86, 0, -86])), new CaseRange.ptr(1009, 1009, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1010, 1010, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(1011, 1011, $toNativeArray($kindInt32, [-116, 0, -116])), new CaseRange.ptr(1012, 1012, $toNativeArray($kindInt32, [0, -60, 0])), new CaseRange.ptr(1013, 1013, $toNativeArray($kindInt32, [-96, 0, -96])), new CaseRange.ptr(1015, 1016, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1017, 1017, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(1018, 1019, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1021, 1023, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(1024, 1039, $toNativeArray($kindInt32, [0, 80, 0])), new CaseRange.ptr(1040, 1071, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(1072, 1103, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(1104, 1119, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1120, 1153, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1162, 1215, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1216, 1216, $toNativeArray($kindInt32, [0, 15, 0])), new CaseRange.ptr(1217, 1230, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1231, 1231, $toNativeArray($kindInt32, [-15, 0, -15])), new CaseRange.ptr(1232, 1327, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1329, 1366, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(1377, 1414, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(4256, 4293, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4295, 4295, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4301, 4301, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(5024, 5103, $toNativeArray($kindInt32, [0, 38864, 0])), new CaseRange.ptr(5104, 5109, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(5112, 5117, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(7296, 7296, $toNativeArray($kindInt32, [-6254, 0, -6254])), new CaseRange.ptr(7297, 7297, $toNativeArray($kindInt32, [-6253, 0, -6253])), new CaseRange.ptr(7298, 7298, $toNativeArray($kindInt32, [-6244, 0, -6244])), new CaseRange.ptr(7299, 7300, $toNativeArray($kindInt32, [-6242, 0, -6242])), new CaseRange.ptr(7301, 7301, $toNativeArray($kindInt32, [-6243, 0, -6243])), new CaseRange.ptr(7302, 7302, $toNativeArray($kindInt32, [-6236, 0, -6236])), new CaseRange.ptr(7303, 7303, $toNativeArray($kindInt32, [-6181, 0, -6181])), new CaseRange.ptr(7304, 7304, $toNativeArray($kindInt32, [35266, 0, 35266])), new CaseRange.ptr(7545, 7545, $toNativeArray($kindInt32, [35332, 0, 35332])), new CaseRange.ptr(7549, 7549, $toNativeArray($kindInt32, [3814, 0, 3814])), new CaseRange.ptr(7680, 7829, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7835, 7835, $toNativeArray($kindInt32, [-59, 0, -59])), new CaseRange.ptr(7838, 7838, $toNativeArray($kindInt32, [0, -7615, 0])), new CaseRange.ptr(7840, 7935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7936, 7943, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7944, 7951, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7952, 7957, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7960, 7965, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7968, 7975, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7976, 7983, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7984, 7991, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7992, 7999, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8000, 8005, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8008, 8013, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8017, 8017, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8019, 8019, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8021, 8021, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8023, 8023, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8025, 8025, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8027, 8027, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8029, 8029, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8031, 8031, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8032, 8039, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8040, 8047, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8048, 8049, $toNativeArray($kindInt32, [74, 0, 74])), new CaseRange.ptr(8050, 8053, $toNativeArray($kindInt32, [86, 0, 86])), new CaseRange.ptr(8054, 8055, $toNativeArray($kindInt32, [100, 0, 100])), new CaseRange.ptr(8056, 8057, $toNativeArray($kindInt32, [128, 0, 128])), new CaseRange.ptr(8058, 8059, $toNativeArray($kindInt32, [112, 0, 112])), new CaseRange.ptr(8060, 8061, $toNativeArray($kindInt32, [126, 0, 126])), new CaseRange.ptr(8064, 8071, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8072, 8079, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8080, 8087, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8088, 8095, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8096, 8103, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8104, 8111, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8112, 8113, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8115, 8115, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8120, 8121, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8122, 8123, $toNativeArray($kindInt32, [0, -74, 0])), new CaseRange.ptr(8124, 8124, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8126, 8126, $toNativeArray($kindInt32, [-7205, 0, -7205])), new CaseRange.ptr(8131, 8131, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8136, 8139, $toNativeArray($kindInt32, [0, -86, 0])), new CaseRange.ptr(8140, 8140, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8144, 8145, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8152, 8153, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8154, 8155, $toNativeArray($kindInt32, [0, -100, 0])), new CaseRange.ptr(8160, 8161, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8165, 8165, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(8168, 8169, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8170, 8171, $toNativeArray($kindInt32, [0, -112, 0])), new CaseRange.ptr(8172, 8172, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(8179, 8179, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8184, 8185, $toNativeArray($kindInt32, [0, -128, 0])), new CaseRange.ptr(8186, 8187, $toNativeArray($kindInt32, [0, -126, 0])), new CaseRange.ptr(8188, 8188, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8486, 8486, $toNativeArray($kindInt32, [0, -7517, 0])), new CaseRange.ptr(8490, 8490, $toNativeArray($kindInt32, [0, -8383, 0])), new CaseRange.ptr(8491, 8491, $toNativeArray($kindInt32, [0, -8262, 0])), new CaseRange.ptr(8498, 8498, $toNativeArray($kindInt32, [0, 28, 0])), new CaseRange.ptr(8526, 8526, $toNativeArray($kindInt32, [-28, 0, -28])), new CaseRange.ptr(8544, 8559, $toNativeArray($kindInt32, [0, 16, 0])), new CaseRange.ptr(8560, 8575, $toNativeArray($kindInt32, [-16, 0, -16])), new CaseRange.ptr(8579, 8580, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(9398, 9423, $toNativeArray($kindInt32, [0, 26, 0])), new CaseRange.ptr(9424, 9449, $toNativeArray($kindInt32, [-26, 0, -26])), new CaseRange.ptr(11264, 11310, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(11312, 11358, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(11360, 11361, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11362, 11362, $toNativeArray($kindInt32, [0, -10743, 0])), new CaseRange.ptr(11363, 11363, $toNativeArray($kindInt32, [0, -3814, 0])), new CaseRange.ptr(11364, 11364, $toNativeArray($kindInt32, [0, -10727, 0])), new CaseRange.ptr(11365, 11365, $toNativeArray($kindInt32, [-10795, 0, -10795])), new CaseRange.ptr(11366, 11366, $toNativeArray($kindInt32, [-10792, 0, -10792])), new CaseRange.ptr(11367, 11372, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11373, 11373, $toNativeArray($kindInt32, [0, -10780, 0])), new CaseRange.ptr(11374, 11374, $toNativeArray($kindInt32, [0, -10749, 0])), new CaseRange.ptr(11375, 11375, $toNativeArray($kindInt32, [0, -10783, 0])), new CaseRange.ptr(11376, 11376, $toNativeArray($kindInt32, [0, -10782, 0])), new CaseRange.ptr(11378, 11379, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11381, 11382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11390, 11391, $toNativeArray($kindInt32, [0, -10815, 0])), new CaseRange.ptr(11392, 11491, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11499, 11502, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11506, 11507, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11520, 11557, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11559, 11559, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11565, 11565, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(42560, 42605, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42624, 42651, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42786, 42799, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42802, 42863, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42873, 42876, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42877, 42877, $toNativeArray($kindInt32, [0, -35332, 0])), new CaseRange.ptr(42878, 42887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42891, 42892, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42893, 42893, $toNativeArray($kindInt32, [0, -42280, 0])), new CaseRange.ptr(42896, 42899, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42902, 42921, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42922, 42922, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42923, 42923, $toNativeArray($kindInt32, [0, -42319, 0])), new CaseRange.ptr(42924, 42924, $toNativeArray($kindInt32, [0, -42315, 0])), new CaseRange.ptr(42925, 42925, $toNativeArray($kindInt32, [0, -42305, 0])), new CaseRange.ptr(42926, 42926, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42928, 42928, $toNativeArray($kindInt32, [0, -42258, 0])), new CaseRange.ptr(42929, 42929, $toNativeArray($kindInt32, [0, -42282, 0])), new CaseRange.ptr(42930, 42930, $toNativeArray($kindInt32, [0, -42261, 0])), new CaseRange.ptr(42931, 42931, $toNativeArray($kindInt32, [0, 928, 0])), new CaseRange.ptr(42932, 42935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(43859, 43859, $toNativeArray($kindInt32, [-928, 0, -928])), new CaseRange.ptr(43888, 43967, $toNativeArray($kindInt32, [-38864, 0, -38864])), new CaseRange.ptr(65313, 65338, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(65345, 65370, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(66560, 66599, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66600, 66639, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(66736, 66771, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66776, 66811, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(68736, 68786, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(68800, 68850, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(71840, 71871, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(71872, 71903, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(125184, 125217, $toNativeArray($kindInt32, [0, 34, 0])), new CaseRange.ptr(125218, 125251, $toNativeArray($kindInt32, [-34, 0, -34]))]);
		$pkg.CaseRanges = _CaseRanges;
		properties = $toNativeArray($kindUint8, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 144, 130, 130, 130, 136, 130, 130, 130, 130, 130, 130, 136, 130, 130, 130, 130, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 130, 130, 136, 136, 136, 130, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 130, 130, 130, 136, 130, 136, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 130, 136, 130, 136, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 130, 136, 136, 136, 136, 136, 130, 136, 136, 224, 130, 136, 0, 136, 136, 136, 136, 132, 132, 136, 192, 130, 130, 136, 132, 224, 130, 132, 132, 132, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 136, 160, 160, 160, 160, 160, 160, 160, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 136, 192, 192, 192, 192, 192, 192, 192, 192]);
		asciiFold = $toNativeArray($kindUint16, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 8490, 76, 77, 78, 79, 80, 81, 82, 383, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127]);
		caseOrbit = new sliceType$4([new foldPair.ptr(75, 107), new foldPair.ptr(83, 115), new foldPair.ptr(107, 8490), new foldPair.ptr(115, 383), new foldPair.ptr(181, 924), new foldPair.ptr(197, 229), new foldPair.ptr(223, 7838), new foldPair.ptr(229, 8491), new foldPair.ptr(304, 304), new foldPair.ptr(305, 305), new foldPair.ptr(383, 83), new foldPair.ptr(452, 453), new foldPair.ptr(453, 454), new foldPair.ptr(454, 452), new foldPair.ptr(455, 456), new foldPair.ptr(456, 457), new foldPair.ptr(457, 455), new foldPair.ptr(458, 459), new foldPair.ptr(459, 460), new foldPair.ptr(460, 458), new foldPair.ptr(497, 498), new foldPair.ptr(498, 499), new foldPair.ptr(499, 497), new foldPair.ptr(837, 921), new foldPair.ptr(914, 946), new foldPair.ptr(917, 949), new foldPair.ptr(920, 952), new foldPair.ptr(921, 953), new foldPair.ptr(922, 954), new foldPair.ptr(924, 956), new foldPair.ptr(928, 960), new foldPair.ptr(929, 961), new foldPair.ptr(931, 962), new foldPair.ptr(934, 966), new foldPair.ptr(937, 969), new foldPair.ptr(946, 976), new foldPair.ptr(949, 1013), new foldPair.ptr(952, 977), new foldPair.ptr(953, 8126), new foldPair.ptr(954, 1008), new foldPair.ptr(956, 181), new foldPair.ptr(960, 982), new foldPair.ptr(961, 1009), new foldPair.ptr(962, 963), new foldPair.ptr(963, 931), new foldPair.ptr(966, 981), new foldPair.ptr(969, 8486), new foldPair.ptr(976, 914), new foldPair.ptr(977, 1012), new foldPair.ptr(981, 934), new foldPair.ptr(982, 928), new foldPair.ptr(1008, 922), new foldPair.ptr(1009, 929), new foldPair.ptr(1012, 920), new foldPair.ptr(1013, 917), new foldPair.ptr(1042, 1074), new foldPair.ptr(1044, 1076), new foldPair.ptr(1054, 1086), new foldPair.ptr(1057, 1089), new foldPair.ptr(1058, 1090), new foldPair.ptr(1066, 1098), new foldPair.ptr(1074, 7296), new foldPair.ptr(1076, 7297), new foldPair.ptr(1086, 7298), new foldPair.ptr(1089, 7299), new foldPair.ptr(1090, 7300), new foldPair.ptr(1098, 7302), new foldPair.ptr(1122, 1123), new foldPair.ptr(1123, 7303), new foldPair.ptr(7296, 1042), new foldPair.ptr(7297, 1044), new foldPair.ptr(7298, 1054), new foldPair.ptr(7299, 1057), new foldPair.ptr(7300, 7301), new foldPair.ptr(7301, 1058), new foldPair.ptr(7302, 1066), new foldPair.ptr(7303, 1122), new foldPair.ptr(7304, 42570), new foldPair.ptr(7776, 7777), new foldPair.ptr(7777, 7835), new foldPair.ptr(7835, 7776), new foldPair.ptr(7838, 223), new foldPair.ptr(8126, 837), new foldPair.ptr(8486, 937), new foldPair.ptr(8490, 75), new foldPair.ptr(8491, 197), new foldPair.ptr(42570, 42571), new foldPair.ptr(42571, 7304)]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode/utf8"] = (function() {
	var $pkg = {}, $init, acceptRange, first, acceptRanges, DecodeRune, DecodeRuneInString, DecodeLastRune, DecodeLastRuneInString, RuneLen, EncodeRune, RuneCount, RuneCountInString, RuneStart, ValidRune;
	acceptRange = $pkg.acceptRange = $newType(0, $kindStruct, "utf8.acceptRange", true, "unicode/utf8", false, function(lo_, hi_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.lo = 0;
			this.hi = 0;
			return;
		}
		this.lo = lo_;
		this.hi = hi_;
	});
	DecodeRune = function(p) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, b1, b2, b3, mask, n, p, p0, r, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = p.$length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		p0 = (0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]);
		x = ((p0 < 0 || p0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[p0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = (((((0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		b1 = (1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]);
		if (b1 < accept.lo || accept.hi < b1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((p0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((b1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		b2 = (2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]);
		if (b2 < 128 || 191 < b2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((p0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		b3 = (3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]);
		if (b3 < 128 || 191 < b3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((p0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((b2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRune = DecodeRune;
	DecodeRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, mask, n, r, s, s0, s1, s2, s3, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = s.length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		s0 = s.charCodeAt(0);
		x = ((s0 < 0 || s0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[s0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = ((((s.charCodeAt(0) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		s1 = s.charCodeAt(1);
		if (s1 < accept.lo || accept.hi < s1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((s0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((s1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		s2 = s.charCodeAt(2);
		if (s2 < 128 || 191 < s2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((s0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		s3 = s.charCodeAt(3);
		if (s3 < 128 || 191 < s3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((s0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((s2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRuneInString = DecodeRuneInString;
	DecodeLastRune = function(p) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, p, r, size, start;
		r = 0;
		size = 0;
		end = p.$length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRune($subslice(p, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRune = DecodeLastRune;
	DecodeLastRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, r, s, size, start;
		r = 0;
		size = 0;
		end = s.length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((s.charCodeAt(start) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(s.charCodeAt(start))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRuneInString($substring(s, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRuneInString = DecodeLastRuneInString;
	RuneLen = function(r) {
		var r;
		if (r < 0) {
			return -1;
		} else if (r <= 127) {
			return 1;
		} else if (r <= 2047) {
			return 2;
		} else if (55296 <= r && r <= 57343) {
			return -1;
		} else if (r <= 65535) {
			return 3;
		} else if (r <= 1114111) {
			return 4;
		}
		return -1;
	};
	$pkg.RuneLen = RuneLen;
	EncodeRune = function(p, r) {
		var i, p, r;
		i = ((r >>> 0));
		if (i <= 127) {
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((r << 24 >>> 24)));
			return 1;
		} else if (i <= 2047) {
			$unused((1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((192 | (((r >> 6 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 2;
		} else if ((i > 1114111) || (55296 <= i && i <= 57343)) {
			r = 65533;
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else if (i <= 65535) {
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else {
			$unused((3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((240 | (((r >> 18 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 12 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 4;
		}
	};
	$pkg.EncodeRune = EncodeRune;
	RuneCount = function(p) {
		var accept, c, c$1, c$2, c$3, i, n, np, p, size, x, x$1, x$2, x$3, x$4;
		np = p.$length;
		n = 0;
		i = 0;
		while (true) {
			if (!(i < np)) { break; }
			n = n + (1) >> 0;
			c = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
			if (c < 128) {
				i = i + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > np) {
				i = i + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = (x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$2]));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = (x$3 = i + 2 >> 0, ((x$3 < 0 || x$3 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$3]));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = (x$4 = i + 3 >> 0, ((x$4 < 0 || x$4 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$4]));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
		}
		return n;
	};
	$pkg.RuneCount = RuneCount;
	RuneCountInString = function(s) {
		var accept, c, c$1, c$2, c$3, i, n, ns, s, size, x, x$1;
		n = 0;
		ns = s.length;
		i = 0;
		while (true) {
			if (!(i < ns)) { break; }
			c = s.charCodeAt(i);
			if (c < 128) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > ns) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = s.charCodeAt((i + 1 >> 0));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = s.charCodeAt((i + 2 >> 0));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = s.charCodeAt((i + 3 >> 0));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
			n = n + (1) >> 0;
		}
		n = n;
		return n;
	};
	$pkg.RuneCountInString = RuneCountInString;
	RuneStart = function(b) {
		var b;
		return !((((b & 192) >>> 0) === 128));
	};
	$pkg.RuneStart = RuneStart;
	ValidRune = function(r) {
		var r;
		if (0 <= r && r < 55296) {
			return true;
		} else if (57343 < r && r <= 1114111) {
			return true;
		}
		return false;
	};
	$pkg.ValidRune = ValidRune;
	acceptRange.init("unicode/utf8", [{prop: "lo", name: "lo", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "hi", name: "hi", embedded: false, exported: false, typ: $Uint8, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		first = $toNativeArray($kindUint8, [240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 19, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 35, 3, 3, 52, 4, 4, 4, 68, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241]);
		acceptRanges = $toNativeArray($kindStruct, [new acceptRange.ptr(128, 191), new acceptRange.ptr(160, 191), new acceptRange.ptr(128, 159), new acceptRange.ptr(144, 191), new acceptRange.ptr(128, 143)]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bytes"] = (function() {
	var $pkg = {}, $init, errors, bytealg, io, unicode, utf8, Buffer, readOp, asciiSet, ptrType, sliceType, sliceType$1, ptrType$1, arrayType$1, errNegativeRead, IndexByte, Equal, makeSlice, NewBufferString, explode, Count, Contains, ContainsAny, IndexAny, genSplit, Split, HasPrefix, HasSuffix, Map, Repeat, ToLower, TrimLeftFunc, TrimRightFunc, TrimFunc, indexFunc, lastIndexFunc, makeASCIISet, makeCutsetFunc, Trim, TrimSpace, Replace, ReplaceAll, Index, indexRabinKarp, hashStr;
	errors = $packages["errors"];
	bytealg = $packages["internal/bytealg"];
	io = $packages["io"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Buffer = $pkg.Buffer = $newType(0, $kindStruct, "bytes.Buffer", true, "bytes", true, function(buf_, off_, lastRead_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType.nil;
			this.off = 0;
			this.lastRead = 0;
			return;
		}
		this.buf = buf_;
		this.off = off_;
		this.lastRead = lastRead_;
	});
	readOp = $pkg.readOp = $newType(1, $kindInt8, "bytes.readOp", true, "bytes", false, null);
	asciiSet = $pkg.asciiSet = $newType(32, $kindArray, "bytes.asciiSet", true, "bytes", false, null);
	ptrType = $ptrType(Buffer);
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType(sliceType);
	ptrType$1 = $ptrType(asciiSet);
	arrayType$1 = $arrayType($Uint32, 8);
	IndexByte = function(s, c) {
		var _i, _ref, b, c, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === c) {
				return i;
			}
			_i++;
		}
		return -1;
	};
	$pkg.IndexByte = IndexByte;
	Equal = function(a, b) {
		var _i, _ref, a, b, c, i;
		if (!((a.$length === b.$length))) {
			return false;
		}
		_ref = a;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((c === ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i])))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	$pkg.Equal = Equal;
	Buffer.ptr.prototype.Bytes = function() {
		var b;
		b = this;
		return $subslice(b.buf, b.off);
	};
	Buffer.prototype.Bytes = function() { return this.$val.Bytes(); };
	Buffer.ptr.prototype.String = function() {
		var b;
		b = this;
		if (b === ptrType.nil) {
			return "<nil>";
		}
		return ($bytesToString($subslice(b.buf, b.off)));
	};
	Buffer.prototype.String = function() { return this.$val.String(); };
	Buffer.ptr.prototype.empty = function() {
		var b;
		b = this;
		return b.buf.$length <= b.off;
	};
	Buffer.prototype.empty = function() { return this.$val.empty(); };
	Buffer.ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.$length - b.off >> 0;
	};
	Buffer.prototype.Len = function() { return this.$val.Len(); };
	Buffer.ptr.prototype.Cap = function() {
		var b;
		b = this;
		return b.buf.$capacity;
	};
	Buffer.prototype.Cap = function() { return this.$val.Cap(); };
	Buffer.ptr.prototype.Truncate = function(n) {
		var b, n;
		b = this;
		if (n === 0) {
			b.Reset();
			return;
		}
		b.lastRead = 0;
		if (n < 0 || n > b.Len()) {
			$panic(new $String("bytes.Buffer: truncation out of range"));
		}
		b.buf = $subslice(b.buf, 0, (b.off + n >> 0));
	};
	Buffer.prototype.Truncate = function(n) { return this.$val.Truncate(n); };
	Buffer.ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.buf = $subslice(b.buf, 0, 0);
		b.off = 0;
		b.lastRead = 0;
	};
	Buffer.prototype.Reset = function() { return this.$val.Reset(); };
	Buffer.ptr.prototype.tryGrowByReslice = function(n) {
		var b, l, n;
		b = this;
		l = b.buf.$length;
		if (n <= (b.buf.$capacity - l >> 0)) {
			b.buf = $subslice(b.buf, 0, (l + n >> 0));
			return [l, true];
		}
		return [0, false];
	};
	Buffer.prototype.tryGrowByReslice = function(n) { return this.$val.tryGrowByReslice(n); };
	Buffer.ptr.prototype.grow = function(n) {
		var _q, _tuple, b, buf, c, i, m, n, ok;
		b = this;
		m = b.Len();
		if ((m === 0) && !((b.off === 0))) {
			b.Reset();
		}
		_tuple = b.tryGrowByReslice(n);
		i = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			return i;
		}
		if (b.buf === sliceType.nil && n <= 64) {
			b.buf = $makeSlice(sliceType, n, 64);
			return 0;
		}
		c = b.buf.$capacity;
		if (n <= ((_q = c / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) - m >> 0)) {
			$copySlice(b.buf, $subslice(b.buf, b.off));
		} else if (c > ((2147483647 - c >> 0) - n >> 0)) {
			$panic($pkg.ErrTooLarge);
		} else {
			buf = makeSlice(($imul(2, c)) + n >> 0);
			$copySlice(buf, $subslice(b.buf, b.off));
			b.buf = buf;
		}
		b.off = 0;
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		return m;
	};
	Buffer.prototype.grow = function(n) { return this.$val.grow(n); };
	Buffer.ptr.prototype.Grow = function(n) {
		var b, m, n;
		b = this;
		if (n < 0) {
			$panic(new $String("bytes.Buffer.Grow: negative count"));
		}
		m = b.grow(n);
		b.buf = $subslice(b.buf, 0, m);
	};
	Buffer.prototype.Grow = function(n) { return this.$val.Grow(n); };
	Buffer.ptr.prototype.Write = function(p) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(p.$length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(p.$length);
		}
		_tmp = $copySlice($subslice(b.buf, m), p);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.Write = function(p) { return this.$val.Write(p); };
	Buffer.ptr.prototype.WriteString = function(s) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, s;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(s.length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(s.length);
		}
		_tmp = $copyString($subslice(b.buf, m), s);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Buffer.ptr.prototype.ReadFrom = function(r) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, i, m, n, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; i = $f.i; m = $f.m; n = $f.n; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		/* while (true) { */ case 1:
			i = b.grow(512);
			b.buf = $subslice(b.buf, 0, i);
			_r = r.Read($subslice(b.buf, i, b.buf.$capacity)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (m < 0) {
				$panic(errNegativeRead);
			}
			b.buf = $subslice(b.buf, 0, (i + m >> 0));
			n = (x = (new $Int64(0, m)), new $Int64(n.$high + x.$high, n.$low + x.$low));
			if ($interfaceIsEqual(e, io.EOF)) {
				_tmp = n;
				_tmp$1 = $ifaceNil;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp$2 = n;
				_tmp$3 = e;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.ReadFrom }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.i = i; $f.m = m; $f.n = n; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.ReadFrom = function(r) { return this.$val.ReadFrom(r); };
	makeSlice = function(n) {
		var n, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$deferred.push([(function() {
			if (!($interfaceIsEqual($recover(), $ifaceNil))) {
				$panic($pkg.ErrTooLarge);
			}
		}), []]);
		return $makeSlice(sliceType, n);
		/* */ } catch(err) { $err = err; return sliceType.nil; } finally { $callDeferred($deferred, $err); }
	};
	Buffer.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, b, e, err, m, n, nBytes, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; m = $f.m; n = $f.n; nBytes = $f.nBytes; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		nBytes = b.Len();
		/* */ if (nBytes > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (nBytes > 0) { */ case 1:
			_r = w.Write($subslice(b.buf, b.off)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (m > nBytes) {
				$panic(new $String("bytes.Buffer.WriteTo: invalid Write count"));
			}
			b.off = b.off + (m) >> 0;
			n = (new $Int64(0, m));
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp = n;
				_tmp$1 = e;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
			if (!((m === nBytes))) {
				_tmp$2 = n;
				_tmp$3 = io.ErrShortWrite;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
		/* } */ case 2:
		b.Reset();
		_tmp$4 = n;
		_tmp$5 = $ifaceNil;
		n = _tmp$4;
		err = _tmp$5;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.n = n; $f.nBytes = nBytes; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Buffer.ptr.prototype.WriteByte = function(c) {
		var _tuple, b, c, m, ok, x;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(1);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(1);
		}
		(x = b.buf, ((m < 0 || m >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + m] = c));
		return $ifaceNil;
	};
	Buffer.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Buffer.ptr.prototype.WriteRune = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, err, m, n, ok, r;
		n = 0;
		err = $ifaceNil;
		b = this;
		if (r < 128) {
			b.WriteByte(((r << 24 >>> 24)));
			_tmp = 1;
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(4);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(4);
		}
		n = utf8.EncodeRune($subslice(b.buf, m, (m + 4 >> 0)), r);
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		_tmp$2 = n;
		_tmp$3 = $ifaceNil;
		n = _tmp$2;
		err = _tmp$3;
		return [n, err];
	};
	Buffer.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Buffer.ptr.prototype.Read = function(p) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, err, n, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		if (b.empty()) {
			b.Reset();
			if (p.$length === 0) {
				_tmp = 0;
				_tmp$1 = $ifaceNil;
				n = _tmp;
				err = _tmp$1;
				return [n, err];
			}
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copySlice(p, $subslice(b.buf, b.off));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		_tmp$4 = n;
		_tmp$5 = $ifaceNil;
		n = _tmp$4;
		err = _tmp$5;
		return [n, err];
	};
	Buffer.prototype.Read = function(p) { return this.$val.Read(p); };
	Buffer.ptr.prototype.Next = function(n) {
		var b, data, m, n;
		b = this;
		b.lastRead = 0;
		m = b.Len();
		if (n > m) {
			n = m;
		}
		data = $subslice(b.buf, b.off, (b.off + n >> 0));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		return data;
	};
	Buffer.prototype.Next = function(n) { return this.$val.Next(n); };
	Buffer.ptr.prototype.ReadByte = function() {
		var b, c, x, x$1;
		b = this;
		if (b.empty()) {
			b.Reset();
			return [0, io.EOF];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		b.off = b.off + (1) >> 0;
		b.lastRead = -1;
		return [c, $ifaceNil];
	};
	Buffer.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Buffer.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, b, c, err, n, r, size, x, x$1;
		r = 0;
		size = 0;
		err = $ifaceNil;
		b = this;
		if (b.empty()) {
			b.Reset();
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			r = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [r, size, err];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (c < 128) {
			b.off = b.off + (1) >> 0;
			b.lastRead = 1;
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			r = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [r, size, err];
		}
		_tuple = utf8.DecodeRune($subslice(b.buf, b.off));
		r = _tuple[0];
		n = _tuple[1];
		b.off = b.off + (n) >> 0;
		b.lastRead = ((n << 24 >> 24));
		_tmp$6 = r;
		_tmp$7 = n;
		_tmp$8 = $ifaceNil;
		r = _tmp$6;
		size = _tmp$7;
		err = _tmp$8;
		return [r, size, err];
	};
	Buffer.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Buffer.ptr.prototype.UnreadRune = function() {
		var b;
		b = this;
		if (b.lastRead <= 0) {
			return errors.New("bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune");
		}
		if (b.off >= ((b.lastRead >> 0))) {
			b.off = b.off - (((b.lastRead >> 0))) >> 0;
		}
		b.lastRead = 0;
		return $ifaceNil;
	};
	Buffer.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Buffer.ptr.prototype.UnreadByte = function() {
		var b;
		b = this;
		if (b.lastRead === 0) {
			return errors.New("bytes.Buffer: UnreadByte: previous operation was not a successful read");
		}
		b.lastRead = 0;
		if (b.off > 0) {
			b.off = b.off - (1) >> 0;
		}
		return $ifaceNil;
	};
	Buffer.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Buffer.ptr.prototype.ReadBytes = function(delim) {
		var _tmp, _tmp$1, _tuple, b, delim, err, line, slice;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		line = $appendSlice(line, slice);
		_tmp = line;
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.ReadBytes = function(delim) { return this.$val.ReadBytes(delim); };
	Buffer.ptr.prototype.readSlice = function(delim) {
		var _tmp, _tmp$1, b, delim, end, err, i, line;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		i = IndexByte($subslice(b.buf, b.off), delim);
		end = (b.off + i >> 0) + 1 >> 0;
		if (i < 0) {
			end = b.buf.$length;
			err = io.EOF;
		}
		line = $subslice(b.buf, b.off, end);
		b.off = end;
		b.lastRead = -1;
		_tmp = line;
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.readSlice = function(delim) { return this.$val.readSlice(delim); };
	Buffer.ptr.prototype.ReadString = function(delim) {
		var _tmp, _tmp$1, _tuple, b, delim, err, line, slice;
		line = "";
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		_tmp = ($bytesToString(slice));
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.ReadString = function(delim) { return this.$val.ReadString(delim); };
	NewBufferString = function(s) {
		var s;
		return new Buffer.ptr((new sliceType($stringToBytes(s))), 0, 0);
	};
	$pkg.NewBufferString = NewBufferString;
	explode = function(s, n) {
		var _tuple, a, n, na, s, size;
		if (n <= 0) {
			n = s.$length;
		}
		a = $makeSlice(sliceType$1, n);
		size = 0;
		na = 0;
		while (true) {
			if (!(s.$length > 0)) { break; }
			if ((na + 1 >> 0) >= n) {
				((na < 0 || na >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + na] = s);
				na = na + (1) >> 0;
				break;
			}
			_tuple = utf8.DecodeRune(s);
			size = _tuple[1];
			((na < 0 || na >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + na] = $subslice(s, 0, size, size));
			s = $subslice(s, size);
			na = na + (1) >> 0;
		}
		return $subslice(a, 0, na);
	};
	Count = function(s, sep) {
		var i, n, s, sep;
		if (sep.$length === 0) {
			return utf8.RuneCount(s) + 1 >> 0;
		}
		if (sep.$length === 1) {
			return bytealg.Count(s, (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]));
		}
		n = 0;
		while (true) {
			i = Index(s, sep);
			if (i === -1) {
				return n;
			}
			n = n + (1) >> 0;
			s = $subslice(s, (i + sep.$length >> 0));
		}
	};
	$pkg.Count = Count;
	Contains = function(b, subslice) {
		var b, subslice;
		return !((Index(b, subslice) === -1));
	};
	$pkg.Contains = Contains;
	ContainsAny = function(b, chars) {
		var b, chars;
		return IndexAny(b, chars) >= 0;
	};
	$pkg.ContainsAny = ContainsAny;
	IndexAny = function(s, chars) {
		var _i, _i$1, _ref, _ref$1, _rune, _tuple, _tuple$1, as, c, ch, chars, i, i$1, isASCII, r, s, width;
		if (chars === "") {
			return -1;
		}
		if (s.$length > 8) {
			_tuple = makeASCIISet(chars);
			as = $clone(_tuple[0], asciiSet);
			isASCII = _tuple[1];
			if (isASCII) {
				_ref = s;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i = _i;
					c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (new ptrType$1(as).contains(c)) {
						return i;
					}
					_i++;
				}
				return -1;
			}
		}
		width = 0;
		i$1 = 0;
		while (true) {
			if (!(i$1 < s.$length)) { break; }
			r = ((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) >> 0));
			if (r < 128) {
				width = 1;
			} else {
				_tuple$1 = utf8.DecodeRune($subslice(s, i$1));
				r = _tuple$1[0];
				width = _tuple$1[1];
			}
			_ref$1 = chars;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.length)) { break; }
				_rune = $decodeRune(_ref$1, _i$1);
				ch = _rune[0];
				if (r === ch) {
					return i$1;
				}
				_i$1 += _rune[1];
			}
			i$1 = i$1 + (width) >> 0;
		}
		return -1;
	};
	$pkg.IndexAny = IndexAny;
	genSplit = function(s, sep, sepSave, n) {
		var a, i, m, n, s, sep, sepSave;
		if (n === 0) {
			return sliceType$1.nil;
		}
		if (sep.$length === 0) {
			return explode(s, n);
		}
		if (n < 0) {
			n = Count(s, sep) + 1 >> 0;
		}
		a = $makeSlice(sliceType$1, n);
		n = n - (1) >> 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			m = Index(s, sep);
			if (m < 0) {
				break;
			}
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $subslice(s, 0, (m + sepSave >> 0), (m + sepSave >> 0)));
			s = $subslice(s, (m + sep.$length >> 0));
			i = i + (1) >> 0;
		}
		((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = s);
		return $subslice(a, 0, (i + 1 >> 0));
	};
	Split = function(s, sep) {
		var s, sep;
		return genSplit(s, sep, 0, -1);
	};
	$pkg.Split = Split;
	HasPrefix = function(s, prefix) {
		var prefix, s;
		return s.$length >= prefix.$length && Equal($subslice(s, 0, prefix.$length), prefix);
	};
	$pkg.HasPrefix = HasPrefix;
	HasSuffix = function(s, suffix) {
		var s, suffix;
		return s.$length >= suffix.$length && Equal($subslice(s, (s.$length - suffix.$length >> 0)), suffix);
	};
	$pkg.HasSuffix = HasSuffix;
	Map = function(mapping, s) {
		var _r, _tuple, b, i, mapping, maxbytes, nb, nbytes, r, rl, s, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; i = $f.i; mapping = $f.mapping; maxbytes = $f.maxbytes; nb = $f.nb; nbytes = $f.nbytes; r = $f.r; rl = $f.rl; s = $f.s; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		maxbytes = s.$length;
		nbytes = 0;
		b = $makeSlice(sliceType, maxbytes);
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < s.$length)) { break; } */ if(!(i < s.$length)) { $s = 2; continue; }
			wid = 1;
			r = ((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >> 0));
			if (r >= 128) {
				_tuple = utf8.DecodeRune($subslice(s, i));
				r = _tuple[0];
				wid = _tuple[1];
			}
			_r = mapping(r); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if (r >= 0) {
				rl = utf8.RuneLen(r);
				if (rl < 0) {
					rl = 3;
				}
				if ((nbytes + rl >> 0) > maxbytes) {
					maxbytes = ($imul(maxbytes, 2)) + 4 >> 0;
					nb = $makeSlice(sliceType, maxbytes);
					$copySlice(nb, $subslice(b, 0, nbytes));
					b = nb;
				}
				nbytes = nbytes + (utf8.EncodeRune($subslice(b, nbytes, maxbytes), r)) >> 0;
			}
			i = i + (wid) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $subslice(b, 0, nbytes);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.i = i; $f.mapping = mapping; $f.maxbytes = maxbytes; $f.nb = nb; $f.nbytes = nbytes; $f.r = r; $f.rl = rl; $f.s = s; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Map = Map;
	Repeat = function(b, count) {
		var _q, b, bp, count, nb;
		if (count < 0) {
			$panic(new $String("bytes: negative Repeat count"));
		} else if (count > 0 && !(((_q = ($imul(b.$length, count)) / count, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) === b.$length))) {
			$panic(new $String("bytes: Repeat count causes overflow"));
		}
		nb = $makeSlice(sliceType, ($imul(b.$length, count)));
		bp = $copySlice(nb, b);
		while (true) {
			if (!(bp < nb.$length)) { break; }
			$copySlice($subslice(nb, bp), $subslice(nb, 0, bp));
			bp = $imul(bp, (2));
		}
		return nb;
	};
	$pkg.Repeat = Repeat;
	ToLower = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Map(unicode.ToLower, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ToLower }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ToLower = ToLower;
	TrimLeftFunc = function(s, f) {
		var _r, f, i, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; i = $f.i; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = indexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i === -1) {
			$s = -1; return sliceType.nil;
		}
		$s = -1; return $subslice(s, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimLeftFunc }; } $f._r = _r; $f.f = f; $f.i = i; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimLeftFunc = TrimLeftFunc;
	TrimRightFunc = function(s, f) {
		var _r, _tuple, f, i, s, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; s = $f.s; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = lastIndexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i >= 0 && ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >= 128) {
			_tuple = utf8.DecodeRune($subslice(s, i));
			wid = _tuple[1];
			i = i + (wid) >> 0;
		} else {
			i = i + (1) >> 0;
		}
		$s = -1; return $subslice(s, 0, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRightFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.s = s; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRightFunc = TrimRightFunc;
	TrimFunc = function(s, f) {
		var _r, _r$1, f, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimLeftFunc(s, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = TrimRightFunc(_r, f); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimFunc }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimFunc = TrimFunc;
	indexFunc = function(s, f, truth) {
		var _r, _tuple, f, r, s, start, truth, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; r = $f.r; s = $f.s; start = $f.start; truth = $f.truth; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		start = 0;
		/* while (true) { */ case 1:
			/* if (!(start < s.$length)) { break; } */ if(!(start < s.$length)) { $s = 2; continue; }
			wid = 1;
			r = ((((start < 0 || start >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + start]) >> 0));
			if (r >= 128) {
				_tuple = utf8.DecodeRune($subslice(s, start));
				r = _tuple[0];
				wid = _tuple[1];
			}
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return start;
			/* } */ case 4:
			start = start + (wid) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: indexFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.r = r; $f.s = s; $f.start = start; $f.truth = truth; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	lastIndexFunc = function(s, f, truth) {
		var _r, _tmp, _tmp$1, _tuple, f, i, r, s, size, truth, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; f = $f.f; i = $f.i; r = $f.r; s = $f.s; size = $f.size; truth = $f.truth; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = s.$length;
		/* while (true) { */ case 1:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 2; continue; }
			_tmp = (((x = i - 1 >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) >> 0));
			_tmp$1 = 1;
			r = _tmp;
			size = _tmp$1;
			if (r >= 128) {
				_tuple = utf8.DecodeLastRune($subslice(s, 0, i));
				r = _tuple[0];
				size = _tuple[1];
			}
			i = i - (size) >> 0;
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lastIndexFunc }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.size = size; $f.truth = truth; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeASCIISet = function(chars) {
		var _index, _tmp, _tmp$1, _tmp$2, _tmp$3, as, c, chars, i, ok, y;
		as = arrayType$1.zero();
		ok = false;
		i = 0;
		while (true) {
			if (!(i < chars.length)) { break; }
			c = chars.charCodeAt(i);
			if (c >= 128) {
				_tmp = $clone(as, asciiSet);
				_tmp$1 = false;
				asciiSet.copy(as, _tmp);
				ok = _tmp$1;
				return [as, ok];
			}
			_index = c >>> 5 << 24 >>> 24;
			((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index] = ((((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index]) | (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0));
			i = i + (1) >> 0;
		}
		_tmp$2 = $clone(as, asciiSet);
		_tmp$3 = true;
		asciiSet.copy(as, _tmp$2);
		ok = _tmp$3;
		return [as, ok];
	};
	asciiSet.prototype.contains = function(c) {
		var as, c, x, y;
		as = this.$val;
		return !((((((x = c >>> 5 << 24 >>> 24, (as.nilCheck, ((x < 0 || x >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[x]))) & (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0)) === 0));
	};
	$ptrType(asciiSet).prototype.contains = function(c) { return (new asciiSet(this.$get())).contains(c); };
	makeCutsetFunc = function(cutset) {
		var _tuple, as, cutset, isASCII;
		if ((cutset.length === 1) && cutset.charCodeAt(0) < 128) {
			return (function(r) {
				var r;
				return r === ((cutset.charCodeAt(0) >> 0));
			});
		}
		_tuple = makeASCIISet(cutset);
		as = $clone(_tuple[0], asciiSet);
		isASCII = _tuple[1];
		if (isASCII) {
			return (function(r) {
				var r;
				return r < 128 && new ptrType$1(as).contains(((r << 24 >>> 24)));
			});
		}
		return (function(r) {
			var _i, _ref, _rune, c, r;
			_ref = cutset;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				c = _rune[0];
				if (c === r) {
					return true;
				}
				_i += _rune[1];
			}
			return false;
		});
	};
	Trim = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Trim }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Trim = Trim;
	TrimSpace = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimFunc(s, unicode.IsSpace); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimSpace }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimSpace = TrimSpace;
	Replace = function(s, old, new$1, n) {
		var _tuple, i, j, m, n, new$1, old, s, start, t, w, wid;
		m = 0;
		if (!((n === 0))) {
			m = Count(s, old);
		}
		if (m === 0) {
			return $appendSlice((sliceType.nil), s);
		}
		if (n < 0 || m < n) {
			n = m;
		}
		t = $makeSlice(sliceType, (s.$length + ($imul(n, ((new$1.$length - old.$length >> 0)))) >> 0));
		w = 0;
		start = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			j = start;
			if (old.$length === 0) {
				if (i > 0) {
					_tuple = utf8.DecodeRune($subslice(s, start));
					wid = _tuple[1];
					j = j + (wid) >> 0;
				}
			} else {
				j = j + (Index($subslice(s, start), old)) >> 0;
			}
			w = w + ($copySlice($subslice(t, w), $subslice(s, start, j))) >> 0;
			w = w + ($copySlice($subslice(t, w), new$1)) >> 0;
			start = j + old.$length >> 0;
			i = i + (1) >> 0;
		}
		w = w + ($copySlice($subslice(t, w), $subslice(s, start))) >> 0;
		return $subslice(t, 0, w);
	};
	$pkg.Replace = Replace;
	ReplaceAll = function(s, old, new$1) {
		var new$1, old, s;
		return Replace(s, old, new$1, -1);
	};
	$pkg.ReplaceAll = ReplaceAll;
	Index = function(s, sep) {
		var c0, c0$1, c1, c1$1, fails, fails$1, i, i$1, j, n, o, o$1, r, s, sep, t, t$1, x, x$1;
		n = sep.$length;
		if ((n === 0)) {
			return 0;
		} else if ((n === 1)) {
			return IndexByte(s, (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]));
		} else if ((n === s.$length)) {
			if (Equal(sep, s)) {
				return 0;
			}
			return -1;
		} else if (n > s.$length) {
			return -1;
		} else if (n <= bytealg.MaxLen) {
			if (s.$length <= 0) {
				return bytealg.Index(s, sep);
			}
			c0 = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
			c1 = (1 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 1]);
			i = 0;
			t = (s.$length - n >> 0) + 1 >> 0;
			fails = 0;
			while (true) {
				if (!(i < t)) { break; }
				if (!((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === c0))) {
					o = IndexByte($subslice(s, i, t), c0);
					if (o < 0) {
						return -1;
					}
					i = i + (o) >> 0;
				}
				if (((x = i + 1 >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) === c1) && Equal($subslice(s, i, (i + n >> 0)), sep)) {
					return i;
				}
				fails = fails + (1) >> 0;
				i = i + (1) >> 0;
				if (fails > bytealg.Cutover(i)) {
					r = bytealg.Index($subslice(s, i), sep);
					if (r >= 0) {
						return r + i >> 0;
					}
					return -1;
				}
			}
			return -1;
		}
		c0$1 = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
		c1$1 = (1 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 1]);
		i$1 = 0;
		fails$1 = 0;
		t$1 = (s.$length - n >> 0) + 1 >> 0;
		while (true) {
			if (!(i$1 < t$1)) { break; }
			if (!((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) === c0$1))) {
				o$1 = IndexByte($subslice(s, i$1, t$1), c0$1);
				if (o$1 < 0) {
					break;
				}
				i$1 = i$1 + (o$1) >> 0;
			}
			if (((x$1 = i$1 + 1 >> 0, ((x$1 < 0 || x$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x$1])) === c1$1) && Equal($subslice(s, i$1, (i$1 + n >> 0)), sep)) {
				return i$1;
			}
			i$1 = i$1 + (1) >> 0;
			fails$1 = fails$1 + (1) >> 0;
			if (fails$1 >= (4 + (i$1 >> 4 >> 0) >> 0) && i$1 < t$1) {
				j = indexRabinKarp($subslice(s, i$1), sep);
				if (j < 0) {
					return -1;
				}
				return i$1 + j >> 0;
			}
		}
		return -1;
	};
	$pkg.Index = Index;
	indexRabinKarp = function(s, sep) {
		var _tuple, h, hashsep, i, i$1, n, pow, s, sep, x;
		_tuple = hashStr(sep);
		hashsep = _tuple[0];
		pow = _tuple[1];
		n = sep.$length;
		h = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			h = ($imul(h, 16777619) >>> 0) + ((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >>> 0)) >>> 0;
			i = i + (1) >> 0;
		}
		if ((h === hashsep) && Equal($subslice(s, 0, n), sep)) {
			return 0;
		}
		i$1 = n;
		while (true) {
			if (!(i$1 < s.$length)) { break; }
			h = $imul(h, (16777619)) >>> 0;
			h = h + (((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) >>> 0))) >>> 0;
			h = h - (($imul(pow, (((x = i$1 - n >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) >>> 0))) >>> 0)) >>> 0;
			i$1 = i$1 + (1) >> 0;
			if ((h === hashsep) && Equal($subslice(s, (i$1 - n >> 0), i$1), sep)) {
				return i$1 - n >> 0;
			}
		}
		return -1;
	};
	hashStr = function(sep) {
		var _tmp, _tmp$1, hash, i, i$1, pow, sep, sq;
		hash = 0;
		i = 0;
		while (true) {
			if (!(i < sep.$length)) { break; }
			hash = ($imul(hash, 16777619) >>> 0) + ((((i < 0 || i >= sep.$length) ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + i]) >>> 0)) >>> 0;
			i = i + (1) >> 0;
		}
		_tmp = 1;
		_tmp$1 = 16777619;
		pow = _tmp;
		sq = _tmp$1;
		i$1 = sep.$length;
		while (true) {
			if (!(i$1 > 0)) { break; }
			if (!(((i$1 & 1) === 0))) {
				pow = $imul(pow, (sq)) >>> 0;
			}
			sq = $imul(sq, (sq)) >>> 0;
			i$1 = (i$1 >> $min((1), 31)) >> 0;
		}
		return [hash, pow];
	};
	ptrType.methods = [{prop: "Bytes", name: "Bytes", pkg: "", typ: $funcType([], [sliceType], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "empty", name: "empty", pkg: "bytes", typ: $funcType([], [$Bool], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "tryGrowByReslice", name: "tryGrowByReslice", pkg: "bytes", typ: $funcType([$Int], [$Int, $Bool], false)}, {prop: "grow", name: "grow", pkg: "bytes", typ: $funcType([$Int], [$Int], false)}, {prop: "Grow", name: "Grow", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([io.Reader], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "Next", name: "Next", pkg: "", typ: $funcType([$Int], [sliceType], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadBytes", name: "ReadBytes", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "readSlice", name: "readSlice", pkg: "bytes", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadString", name: "ReadString", pkg: "", typ: $funcType([$Uint8], [$String, $error], false)}];
	ptrType$1.methods = [{prop: "contains", name: "contains", pkg: "bytes", typ: $funcType([$Uint8], [$Bool], false)}];
	Buffer.init("bytes", [{prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "off", name: "off", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastRead", name: "lastRead", embedded: false, exported: false, typ: readOp, tag: ""}]);
	asciiSet.init($Uint32, 8);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrTooLarge = errors.New("bytes.Buffer: too large");
		errNegativeRead = errors.New("bytes.Buffer: reader returned negative count from Read");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bufio"] = (function() {
	var $pkg = {}, $init, bytes, errors, io, utf8, errNegativeRead, errNegativeWrite;
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	io = $packages["io"];
	utf8 = $packages["unicode/utf8"];
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte");
		$pkg.ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune");
		$pkg.ErrBufferFull = errors.New("bufio: buffer full");
		$pkg.ErrNegativeCount = errors.New("bufio: negative count");
		errNegativeRead = errors.New("bufio: reader returned negative count from Read");
		errNegativeWrite = errors.New("bufio: writer returned negative count from Write");
		$pkg.ErrTooLong = errors.New("bufio.Scanner: token too long");
		$pkg.ErrNegativeAdvance = errors.New("bufio.Scanner: SplitFunc returns negative advance count");
		$pkg.ErrAdvanceTooFar = errors.New("bufio.Scanner: SplitFunc returns advance count beyond input");
		$pkg.ErrFinalToken = errors.New("final token");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/b3log/lute/html/atom"] = (function() {
	var $pkg = {}, $init, Atom, table, fnv, match, Lookup, String;
	Atom = $pkg.Atom = $newType(4, $kindUint32, "atom.Atom", true, "github.com/b3log/lute/html/atom", true, null);
	Atom.prototype.String = function() {
		var a, n, start;
		a = this.$val;
		start = (((a >>> 8 >>> 0) >>> 0));
		n = ((((a & 255) >>> 0) >>> 0));
		if ((start + n >>> 0) > 1834) {
			return "";
		}
		return $substring("abbradiogrouparamainavalueaccept-charsetbodyaccesskeygenobrbasefontimeupdateviacacheightmlabelooptgroupatternoembedetailsampictureversedfnoframesetdirnameterowspanomoduleacronymalignmarkbdialogallowpaymentrequestrikeytypeallowusermediagroupingaltfooterubyasyncanvasidefaultitleaudioncancelautofocusandboxmplaceholderautoplaysinlinebdoncanplaythrough1bgsoundisabledivarbigblinkindraggablegendblockquotebuttonabortcitempropenoncecolgrouplaintextrackcolorcolspannotation-xmlcommandcontrolshapecoordslotranslatecrossoriginsmallowfullscreenoscriptfacenterfieldsetfigcaptionafterprintegrityfigurequiredforeignObjectforeignobjectformactionautocompleteerrorformenctypemustmatchallengeformmethodformnovalidatetimeformtargethgrouposterhiddenhigh2hreflanghttp-equivideonclickiframeimageimglyph3isindexismappletitemtypemarqueematheadersortedmaxlength4minlength5mtextareadonlymultiplemutedoncloseamlessourceoncontextmenuitemidoncopyoncuechangeoncutondblclickondragendondragenterondragexitemreferrerpolicyondragleaveondragoverondragstarticleondropzonemptiedondurationchangeonendedonerroronfocuspaceronhashchangeoninputmodeloninvalidonkeydownloadonkeypresspellcheckedonkeyupreloadonlanguagechangeonloadeddatalistingonloadedmetadatabindexonloadendonloadstartonmessageerroronmousedownonmouseenteronmouseleaveonmousemoveonmouseoutputonmouseoveronmouseupromptonmousewheelonofflineononlineonpagehidesclassectionbluronpageshowbronpastepublicontenteditableonpausemaponplayingonpopstateonprogressrcdocodeferonratechangeonrejectionhandledonresetonresizesrclangonscrollonsecuritypolicyviolationauxclickonseekedonseekingonselectedonshowidth6onsortableonstalledonstorageonsubmitemscopedonsuspendontoggleonunhandledrejectionbeforeprintonunloadonvolumechangeonwaitingonwheeloptimumanifestrongoptionbeforeunloaddressrcsetstylesummarysupsvgsystemplateworkertypewrap", start, (start + n >>> 0));
	};
	$ptrType(Atom).prototype.String = function() { return new Atom(this.$get()).String(); };
	Atom.prototype.string = function() {
		var a;
		a = this.$val;
		return $substring("abbradiogrouparamainavalueaccept-charsetbodyaccesskeygenobrbasefontimeupdateviacacheightmlabelooptgroupatternoembedetailsampictureversedfnoframesetdirnameterowspanomoduleacronymalignmarkbdialogallowpaymentrequestrikeytypeallowusermediagroupingaltfooterubyasyncanvasidefaultitleaudioncancelautofocusandboxmplaceholderautoplaysinlinebdoncanplaythrough1bgsoundisabledivarbigblinkindraggablegendblockquotebuttonabortcitempropenoncecolgrouplaintextrackcolorcolspannotation-xmlcommandcontrolshapecoordslotranslatecrossoriginsmallowfullscreenoscriptfacenterfieldsetfigcaptionafterprintegrityfigurequiredforeignObjectforeignobjectformactionautocompleteerrorformenctypemustmatchallengeformmethodformnovalidatetimeformtargethgrouposterhiddenhigh2hreflanghttp-equivideonclickiframeimageimglyph3isindexismappletitemtypemarqueematheadersortedmaxlength4minlength5mtextareadonlymultiplemutedoncloseamlessourceoncontextmenuitemidoncopyoncuechangeoncutondblclickondragendondragenterondragexitemreferrerpolicyondragleaveondragoverondragstarticleondropzonemptiedondurationchangeonendedonerroronfocuspaceronhashchangeoninputmodeloninvalidonkeydownloadonkeypresspellcheckedonkeyupreloadonlanguagechangeonloadeddatalistingonloadedmetadatabindexonloadendonloadstartonmessageerroronmousedownonmouseenteronmouseleaveonmousemoveonmouseoutputonmouseoveronmouseupromptonmousewheelonofflineononlineonpagehidesclassectionbluronpageshowbronpastepublicontenteditableonpausemaponplayingonpopstateonprogressrcdocodeferonratechangeonrejectionhandledonresetonresizesrclangonscrollonsecuritypolicyviolationauxclickonseekedonseekingonselectedonshowidth6onsortableonstalledonstorageonsubmitemscopedonsuspendontoggleonunhandledrejectionbeforeprintonunloadonvolumechangeonwaitingonwheeloptimumanifestrongoptionbeforeunloaddressrcsetstylesummarysupsvgsystemplateworkertypewrap", (a >>> 8 >>> 0), ((a >>> 8 >>> 0) + ((a & 255) >>> 0) >>> 0));
	};
	$ptrType(Atom).prototype.string = function() { return new Atom(this.$get()).string(); };
	fnv = function(h, s) {
		var _i, _ref, h, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			h = (h ^ (((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >>> 0)))) >>> 0;
			h = $imul(h, (16777619)) >>> 0;
			_i++;
		}
		return h;
	};
	match = function(s, t) {
		var _i, _ref, c, i, s, t;
		_ref = t;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((s.charCodeAt(i) === c))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	Lookup = function(s) {
		var a, a$1, h, s, x, x$1;
		if ((s.$length === 0) || s.$length > 25) {
			return 0;
		}
		h = fnv(2177757454, s);
		a = (x = (h & 511) >>> 0, ((x < 0 || x >= table.length) ? ($throwRuntimeError("index out of range"), undefined) : table[x]));
		if ((((((a & 255) >>> 0) >> 0)) === s.$length) && match(new Atom(a).string(), s)) {
			return a;
		}
		a$1 = (x$1 = (((h >>> 16 >>> 0)) & 511) >>> 0, ((x$1 < 0 || x$1 >= table.length) ? ($throwRuntimeError("index out of range"), undefined) : table[x$1]));
		if ((((((a$1 & 255) >>> 0) >> 0)) === s.$length) && match(new Atom(a$1).string(), s)) {
			return a$1;
		}
		return 0;
	};
	$pkg.Lookup = Lookup;
	String = function(s) {
		var a, s;
		a = Lookup(s);
		if (!((a === 0))) {
			return new Atom(a).String();
		}
		return ($bytesToString(s));
	};
	$pkg.String = String;
	Atom.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "string", name: "string", pkg: "github.com/b3log/lute/html/atom", typ: $funcType([], [$String], false)}];
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		table = $toNativeArray($kindUint32, [0, 58890, 189444, 0, 11273, 35592, 0, 408072, 463110, 0, 411909, 0, 166155, 79618, 235275, 0, 84739, 70917, 96777, 0, 192773, 176386, 231172, 184070, 0, 62982, 174086, 178184, 103687, 17934, 65285, 302342, 0, 71944, 403720, 197125, 382994, 0, 95236, 335110, 209156, 327436, 360199, 369673, 115719, 0, 0, 114437, 390404, 190474, 0, 1537, 350474, 429076, 0, 272903, 0, 0, 15112, 0, 0, 0, 0, 4867, 96004, 218888, 198662, 0, 45570, 0, 185606, 462339, 361220, 147209, 361990, 0, 109315, 100106, 216834, 0, 375048, 390405, 214274, 0, 0, 0, 208901, 54791, 374538, 281353, 241929, 0, 0, 238085, 276230, 109320, 0, 0, 91394, 0, 0, 15362, 346121, 210694, 0, 298256, 0, 0, 277772, 38404, 62725, 352516, 212227, 0, 125446, 199938, 452366, 39940, 408582, 38917, 232198, 343052, 376838, 0, 0, 113157, 0, 204552, 0, 0, 41986, 269064, 209159, 379916, 395289, 0, 304392, 321547, 126724, 307216, 6662, 157702, 0, 0, 0, 439054, 8455, 161299, 49427, 10244, 68103, 408584, 138756, 124165, 0, 427016, 0, 0, 412418, 46596, 0, 2817, 0, 0, 437000, 23812, 91144, 0, 0, 0, 271111, 45066, 0, 424713, 217349, 413446, 105736, 0, 0, 422153, 94981, 0, 241926, 42754, 159236, 76039, 35589, 5381, 418313, 0, 0, 43527, 104962, 0, 514, 140808, 167949, 41480, 27655, 433677, 102662, 193799, 459783, 0, 0, 64260, 353285, 259083, 143623, 0, 0, 0, 56590, 315147, 0, 0, 0, 92931, 305412, 208388, 281349, 0, 0, 256522, 187906, 0, 111113, 0, 324364, 0, 0, 293127, 290819, 0, 220936, 47619, 212233, 52993, 401162, 0, 359427, 0, 15108, 451334, 0, 267024, 0, 35080, 0, 263432, 0, 423173, 32776, 244235, 260613, 77571, 391431, 198403, 0, 0, 257, 152579, 67333, 280839, 218628, 173066, 468484, 0, 146434, 289546, 26626, 0, 214786, 222981, 62211, 378116, 28162, 247050, 0, 40708, 0, 448264, 231176, 363271, 0, 442633, 0, 312841, 0, 228877, 0, 355590, 261127, 37635, 61188, 150536, 283913, 45317, 0, 363012, 412930, 115716, 142858, 286217, 420616, 85257, 461571, 3073, 0, 264713, 233734, 105476, 239370, 0, 330507, 0, 421123, 296707, 24328, 0, 0, 0, 39943, 227334, 136712, 107268, 132099, 152589, 371978, 0, 167175, 161294, 217608, 0, 161804, 87810, 122376, 67842, 0, 144908, 0, 155917, 206599, 367111, 386562, 20998, 214787, 37639, 127497, 22020, 214793, 296455, 463880, 253707, 14850, 0, 376835, 449798, 0, 30724, 455431, 348424, 0, 78091, 181254, 132613, 444935, 117002, 291850, 29191, 66310, 73993, 3077, 0, 287496, 283139, 224263, 47363, 203014, 188420, 389384, 0, 302348, 0, 52226, 180234, 69637, 458501, 53766, 368134, 195590, 4100, 0, 31495, 0, 0, 202245, 0, 304388, 22789, 0, 250126, 87554, 0, 341510, 354311, 0, 446727, 187140, 89090, 416009, 93443, 16900, 0, 422914, 209158, 317961, 108037, 159242, 139270, 14084, 365829, 305415, 98566, 0, 170761, 149510, 58885, 0, 0, 55556, 16132, 317966, 225544, 34563, 378629, 49923, 104963, 336651, 176650, 465930, 0, 249095, 0, 0, 1, 202755, 16396, 89607, 12806, 9989, 0, 0, 410630, 0, 9473, 26119, 0, 0, 0, 85264, 0, 186114, 456966, 94211, 0, 413960, 294919, 0, 369670, 0, 309252, 262918, 0, 393224, 129803, 357130, 4, 37378, 363279, 160262, 81931, 274695, 188424, 0, 333322, 387591, 80904, 405769, 0, 423174, 0, 778, 0, 229387, 339465, 0, 182790, 133135, 310792, 0, 0, 200455, 6670, 175630, 0, 0, 117006, 28165, 137222, 47878, 120583]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math/bits"] = (function() {
	var $pkg = {}, $init, deBruijn32tab, deBruijn64tab, TrailingZeros, TrailingZeros32, TrailingZeros64;
	TrailingZeros = function(x) {
		var x;
		if (true) {
			return TrailingZeros32(((x >>> 0)));
		}
		return TrailingZeros64((new $Uint64(0, x)));
	};
	$pkg.TrailingZeros = TrailingZeros;
	TrailingZeros32 = function(x) {
		var x, x$1;
		if (x === 0) {
			return 32;
		}
		return (((x$1 = ($imul((((x & (-x >>> 0)) >>> 0)), 125613361) >>> 0) >>> 27 >>> 0, ((x$1 < 0 || x$1 >= deBruijn32tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn32tab[x$1])) >> 0));
	};
	$pkg.TrailingZeros32 = TrailingZeros32;
	TrailingZeros64 = function(x) {
		var x, x$1, x$2;
		if ((x.$high === 0 && x.$low === 0)) {
			return 64;
		}
		return (((x$1 = $shiftRightUint64($mul64(((x$2 = new $Uint64(-x.$high, -x.$low), new $Uint64(x.$high & x$2.$high, (x.$low & x$2.$low) >>> 0))), new $Uint64(66559345, 3033172745)), 58), (($flatten64(x$1) < 0 || $flatten64(x$1) >= deBruijn64tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn64tab[$flatten64(x$1)])) >> 0));
	};
	$pkg.TrailingZeros64 = TrailingZeros64;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		deBruijn32tab = $toNativeArray($kindUint8, [0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9]);
		deBruijn64tab = $toNativeArray($kindUint8, [0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math"] = (function() {
	var $pkg = {}, $init, js, bits, arrayType, arrayType$1, arrayType$2, structType, math, buf, init;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bits = $packages["math/bits"];
	arrayType = $arrayType($Uint32, 2);
	arrayType$1 = $arrayType($Float32, 2);
	arrayType$2 = $arrayType($Float64, 1);
	structType = $structType("math", [{prop: "uint32array", name: "uint32array", embedded: false, exported: false, typ: arrayType, tag: ""}, {prop: "float32array", name: "float32array", embedded: false, exported: false, typ: arrayType$1, tag: ""}, {prop: "float64array", name: "float64array", embedded: false, exported: false, typ: arrayType$2, tag: ""}]);
	init = function() {
		var ab;
		ab = new ($global.ArrayBuffer)(8);
		buf.uint32array = new ($global.Uint32Array)(ab);
		buf.float32array = new ($global.Float32Array)(ab);
		buf.float64array = new ($global.Float64Array)(ab);
	};
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		buf = new structType.ptr(arrayType.zero(), arrayType$1.zero(), arrayType$2.zero());
		math = $global.Math;
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strconv"] = (function() {
	var $pkg = {}, $init, errors, bytealg, math, bits, utf8, NumError, sliceType$4, sliceType$5, sliceType$6, ptrType, arrayType$3, arrayType$4, isPrint16, isNotPrint16, isPrint32, isNotPrint32, isGraphic, syntaxError, rangeError, baseError, bitSizeError, ParseUint, ParseInt, Atoi, FormatInt, Itoa, small, formatBits, isPowerOfTwo, quoteWith, appendQuotedWith, appendEscapedRune, Quote, bsearch16, bsearch32, IsPrint, isInGraphicList;
	errors = $packages["errors"];
	bytealg = $packages["internal/bytealg"];
	math = $packages["math"];
	bits = $packages["math/bits"];
	utf8 = $packages["unicode/utf8"];
	NumError = $pkg.NumError = $newType(0, $kindStruct, "strconv.NumError", true, "strconv", true, function(Func_, Num_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Func = "";
			this.Num = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Func = Func_;
		this.Num = Num_;
		this.Err = Err_;
	});
	sliceType$4 = $sliceType($Uint16);
	sliceType$5 = $sliceType($Uint32);
	sliceType$6 = $sliceType($Uint8);
	ptrType = $ptrType(NumError);
	arrayType$3 = $arrayType($Uint8, 65);
	arrayType$4 = $arrayType($Uint8, 4);
	NumError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return "strconv." + e.Func + ": " + "parsing " + Quote(e.Num) + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NumError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	NumError.prototype.Error = function() { return this.$val.Error(); };
	syntaxError = function(fn, str) {
		var fn, str;
		return new NumError.ptr(fn, str, $pkg.ErrSyntax);
	};
	rangeError = function(fn, str) {
		var fn, str;
		return new NumError.ptr(fn, str, $pkg.ErrRange);
	};
	baseError = function(fn, str, base) {
		var base, fn, str;
		return new NumError.ptr(fn, str, errors.New("invalid base " + Itoa(base)));
	};
	bitSizeError = function(fn, str, bitSize) {
		var bitSize, fn, str;
		return new NumError.ptr(fn, str, errors.New("invalid bit size " + Itoa(bitSize)));
	};
	ParseUint = function(s, base, bitSize) {
		var _1, _i, _ref, base, bitSize, c, cutoff, d, maxVal, n, n1, s, s0, x, x$1, x$2;
		if (s.length === 0) {
			return [new $Uint64(0, 0), syntaxError("ParseUint", s)];
		}
		s0 = s;
		if (2 <= base && base <= 36) {
		} else if ((base === 0)) {
			if ((s.charCodeAt(0) === 48) && s.length > 1 && ((s.charCodeAt(1) === 120) || (s.charCodeAt(1) === 88))) {
				if (s.length < 3) {
					return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
				}
				base = 16;
				s = $substring(s, 2);
			} else if ((s.charCodeAt(0) === 48)) {
				base = 8;
				s = $substring(s, 1);
			} else {
				base = 10;
			}
		} else {
			return [new $Uint64(0, 0), baseError("ParseUint", s0, base)];
		}
		if (bitSize === 0) {
			bitSize = 32;
		} else if (bitSize < 0 || bitSize > 64) {
			return [new $Uint64(0, 0), bitSizeError("ParseUint", s0, bitSize)];
		}
		cutoff = new $Uint64(0, 0);
		_1 = base;
		if (_1 === (10)) {
			cutoff = new $Uint64(429496729, 2576980378);
		} else if (_1 === (16)) {
			cutoff = new $Uint64(268435456, 0);
		} else {
			cutoff = (x = $div64(new $Uint64(4294967295, 4294967295), (new $Uint64(0, base)), false), new $Uint64(x.$high + 0, x.$low + 1));
		}
		maxVal = (x$1 = $shiftLeft64(new $Uint64(0, 1), ((bitSize >>> 0))), new $Uint64(x$1.$high - 0, x$1.$low - 1));
		n = new $Uint64(0, 0);
		_ref = (new sliceType$6($stringToBytes(s)));
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			d = 0;
			if (48 <= c && c <= 57) {
				d = c - 48 << 24 >>> 24;
			} else if (97 <= c && c <= 122) {
				d = (c - 97 << 24 >>> 24) + 10 << 24 >>> 24;
			} else if (65 <= c && c <= 90) {
				d = (c - 65 << 24 >>> 24) + 10 << 24 >>> 24;
			} else {
				return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
			}
			if (d >= ((base << 24 >>> 24))) {
				return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
			}
			if ((n.$high > cutoff.$high || (n.$high === cutoff.$high && n.$low >= cutoff.$low))) {
				return [maxVal, rangeError("ParseUint", s0)];
			}
			n = $mul64(n, ((new $Uint64(0, base))));
			n1 = (x$2 = (new $Uint64(0, d)), new $Uint64(n.$high + x$2.$high, n.$low + x$2.$low));
			if ((n1.$high < n.$high || (n1.$high === n.$high && n1.$low < n.$low)) || (n1.$high > maxVal.$high || (n1.$high === maxVal.$high && n1.$low > maxVal.$low))) {
				return [maxVal, rangeError("ParseUint", s0)];
			}
			n = n1;
			_i++;
		}
		return [n, $ifaceNil];
	};
	$pkg.ParseUint = ParseUint;
	ParseInt = function(s, base, bitSize) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, base, bitSize, cutoff, err, i, n, neg, s, s0, un, x, x$1;
		i = new $Int64(0, 0);
		err = $ifaceNil;
		if (s.length === 0) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = syntaxError("ParseInt", s);
			i = _tmp;
			err = _tmp$1;
			return [i, err];
		}
		s0 = s;
		neg = false;
		if (s.charCodeAt(0) === 43) {
			s = $substring(s, 1);
		} else if (s.charCodeAt(0) === 45) {
			neg = true;
			s = $substring(s, 1);
		}
		un = new $Uint64(0, 0);
		_tuple = ParseUint(s, base, bitSize);
		un = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil)) && !($interfaceIsEqual($assertType(err, ptrType).Err, $pkg.ErrRange))) {
			$assertType(err, ptrType).Func = "ParseInt";
			$assertType(err, ptrType).Num = s0;
			_tmp$2 = new $Int64(0, 0);
			_tmp$3 = err;
			i = _tmp$2;
			err = _tmp$3;
			return [i, err];
		}
		if (bitSize === 0) {
			bitSize = 32;
		}
		cutoff = ($shiftLeft64(new $Uint64(0, 1), (((bitSize - 1 >> 0) >>> 0))));
		if (!neg && (un.$high > cutoff.$high || (un.$high === cutoff.$high && un.$low >= cutoff.$low))) {
			_tmp$4 = ((x = new $Uint64(cutoff.$high - 0, cutoff.$low - 1), new $Int64(x.$high, x.$low)));
			_tmp$5 = rangeError("ParseInt", s0);
			i = _tmp$4;
			err = _tmp$5;
			return [i, err];
		}
		if (neg && (un.$high > cutoff.$high || (un.$high === cutoff.$high && un.$low > cutoff.$low))) {
			_tmp$6 = (x$1 = (new $Int64(cutoff.$high, cutoff.$low)), new $Int64(-x$1.$high, -x$1.$low));
			_tmp$7 = rangeError("ParseInt", s0);
			i = _tmp$6;
			err = _tmp$7;
			return [i, err];
		}
		n = (new $Int64(un.$high, un.$low));
		if (neg) {
			n = new $Int64(-n.$high, -n.$low);
		}
		_tmp$8 = n;
		_tmp$9 = $ifaceNil;
		i = _tmp$8;
		err = _tmp$9;
		return [i, err];
	};
	$pkg.ParseInt = ParseInt;
	Atoi = function(s) {
		var _i, _ref, _tuple, _tuple$1, ch, err, i64, n, nerr, ok, s, s0, sLen;
		sLen = s.length;
		if (true && (0 < sLen && sLen < 10) || false && (0 < sLen && sLen < 19)) {
			s0 = s;
			if ((s.charCodeAt(0) === 45) || (s.charCodeAt(0) === 43)) {
				s = $substring(s, 1);
				if (s.length < 1) {
					return [0, new NumError.ptr("Atoi", s0, $pkg.ErrSyntax)];
				}
			}
			n = 0;
			_ref = (new sliceType$6($stringToBytes(s)));
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				ch = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				ch = ch - (48) << 24 >>> 24;
				if (ch > 9) {
					return [0, new NumError.ptr("Atoi", s0, $pkg.ErrSyntax)];
				}
				n = ($imul(n, 10)) + ((ch >> 0)) >> 0;
				_i++;
			}
			if (s0.charCodeAt(0) === 45) {
				n = -n;
			}
			return [n, $ifaceNil];
		}
		_tuple = ParseInt(s, 10, 0);
		i64 = _tuple[0];
		err = _tuple[1];
		_tuple$1 = $assertType(err, ptrType, true);
		nerr = _tuple$1[0];
		ok = _tuple$1[1];
		if (ok) {
			nerr.Func = "Atoi";
		}
		return [(((i64.$low + ((i64.$high >> 31) * 4294967296)) >> 0)), err];
	};
	$pkg.Atoi = Atoi;
	FormatInt = function(i, base) {
		var _tuple, base, i, s;
		if (true && (0 < i.$high || (0 === i.$high && 0 <= i.$low)) && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return small((((i.$low + ((i.$high >> 31) * 4294967296)) >> 0)));
		}
		_tuple = formatBits(sliceType$6.nil, (new $Uint64(i.$high, i.$low)), base, (i.$high < 0 || (i.$high === 0 && i.$low < 0)), false);
		s = _tuple[1];
		return s;
	};
	$pkg.FormatInt = FormatInt;
	Itoa = function(i) {
		var i;
		return FormatInt((new $Int64(0, i)), 10);
	};
	$pkg.Itoa = Itoa;
	small = function(i) {
		var i;
		if (i < 10) {
			return $substring("0123456789abcdefghijklmnopqrstuvwxyz", i, (i + 1 >> 0));
		}
		return $substring("00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", ($imul(i, 2)), (($imul(i, 2)) + 2 >> 0));
	};
	formatBits = function(dst, u, base, neg, append_) {
		var _q, _q$1, _r, _r$1, a, append_, b, b$1, base, d, dst, i, is, is$1, is$2, j, m, neg, q, q$1, s, shift, u, us, us$1, x, x$1, x$2, x$3, x$4, x$5;
		d = sliceType$6.nil;
		s = "";
		if (base < 2 || base > 36) {
			$panic(new $String("strconv: illegal AppendInt/FormatInt base"));
		}
		a = arrayType$3.zero();
		i = 65;
		if (neg) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		if (base === 10) {
			if (true) {
				while (true) {
					if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 1000000000)))) { break; }
					q = $div64(u, new $Uint64(0, 1000000000), false);
					us = (((x = $mul64(q, new $Uint64(0, 1000000000)), new $Uint64(u.$high - x.$high, u.$low - x.$low)).$low >>> 0));
					j = 4;
					while (true) {
						if (!(j > 0)) { break; }
						is = (_r = us % 100, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
						us = (_q = us / (100), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
						i = i - (2) >> 0;
						(x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$1] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 1 >>> 0))));
						(x$2 = i + 0 >> 0, ((x$2 < 0 || x$2 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$2] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 0 >>> 0))));
						j = j - (1) >> 0;
					}
					i = i - (1) >> 0;
					((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(((us * 2 >>> 0) + 1 >>> 0)));
					u = q;
				}
			}
			us$1 = ((u.$low >>> 0));
			while (true) {
				if (!(us$1 >= 100)) { break; }
				is$1 = (_r$1 = us$1 % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
				us$1 = (_q$1 = us$1 / (100), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
				i = i - (2) >> 0;
				(x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$3] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 1 >>> 0))));
				(x$4 = i + 0 >> 0, ((x$4 < 0 || x$4 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$4] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 0 >>> 0))));
			}
			is$2 = us$1 * 2 >>> 0;
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$2 + 1 >>> 0)));
			if (us$1 >= 10) {
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(is$2));
			}
		} else if (isPowerOfTwo(base)) {
			shift = (((bits.TrailingZeros(((base >>> 0))) >>> 0)) & 7) >>> 0;
			b = (new $Uint64(0, base));
			m = ((base >>> 0)) - 1 >>> 0;
			while (true) {
				if (!((u.$high > b.$high || (u.$high === b.$high && u.$low >= b.$low)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((((u.$low >>> 0)) & m) >>> 0)));
				u = $shiftRightUint64(u, (shift));
			}
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
		} else {
			b$1 = (new $Uint64(0, base));
			while (true) {
				if (!((u.$high > b$1.$high || (u.$high === b$1.$high && u.$low >= b$1.$low)))) { break; }
				i = i - (1) >> 0;
				q$1 = $div64(u, b$1, false);
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((((x$5 = $mul64(q$1, b$1), new $Uint64(u.$high - x$5.$high, u.$low - x$5.$low)).$low >>> 0))));
				u = q$1;
			}
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
		}
		if (neg) {
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = 45);
		}
		if (append_) {
			d = $appendSlice(dst, $subslice(new sliceType$6(a), i));
			return [d, s];
		}
		s = ($bytesToString($subslice(new sliceType$6(a), i)));
		return [d, s];
	};
	isPowerOfTwo = function(x) {
		var x;
		return (x & ((x - 1 >> 0))) === 0;
	};
	quoteWith = function(s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _q, graphicOnly, quote, s;
		return ($bytesToString(appendQuotedWith($makeSlice(sliceType$6, 0, (_q = ($imul(3, s.length)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))), s, quote, ASCIIonly, graphicOnly)));
	};
	appendQuotedWith = function(buf, s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _tuple, buf, graphicOnly, quote, r, s, width;
		buf = $append(buf, quote);
		width = 0;
		while (true) {
			if (!(s.length > 0)) { break; }
			r = ((s.charCodeAt(0) >> 0));
			width = 1;
			if (r >= 128) {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				width = _tuple[1];
			}
			if ((width === 1) && (r === 65533)) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((s.charCodeAt(0) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((s.charCodeAt(0) & 15) >>> 0)));
				s = $substring(s, width);
				continue;
			}
			buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
			s = $substring(s, width);
		}
		buf = $append(buf, quote);
		return buf;
	};
	appendEscapedRune = function(buf, r, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _1, buf, graphicOnly, n, quote, r, runeTmp, s, s$1;
		runeTmp = arrayType$4.zero();
		if ((r === ((quote >> 0))) || (r === 92)) {
			buf = $append(buf, 92);
			buf = $append(buf, ((r << 24 >>> 24)));
			return buf;
		}
		if (ASCIIonly) {
			if (r < 128 && IsPrint(r)) {
				buf = $append(buf, ((r << 24 >>> 24)));
				return buf;
			}
		} else if (IsPrint(r) || graphicOnly && isInGraphicList(r)) {
			n = utf8.EncodeRune(new sliceType$6(runeTmp), r);
			buf = $appendSlice(buf, $subslice(new sliceType$6(runeTmp), 0, n));
			return buf;
		}
		_1 = r;
		if (_1 === (7)) {
			buf = $appendSlice(buf, "\\a");
		} else if (_1 === (8)) {
			buf = $appendSlice(buf, "\\b");
		} else if (_1 === (12)) {
			buf = $appendSlice(buf, "\\f");
		} else if (_1 === (10)) {
			buf = $appendSlice(buf, "\\n");
		} else if (_1 === (13)) {
			buf = $appendSlice(buf, "\\r");
		} else if (_1 === (9)) {
			buf = $appendSlice(buf, "\\t");
		} else if (_1 === (11)) {
			buf = $appendSlice(buf, "\\v");
		} else {
			if (r < 32) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((((r << 24 >>> 24)) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((((r << 24 >>> 24)) & 15) >>> 0)));
			} else if (r > 1114111) {
				r = 65533;
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else if (r < 65536) {
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else {
				buf = $appendSlice(buf, "\\U");
				s$1 = 28;
				while (true) {
					if (!(s$1 >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s$1 >>> 0)), 31)) >> 0) & 15)));
					s$1 = s$1 - (4) >> 0;
				}
			}
		}
		return buf;
	};
	Quote = function(s) {
		var s;
		return quoteWith(s, 34, false, false);
	};
	$pkg.Quote = Quote;
	bsearch16 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	bsearch32 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	IsPrint = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, i, i$1, isNotPrint, isNotPrint$1, isPrint, isPrint$1, j, j$1, r, rr, rr$1, x, x$1, x$2, x$3;
		if (r <= 255) {
			if (32 <= r && r <= 126) {
				return true;
			}
			if (161 <= r && r <= 255) {
				return !((r === 173));
			}
			return false;
		}
		if (0 <= r && r < 65536) {
			_tmp = ((r << 16 >>> 16));
			_tmp$1 = isPrint16;
			_tmp$2 = isNotPrint16;
			rr = _tmp;
			isPrint = _tmp$1;
			isNotPrint = _tmp$2;
			i = bsearch16(isPrint, rr);
			if (i >= isPrint.$length || rr < (x = (i & ~1) >> 0, ((x < 0 || x >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x])) || (x$1 = i | 1, ((x$1 < 0 || x$1 >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x$1])) < rr) {
				return false;
			}
			j = bsearch16(isNotPrint, rr);
			return j >= isNotPrint.$length || !((((j < 0 || j >= isNotPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint.$array[isNotPrint.$offset + j]) === rr));
		}
		_tmp$3 = ((r >>> 0));
		_tmp$4 = isPrint32;
		_tmp$5 = isNotPrint32;
		rr$1 = _tmp$3;
		isPrint$1 = _tmp$4;
		isNotPrint$1 = _tmp$5;
		i$1 = bsearch32(isPrint$1, rr$1);
		if (i$1 >= isPrint$1.$length || rr$1 < (x$2 = (i$1 & ~1) >> 0, ((x$2 < 0 || x$2 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$2])) || (x$3 = i$1 | 1, ((x$3 < 0 || x$3 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$3])) < rr$1) {
			return false;
		}
		if (r >= 131072) {
			return true;
		}
		r = r - (65536) >> 0;
		j$1 = bsearch16(isNotPrint$1, ((r << 16 >>> 16)));
		return j$1 >= isNotPrint$1.$length || !((((j$1 < 0 || j$1 >= isNotPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint$1.$array[isNotPrint$1.$offset + j$1]) === ((r << 16 >>> 16))));
	};
	$pkg.IsPrint = IsPrint;
	isInGraphicList = function(r) {
		var i, r, rr;
		if (r > 65535) {
			return false;
		}
		rr = ((r << 16 >>> 16));
		i = bsearch16(isGraphic, rr);
		return i < isGraphic.$length && (rr === ((i < 0 || i >= isGraphic.$length) ? ($throwRuntimeError("index out of range"), undefined) : isGraphic.$array[isGraphic.$offset + i]));
	};
	ptrType.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	NumError.init("", [{prop: "Func", name: "Func", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Num", name: "Num", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", embedded: false, exported: true, typ: $error, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrRange = errors.New("value out of range");
		$pkg.ErrSyntax = errors.New("invalid syntax");
		isPrint16 = new sliceType$4([32, 126, 161, 887, 890, 895, 900, 1366, 1369, 1418, 1421, 1479, 1488, 1514, 1520, 1524, 1542, 1563, 1566, 1805, 1808, 1866, 1869, 1969, 1984, 2042, 2048, 2093, 2096, 2139, 2142, 2154, 2208, 2237, 2260, 2444, 2447, 2448, 2451, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2531, 2534, 2557, 2561, 2570, 2575, 2576, 2579, 2617, 2620, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2654, 2662, 2677, 2689, 2745, 2748, 2765, 2768, 2768, 2784, 2787, 2790, 2801, 2809, 2828, 2831, 2832, 2835, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2915, 2918, 2935, 2946, 2954, 2958, 2965, 2969, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3021, 3024, 3024, 3031, 3031, 3046, 3066, 3072, 3129, 3133, 3149, 3157, 3162, 3168, 3171, 3174, 3183, 3192, 3257, 3260, 3277, 3285, 3286, 3294, 3299, 3302, 3314, 3328, 3407, 3412, 3427, 3430, 3455, 3458, 3478, 3482, 3517, 3520, 3526, 3530, 3530, 3535, 3551, 3558, 3567, 3570, 3572, 3585, 3642, 3647, 3675, 3713, 3716, 3719, 3722, 3725, 3725, 3732, 3751, 3754, 3773, 3776, 3789, 3792, 3801, 3804, 3807, 3840, 3948, 3953, 4058, 4096, 4295, 4301, 4301, 4304, 4685, 4688, 4701, 4704, 4749, 4752, 4789, 4792, 4805, 4808, 4885, 4888, 4954, 4957, 4988, 4992, 5017, 5024, 5109, 5112, 5117, 5120, 5788, 5792, 5880, 5888, 5908, 5920, 5942, 5952, 5971, 5984, 6003, 6016, 6109, 6112, 6121, 6128, 6137, 6144, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6443, 6448, 6459, 6464, 6464, 6468, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6622, 6683, 6686, 6780, 6783, 6793, 6800, 6809, 6816, 6829, 6832, 6846, 6912, 6987, 6992, 7036, 7040, 7155, 7164, 7223, 7227, 7241, 7245, 7304, 7360, 7367, 7376, 7417, 7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8061, 8064, 8147, 8150, 8175, 8178, 8190, 8208, 8231, 8240, 8286, 8304, 8305, 8308, 8348, 8352, 8383, 8400, 8432, 8448, 8587, 8592, 9254, 9280, 9290, 9312, 11123, 11126, 11157, 11160, 11193, 11197, 11218, 11244, 11247, 11264, 11507, 11513, 11559, 11565, 11565, 11568, 11623, 11631, 11632, 11647, 11670, 11680, 11849, 11904, 12019, 12032, 12245, 12272, 12283, 12289, 12438, 12441, 12543, 12549, 12590, 12593, 12730, 12736, 12771, 12784, 19893, 19904, 40938, 40960, 42124, 42128, 42182, 42192, 42539, 42560, 42743, 42752, 42935, 42999, 43051, 43056, 43065, 43072, 43127, 43136, 43205, 43214, 43225, 43232, 43261, 43264, 43347, 43359, 43388, 43392, 43481, 43486, 43574, 43584, 43597, 43600, 43609, 43612, 43714, 43739, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43877, 43888, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64449, 64467, 64831, 64848, 64911, 64914, 64967, 65008, 65021, 65024, 65049, 65056, 65131, 65136, 65276, 65281, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65504, 65518, 65532, 65533]);
		isNotPrint16 = new sliceType$4([173, 907, 909, 930, 1328, 1376, 1416, 1424, 1757, 2111, 2143, 2229, 2274, 2436, 2473, 2481, 2526, 2564, 2601, 2609, 2612, 2615, 2621, 2653, 2692, 2702, 2706, 2729, 2737, 2740, 2758, 2762, 2816, 2820, 2857, 2865, 2868, 2910, 2948, 2961, 2971, 2973, 3017, 3076, 3085, 3089, 3113, 3141, 3145, 3159, 3204, 3213, 3217, 3241, 3252, 3269, 3273, 3295, 3312, 3332, 3341, 3345, 3397, 3401, 3460, 3506, 3516, 3541, 3543, 3715, 3721, 3736, 3744, 3748, 3750, 3756, 3770, 3781, 3783, 3912, 3992, 4029, 4045, 4294, 4681, 4695, 4697, 4745, 4785, 4799, 4801, 4823, 4881, 5760, 5901, 5997, 6001, 6431, 6751, 7674, 8024, 8026, 8028, 8030, 8117, 8133, 8156, 8181, 8335, 11209, 11311, 11359, 11558, 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, 11930, 12352, 12687, 12831, 13055, 42927, 43470, 43519, 43815, 43823, 64311, 64317, 64319, 64322, 64325, 65107, 65127, 65141, 65511]);
		isPrint32 = new sliceType$5([65536, 65613, 65616, 65629, 65664, 65786, 65792, 65794, 65799, 65843, 65847, 65947, 65952, 65952, 66000, 66045, 66176, 66204, 66208, 66256, 66272, 66299, 66304, 66339, 66349, 66378, 66384, 66426, 66432, 66499, 66504, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66927, 66927, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67640, 67644, 67644, 67647, 67742, 67751, 67759, 67808, 67829, 67835, 67867, 67871, 67897, 67903, 67903, 67968, 68023, 68028, 68047, 68050, 68102, 68108, 68147, 68152, 68154, 68159, 68167, 68176, 68184, 68192, 68255, 68288, 68326, 68331, 68342, 68352, 68405, 68409, 68437, 68440, 68466, 68472, 68497, 68505, 68508, 68521, 68527, 68608, 68680, 68736, 68786, 68800, 68850, 68858, 68863, 69216, 69246, 69632, 69709, 69714, 69743, 69759, 69825, 69840, 69864, 69872, 69881, 69888, 69955, 69968, 70006, 70016, 70093, 70096, 70132, 70144, 70206, 70272, 70313, 70320, 70378, 70384, 70393, 70400, 70412, 70415, 70416, 70419, 70457, 70460, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70749, 70784, 70855, 70864, 70873, 71040, 71093, 71096, 71133, 71168, 71236, 71248, 71257, 71264, 71276, 71296, 71351, 71360, 71369, 71424, 71449, 71453, 71467, 71472, 71487, 71840, 71922, 71935, 71935, 72192, 72263, 72272, 72323, 72326, 72354, 72384, 72440, 72704, 72773, 72784, 72812, 72816, 72847, 72850, 72886, 72960, 73014, 73018, 73031, 73040, 73049, 73728, 74649, 74752, 74868, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92777, 92782, 92783, 92880, 92909, 92912, 92917, 92928, 92997, 93008, 93047, 93053, 93071, 93952, 94020, 94032, 94078, 94095, 94111, 94176, 94177, 94208, 100332, 100352, 101106, 110592, 110878, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113820, 113823, 118784, 119029, 119040, 119078, 119081, 119154, 119163, 119272, 119296, 119365, 119552, 119638, 119648, 119665, 119808, 119967, 119970, 119970, 119973, 119974, 119977, 120074, 120077, 120134, 120138, 120485, 120488, 120779, 120782, 121483, 121499, 121519, 122880, 122904, 122907, 122922, 124928, 125124, 125127, 125142, 125184, 125258, 125264, 125273, 125278, 125279, 126464, 126500, 126503, 126523, 126530, 126530, 126535, 126548, 126551, 126564, 126567, 126619, 126625, 126651, 126704, 126705, 126976, 127019, 127024, 127123, 127136, 127150, 127153, 127221, 127232, 127244, 127248, 127339, 127344, 127404, 127462, 127490, 127504, 127547, 127552, 127560, 127568, 127569, 127584, 127589, 127744, 128724, 128736, 128748, 128752, 128760, 128768, 128883, 128896, 128980, 129024, 129035, 129040, 129095, 129104, 129113, 129120, 129159, 129168, 129197, 129280, 129291, 129296, 129356, 129360, 129387, 129408, 129431, 129472, 129472, 129488, 129510, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999]);
		isNotPrint32 = new sliceType$4([12, 39, 59, 62, 399, 926, 2057, 2102, 2134, 2291, 2564, 2580, 2584, 4285, 4405, 4576, 4626, 4743, 4745, 4750, 4766, 4868, 4905, 4913, 4916, 5210, 5212, 6813, 7177, 7223, 7336, 7431, 7434, 7483, 7486, 9327, 27231, 27482, 27490, 54357, 54429, 54445, 54458, 54460, 54468, 54534, 54549, 54557, 54586, 54591, 54597, 54609, 55968, 57351, 57378, 57381, 60932, 60960, 60963, 60968, 60979, 60984, 60986, 61000, 61002, 61004, 61008, 61011, 61016, 61018, 61020, 61022, 61024, 61027, 61035, 61043, 61048, 61053, 61055, 61066, 61092, 61098, 61632, 61648, 61743, 63807]);
		isGraphic = new sliceType$4([160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strings"] = (function() {
	var $pkg = {}, $init, errors, js, bytealg, io, sync, unicode, utf8, Builder, Reader, asciiSet, ptrType, sliceType, ptrType$5, arrayType$3, ptrType$6, IndexByte, Index, Count, NewReader, Contains, IndexRune, IndexAny, Map, Repeat, ToLower, TrimLeftFunc, TrimRightFunc, TrimFunc, indexFunc, lastIndexFunc, makeASCIISet, makeCutsetFunc, Trim, TrimLeft, Replace, ReplaceAll, EqualFold;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bytealg = $packages["internal/bytealg"];
	io = $packages["io"];
	sync = $packages["sync"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Builder = $pkg.Builder = $newType(0, $kindStruct, "strings.Builder", true, "strings", true, function(addr_, buf_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.addr = ptrType.nil;
			this.buf = sliceType.nil;
			return;
		}
		this.addr = addr_;
		this.buf = buf_;
	});
	Reader = $pkg.Reader = $newType(0, $kindStruct, "strings.Reader", true, "strings", true, function(s_, i_, prevRune_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = "";
			this.i = new $Int64(0, 0);
			this.prevRune = 0;
			return;
		}
		this.s = s_;
		this.i = i_;
		this.prevRune = prevRune_;
	});
	asciiSet = $pkg.asciiSet = $newType(32, $kindArray, "strings.asciiSet", true, "strings", false, null);
	ptrType = $ptrType(Builder);
	sliceType = $sliceType($Uint8);
	ptrType$5 = $ptrType(asciiSet);
	arrayType$3 = $arrayType($Uint32, 8);
	ptrType$6 = $ptrType(Reader);
	IndexByte = function(s, c) {
		var c, s;
		return $parseInt(s.indexOf($global.String.fromCharCode(c))) >> 0;
	};
	$pkg.IndexByte = IndexByte;
	Index = function(s, sep) {
		var s, sep;
		return $parseInt(s.indexOf(sep)) >> 0;
	};
	$pkg.Index = Index;
	Count = function(s, sep) {
		var n, pos, s, sep;
		n = 0;
		if ((sep.length === 0)) {
			return utf8.RuneCountInString(s) + 1 >> 0;
		} else if (sep.length > s.length) {
			return 0;
		} else if ((sep.length === s.length)) {
			if (sep === s) {
				return 1;
			}
			return 0;
		}
		while (true) {
			pos = Index(s, sep);
			if (pos === -1) {
				break;
			}
			n = n + (1) >> 0;
			s = $substring(s, (pos + sep.length >> 0));
		}
		return n;
	};
	$pkg.Count = Count;
	Builder.ptr.prototype.String = function() {
		var b;
		b = this;
		return ($bytesToString(b.buf));
	};
	Builder.prototype.String = function() { return this.$val.String(); };
	Builder.ptr.prototype.copyCheck = function() {
		var b;
		b = this;
		if (b.addr === ptrType.nil) {
			b.addr = b;
		} else if (!(b.addr === b)) {
			$panic(new $String("strings: illegal use of non-zero Builder copied by value"));
		}
	};
	Builder.prototype.copyCheck = function() { return this.$val.copyCheck(); };
	Builder.ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.$length;
	};
	Builder.prototype.Len = function() { return this.$val.Len(); };
	Builder.ptr.prototype.Cap = function() {
		var b;
		b = this;
		return b.buf.$capacity;
	};
	Builder.prototype.Cap = function() { return this.$val.Cap(); };
	Builder.ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.addr = ptrType.nil;
		b.buf = sliceType.nil;
	};
	Builder.prototype.Reset = function() { return this.$val.Reset(); };
	Builder.ptr.prototype.grow = function(n) {
		var b, buf, n;
		b = this;
		buf = $makeSlice(sliceType, b.buf.$length, (($imul(2, b.buf.$capacity)) + n >> 0));
		$copySlice(buf, b.buf);
		b.buf = buf;
	};
	Builder.prototype.grow = function(n) { return this.$val.grow(n); };
	Builder.ptr.prototype.Grow = function(n) {
		var b, n;
		b = this;
		b.copyCheck();
		if (n < 0) {
			$panic(new $String("strings.Builder.Grow: negative count"));
		}
		if ((b.buf.$capacity - b.buf.$length >> 0) < n) {
			b.grow(n);
		}
	};
	Builder.prototype.Grow = function(n) { return this.$val.Grow(n); };
	Builder.ptr.prototype.Write = function(p) {
		var b, p;
		b = this;
		b.copyCheck();
		b.buf = $appendSlice(b.buf, p);
		return [p.$length, $ifaceNil];
	};
	Builder.prototype.Write = function(p) { return this.$val.Write(p); };
	Builder.ptr.prototype.WriteByte = function(c) {
		var b, c;
		b = this;
		b.copyCheck();
		b.buf = $append(b.buf, c);
		return $ifaceNil;
	};
	Builder.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Builder.ptr.prototype.WriteRune = function(r) {
		var b, l, n, r;
		b = this;
		b.copyCheck();
		if (r < 128) {
			b.buf = $append(b.buf, ((r << 24 >>> 24)));
			return [1, $ifaceNil];
		}
		l = b.buf.$length;
		if ((b.buf.$capacity - l >> 0) < 4) {
			b.grow(4);
		}
		n = utf8.EncodeRune($subslice(b.buf, l, (l + 4 >> 0)), r);
		b.buf = $subslice(b.buf, 0, (l + n >> 0));
		return [n, $ifaceNil];
	};
	Builder.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Builder.ptr.prototype.WriteString = function(s) {
		var b, s;
		b = this;
		b.copyCheck();
		b.buf = $appendSlice(b.buf, s);
		return [s.length, $ifaceNil];
	};
	Builder.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Reader.ptr.prototype.Len = function() {
		var r, x, x$1, x$2, x$3, x$4;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return 0;
		}
		return (((x$2 = (x$3 = (new $Int64(0, r.s.length)), x$4 = r.i, new $Int64(x$3.$high - x$4.$high, x$3.$low - x$4.$low)), x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
	};
	Reader.prototype.Len = function() { return this.$val.Len(); };
	Reader.ptr.prototype.Size = function() {
		var r;
		r = this;
		return (new $Int64(0, r.s.length));
	};
	Reader.prototype.Size = function() { return this.$val.Size(); };
	Reader.ptr.prototype.Read = function(b) {
		var _tmp, _tmp$1, b, err, n, r, x, x$1, x$2, x$3;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = 0;
			_tmp$1 = io.EOF;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		r.prevRune = -1;
		n = $copyString(b, $substring(r.s, $flatten64(r.i)));
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, n)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [n, err];
	};
	Reader.prototype.Read = function(b) { return this.$val.Read(b); };
	Reader.ptr.prototype.ReadAt = function(b, off) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, b, err, n, off, r, x;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp = 0;
			_tmp$1 = errors.New("strings.Reader.ReadAt: negative offset");
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		if ((x = (new $Int64(0, r.s.length)), (off.$high > x.$high || (off.$high === x.$high && off.$low >= x.$low)))) {
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copyString(b, $substring(r.s, $flatten64(off)));
		if (n < b.$length) {
			err = io.EOF;
		}
		return [n, err];
	};
	Reader.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };
	Reader.ptr.prototype.ReadByte = function() {
		var b, r, x, x$1, x$2, x$3;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return [0, io.EOF];
		}
		b = r.s.charCodeAt($flatten64(r.i));
		r.i = (x$2 = r.i, x$3 = new $Int64(0, 1), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [b, $ifaceNil];
	};
	Reader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Reader.ptr.prototype.UnreadByte = function() {
		var r, x, x$1, x$2;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("strings.Reader.UnreadByte: at beginning of string");
		}
		r.prevRune = -1;
		r.i = (x$1 = r.i, x$2 = new $Int64(0, 1), new $Int64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));
		return $ifaceNil;
	};
	Reader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Reader.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, c, ch, err, r, size, x, x$1, x$2, x$3, x$4, x$5, x$6;
		ch = 0;
		size = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			r.prevRune = -1;
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			ch = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [ch, size, err];
		}
		r.prevRune = (((x$2 = r.i, x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
		c = r.s.charCodeAt($flatten64(r.i));
		if (c < 128) {
			r.i = (x$3 = r.i, x$4 = new $Int64(0, 1), new $Int64(x$3.$high + x$4.$high, x$3.$low + x$4.$low));
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			ch = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [ch, size, err];
		}
		_tuple = utf8.DecodeRuneInString($substring(r.s, $flatten64(r.i)));
		ch = _tuple[0];
		size = _tuple[1];
		r.i = (x$5 = r.i, x$6 = (new $Int64(0, size)), new $Int64(x$5.$high + x$6.$high, x$5.$low + x$6.$low));
		return [ch, size, err];
	};
	Reader.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Reader.ptr.prototype.UnreadRune = function() {
		var r, x;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("strings.Reader.UnreadRune: at beginning of string");
		}
		if (r.prevRune < 0) {
			return errors.New("strings.Reader.UnreadRune: previous operation was not ReadRune");
		}
		r.i = (new $Int64(0, r.prevRune));
		r.prevRune = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Reader.ptr.prototype.Seek = function(offset, whence) {
		var _1, abs, offset, r, whence, x, x$1;
		r = this;
		r.prevRune = -1;
		abs = new $Int64(0, 0);
		_1 = whence;
		if (_1 === (0)) {
			abs = offset;
		} else if (_1 === (1)) {
			abs = (x = r.i, new $Int64(x.$high + offset.$high, x.$low + offset.$low));
		} else if (_1 === (2)) {
			abs = (x$1 = (new $Int64(0, r.s.length)), new $Int64(x$1.$high + offset.$high, x$1.$low + offset.$low));
		} else {
			return [new $Int64(0, 0), errors.New("strings.Reader.Seek: invalid whence")];
		}
		if ((abs.$high < 0 || (abs.$high === 0 && abs.$low < 0))) {
			return [new $Int64(0, 0), errors.New("strings.Reader.Seek: negative position")];
		}
		r.i = abs;
		return [abs, $ifaceNil];
	};
	Reader.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	Reader.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tuple, err, m, n, r, s, w, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; m = $f.m; n = $f.n; r = $f.r; s = $f.s; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		s = $substring(r.s, $flatten64(r.i));
		_r = io.WriteString(w, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		m = _tuple[0];
		err = _tuple[1];
		if (m > s.length) {
			$panic(new $String("strings.Reader.WriteTo: invalid WriteString count"));
		}
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, m)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		n = (new $Int64(0, m));
		if (!((m === s.length)) && $interfaceIsEqual(err, $ifaceNil)) {
			err = io.ErrShortWrite;
		}
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.m = m; $f.n = n; $f.r = r; $f.s = s; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Reader.ptr.prototype.Reset = function(s) {
		var r, s;
		r = this;
		Reader.copy(r, new Reader.ptr(s, new $Int64(0, 0), -1));
	};
	Reader.prototype.Reset = function(s) { return this.$val.Reset(s); };
	NewReader = function(s) {
		var s;
		return new Reader.ptr(s, new $Int64(0, 0), -1);
	};
	$pkg.NewReader = NewReader;
	Contains = function(s, substr) {
		var s, substr;
		return Index(s, substr) >= 0;
	};
	$pkg.Contains = Contains;
	IndexRune = function(s, r) {
		var _i, _ref, _rune, i, r, r$1, s;
		if (0 <= r && r < 128) {
			return IndexByte(s, ((r << 24 >>> 24)));
		} else if ((r === 65533)) {
			_ref = s;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				i = _i;
				r$1 = _rune[0];
				if (r$1 === 65533) {
					return i;
				}
				_i += _rune[1];
			}
			return -1;
		} else if (!utf8.ValidRune(r)) {
			return -1;
		} else {
			return Index(s, ($encodeRune(r)));
		}
	};
	$pkg.IndexRune = IndexRune;
	IndexAny = function(s, chars) {
		var _i, _i$1, _ref, _ref$1, _rune, _rune$1, _tuple, as, c, chars, i, i$1, isASCII, m, s;
		if (chars === "") {
			return -1;
		}
		if (s.length > 8) {
			_tuple = makeASCIISet(chars);
			as = $clone(_tuple[0], asciiSet);
			isASCII = _tuple[1];
			if (isASCII) {
				i = 0;
				while (true) {
					if (!(i < s.length)) { break; }
					if (new ptrType$5(as).contains(s.charCodeAt(i))) {
						return i;
					}
					i = i + (1) >> 0;
				}
				return -1;
			}
		}
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i$1 = _i;
			c = _rune[0];
			_ref$1 = chars;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.length)) { break; }
				_rune$1 = $decodeRune(_ref$1, _i$1);
				m = _rune$1[0];
				if (c === m) {
					return i$1;
				}
				_i$1 += _rune$1[1];
			}
			_i += _rune[1];
		}
		return -1;
	};
	$pkg.IndexAny = IndexAny;
	Map = function(mapping, s) {
		var _i, _i$1, _r, _r$1, _ref, _ref$1, _rune, _rune$1, _tuple, b, c, c$1, i, mapping, r, r$1, s, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _rune = $f._rune; _rune$1 = $f._rune$1; _tuple = $f._tuple; b = $f.b; c = $f.c; c$1 = $f.c$1; i = $f.i; mapping = $f.mapping; r = $f.r; r$1 = $f.r$1; s = $f.s; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = new Builder.ptr(ptrType.nil, sliceType.nil);
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			_r = mapping(c); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if ((r === c) && !((c === 65533))) {
				_i += _rune[1];
				/* continue; */ $s = 1; continue;
			}
			width = 0;
			if (c === 65533) {
				_tuple = utf8.DecodeRuneInString($substring(s, i));
				c = _tuple[0];
				width = _tuple[1];
				if (!((width === 1)) && (r === c)) {
					_i += _rune[1];
					/* continue; */ $s = 1; continue;
				}
			} else {
				width = utf8.RuneLen(c);
			}
			b.Grow(s.length + 4 >> 0);
			b.WriteString($substring(s, 0, i));
			if (r >= 0) {
				b.WriteRune(r);
			}
			s = $substring(s, (i + width >> 0));
			/* break; */ $s = 2; continue;
		/* } */ $s = 1; continue; case 2:
		if (b.Cap() === 0) {
			$s = -1; return s;
		}
		_ref$1 = s;
		_i$1 = 0;
		/* while (true) { */ case 4:
			/* if (!(_i$1 < _ref$1.length)) { break; } */ if(!(_i$1 < _ref$1.length)) { $s = 5; continue; }
			_rune$1 = $decodeRune(_ref$1, _i$1);
			c$1 = _rune$1[0];
			_r$1 = mapping(c$1); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			r$1 = _r$1;
			if (r$1 >= 0) {
				if (r$1 < 128) {
					b.WriteByte(((r$1 << 24 >>> 24)));
				} else {
					b.WriteRune(r$1);
				}
			}
			_i$1 += _rune$1[1];
		/* } */ $s = 4; continue; case 5:
		$s = -1; return b.String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._rune = _rune; $f._rune$1 = _rune$1; $f._tuple = _tuple; $f.b = b; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.mapping = mapping; $f.r = r; $f.r$1 = r$1; $f.s = s; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Map = Map;
	Repeat = function(s, count) {
		var _q, _q$1, b, count, n, s;
		if (count === 0) {
			return "";
		}
		if (count < 0) {
			$panic(new $String("strings: negative Repeat count"));
		} else if (!(((_q = ($imul(s.length, count)) / count, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) === s.length))) {
			$panic(new $String("strings: Repeat count causes overflow"));
		}
		n = $imul(s.length, count);
		b = new Builder.ptr(ptrType.nil, sliceType.nil);
		b.Grow(n);
		b.WriteString(s);
		while (true) {
			if (!(b.Len() < n)) { break; }
			if (b.Len() <= (_q$1 = n / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) {
				b.WriteString(b.String());
			} else {
				b.WriteString($substring(b.String(), 0, (n - b.Len() >> 0)));
				break;
			}
		}
		return b.String();
	};
	$pkg.Repeat = Repeat;
	ToLower = function(s) {
		var _r, _tmp, _tmp$1, b, c, c$1, hasUpper, i, i$1, isASCII, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; b = $f.b; c = $f.c; c$1 = $f.c$1; hasUpper = $f.hasUpper; i = $f.i; i$1 = $f.i$1; isASCII = $f.isASCII; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = true;
		_tmp$1 = false;
		isASCII = _tmp;
		hasUpper = _tmp$1;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			c = s.charCodeAt(i);
			if (c >= 128) {
				isASCII = false;
				break;
			}
			hasUpper = hasUpper || (c >= 65 && c <= 90);
			i = i + (1) >> 0;
		}
		if (isASCII) {
			if (!hasUpper) {
				$s = -1; return s;
			}
			b = new Builder.ptr(ptrType.nil, sliceType.nil);
			b.Grow(s.length);
			i$1 = 0;
			while (true) {
				if (!(i$1 < s.length)) { break; }
				c$1 = s.charCodeAt(i$1);
				if (c$1 >= 65 && c$1 <= 90) {
					c$1 = c$1 + (32) << 24 >>> 24;
				}
				b.WriteByte(c$1);
				i$1 = i$1 + (1) >> 0;
			}
			$s = -1; return b.String();
		}
		_r = Map(unicode.ToLower, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ToLower }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.b = b; $f.c = c; $f.c$1 = c$1; $f.hasUpper = hasUpper; $f.i = i; $f.i$1 = i$1; $f.isASCII = isASCII; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ToLower = ToLower;
	TrimLeftFunc = function(s, f) {
		var _r, f, i, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; i = $f.i; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = indexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i === -1) {
			$s = -1; return "";
		}
		$s = -1; return $substring(s, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimLeftFunc }; } $f._r = _r; $f.f = f; $f.i = i; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimLeftFunc = TrimLeftFunc;
	TrimRightFunc = function(s, f) {
		var _r, _tuple, f, i, s, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; s = $f.s; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = lastIndexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i >= 0 && s.charCodeAt(i) >= 128) {
			_tuple = utf8.DecodeRuneInString($substring(s, i));
			wid = _tuple[1];
			i = i + (wid) >> 0;
		} else {
			i = i + (1) >> 0;
		}
		$s = -1; return $substring(s, 0, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRightFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.s = s; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRightFunc = TrimRightFunc;
	TrimFunc = function(s, f) {
		var _r, _r$1, f, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimLeftFunc(s, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = TrimRightFunc(_r, f); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimFunc }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimFunc = TrimFunc;
	indexFunc = function(s, f, truth) {
		var _i, _r, _ref, _rune, f, i, r, s, truth, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _rune = $f._rune; f = $f.f; i = $f.i; r = $f.r; s = $f.s; truth = $f.truth; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			r = _rune[0];
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
			_i += _rune[1];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: indexFunc }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._rune = _rune; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.truth = truth; $f.$s = $s; $f.$r = $r; return $f;
	};
	lastIndexFunc = function(s, f, truth) {
		var _r, _tuple, f, i, r, s, size, truth, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; r = $f.r; s = $f.s; size = $f.size; truth = $f.truth; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = s.length;
		/* while (true) { */ case 1:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 2; continue; }
			_tuple = utf8.DecodeLastRuneInString($substring(s, 0, i));
			r = _tuple[0];
			size = _tuple[1];
			i = i - (size) >> 0;
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lastIndexFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.size = size; $f.truth = truth; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeASCIISet = function(chars) {
		var _index, _tmp, _tmp$1, _tmp$2, _tmp$3, as, c, chars, i, ok, y;
		as = arrayType$3.zero();
		ok = false;
		i = 0;
		while (true) {
			if (!(i < chars.length)) { break; }
			c = chars.charCodeAt(i);
			if (c >= 128) {
				_tmp = $clone(as, asciiSet);
				_tmp$1 = false;
				asciiSet.copy(as, _tmp);
				ok = _tmp$1;
				return [as, ok];
			}
			_index = c >>> 5 << 24 >>> 24;
			((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index] = ((((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index]) | (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0));
			i = i + (1) >> 0;
		}
		_tmp$2 = $clone(as, asciiSet);
		_tmp$3 = true;
		asciiSet.copy(as, _tmp$2);
		ok = _tmp$3;
		return [as, ok];
	};
	asciiSet.prototype.contains = function(c) {
		var as, c, x, y;
		as = this.$val;
		return !((((((x = c >>> 5 << 24 >>> 24, (as.nilCheck, ((x < 0 || x >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[x]))) & (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0)) === 0));
	};
	$ptrType(asciiSet).prototype.contains = function(c) { return (new asciiSet(this.$get())).contains(c); };
	makeCutsetFunc = function(cutset) {
		var _tuple, as, cutset, isASCII;
		if ((cutset.length === 1) && cutset.charCodeAt(0) < 128) {
			return (function(r) {
				var r;
				return r === ((cutset.charCodeAt(0) >> 0));
			});
		}
		_tuple = makeASCIISet(cutset);
		as = $clone(_tuple[0], asciiSet);
		isASCII = _tuple[1];
		if (isASCII) {
			return (function(r) {
				var r;
				return r < 128 && new ptrType$5(as).contains(((r << 24 >>> 24)));
			});
		}
		return (function(r) {
			var r;
			return IndexRune(cutset, r) >= 0;
		});
	};
	Trim = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (s === "" || cutset === "") {
			$s = -1; return s;
		}
		_r = TrimFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Trim }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Trim = Trim;
	TrimLeft = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (s === "" || cutset === "") {
			$s = -1; return s;
		}
		_r = TrimLeftFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimLeft }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimLeft = TrimLeft;
	Replace = function(s, old, new$1, n) {
		var _tuple, i, j, m, n, new$1, old, s, start, t, w, wid;
		if (old === new$1 || (n === 0)) {
			return s;
		}
		m = Count(s, old);
		if (m === 0) {
			return s;
		} else if (n < 0 || m < n) {
			n = m;
		}
		t = $makeSlice(sliceType, (s.length + ($imul(n, ((new$1.length - old.length >> 0)))) >> 0));
		w = 0;
		start = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			j = start;
			if (old.length === 0) {
				if (i > 0) {
					_tuple = utf8.DecodeRuneInString($substring(s, start));
					wid = _tuple[1];
					j = j + (wid) >> 0;
				}
			} else {
				j = j + (Index($substring(s, start), old)) >> 0;
			}
			w = w + ($copyString($subslice(t, w), $substring(s, start, j))) >> 0;
			w = w + ($copyString($subslice(t, w), new$1)) >> 0;
			start = j + old.length >> 0;
			i = i + (1) >> 0;
		}
		w = w + ($copyString($subslice(t, w), $substring(s, start))) >> 0;
		return ($bytesToString($subslice(t, 0, w)));
	};
	$pkg.Replace = Replace;
	ReplaceAll = function(s, old, new$1) {
		var new$1, old, s;
		return Replace(s, old, new$1, -1);
	};
	$pkg.ReplaceAll = ReplaceAll;
	EqualFold = function(s, t) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, r, r$1, r$2, s, size, size$1, sr, t, tr;
		while (true) {
			if (!(!(s === "") && !(t === ""))) { break; }
			_tmp = 0;
			_tmp$1 = 0;
			sr = _tmp;
			tr = _tmp$1;
			if (s.charCodeAt(0) < 128) {
				_tmp$2 = ((s.charCodeAt(0) >> 0));
				_tmp$3 = $substring(s, 1);
				sr = _tmp$2;
				s = _tmp$3;
			} else {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				size = _tuple[1];
				_tmp$4 = r;
				_tmp$5 = $substring(s, size);
				sr = _tmp$4;
				s = _tmp$5;
			}
			if (t.charCodeAt(0) < 128) {
				_tmp$6 = ((t.charCodeAt(0) >> 0));
				_tmp$7 = $substring(t, 1);
				tr = _tmp$6;
				t = _tmp$7;
			} else {
				_tuple$1 = utf8.DecodeRuneInString(t);
				r$1 = _tuple$1[0];
				size$1 = _tuple$1[1];
				_tmp$8 = r$1;
				_tmp$9 = $substring(t, size$1);
				tr = _tmp$8;
				t = _tmp$9;
			}
			if (tr === sr) {
				continue;
			}
			if (tr < sr) {
				_tmp$10 = sr;
				_tmp$11 = tr;
				tr = _tmp$10;
				sr = _tmp$11;
			}
			if (tr < 128) {
				if (65 <= sr && sr <= 90 && (tr === ((sr + 97 >> 0) - 65 >> 0))) {
					continue;
				}
				return false;
			}
			r$2 = unicode.SimpleFold(sr);
			while (true) {
				if (!(!((r$2 === sr)) && r$2 < tr)) { break; }
				r$2 = unicode.SimpleFold(r$2);
			}
			if (r$2 === tr) {
				continue;
			}
			return false;
		}
		return s === t;
	};
	$pkg.EqualFold = EqualFold;
	ptrType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "copyCheck", name: "copyCheck", pkg: "strings", typ: $funcType([], [], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "grow", name: "grow", pkg: "strings", typ: $funcType([$Int], [], false)}, {prop: "Grow", name: "Grow", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}];
	ptrType$6.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "ReadAt", name: "ReadAt", pkg: "", typ: $funcType([sliceType, $Int64], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([$String], [], false)}];
	ptrType$5.methods = [{prop: "contains", name: "contains", pkg: "strings", typ: $funcType([$Uint8], [$Bool], false)}];
	Builder.init("strings", [{prop: "addr", name: "addr", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}]);
	Reader.init("strings", [{prop: "s", name: "s", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "i", name: "i", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "prevRune", name: "prevRune", embedded: false, exported: false, typ: $Int, tag: ""}]);
	asciiSet.init($Uint32, 8);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/b3log/lute/html"] = (function() {
	var $pkg = {}, $init, bufio, bytes, errors, atom, io, strconv, strings, utf8, NodeType, Node, nodeStack, insertionModeStack, parser, scope, insertionMode, ParseOption, TokenType, Attribute, Token, span, Tokenizer, sliceType, ptrType, sliceType$1, sliceType$2, sliceType$3, sliceType$4, ptrType$1, ptrType$2, sliceType$5, ptrType$3, sliceType$6, arrayType, arrayType$1, sliceType$7, ptrType$4, isSpecialElementMap, replacementTable, breakout, svgTagNameAdjustments, mathMLAttributeAdjustments, svgAttributeAdjustments, scopeMarker, scopeMarker$24ptr, defaultScopeStopTags, plaintextAbort, nul, replacement, isSpecialElement, unescapeEntity, unescape, lower, escape, EscapeString, adjustAttributeNames, adjustForeignAttributes, htmlIntegrationPoint, mathMLTextIntegrationPoint, reparentChildren, beforeHeadIM, inHeadIM, inHeadNoscriptIM, afterHeadIM, copyAttributes, inBodyIM, textIM, inTableIM, inCaptionIM, inColumnGroupIM, inTableBodyIM, inRowIM, inCellIM, inSelectIM, inSelectInTableIM, inTemplateIM, afterBodyIM, inFramesetIM, afterFramesetIM, afterAfterBodyIM, afterAfterFramesetIM, parseForeignContent, ParseFragment, ParseFragmentWithOptions, readAtLeastOneByte, convertNewlines, NewTokenizerFragment;
	bufio = $packages["bufio"];
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	atom = $packages["github.com/b3log/lute/html/atom"];
	io = $packages["io"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	utf8 = $packages["unicode/utf8"];
	NodeType = $pkg.NodeType = $newType(4, $kindUint32, "html.NodeType", true, "github.com/b3log/lute/html", true, null);
	Node = $pkg.Node = $newType(0, $kindStruct, "html.Node", true, "github.com/b3log/lute/html", true, function(Parent_, FirstChild_, LastChild_, PrevSibling_, NextSibling_, Type_, DataAtom_, Data_, Namespace_, Attr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Parent = ptrType.nil;
			this.FirstChild = ptrType.nil;
			this.LastChild = ptrType.nil;
			this.PrevSibling = ptrType.nil;
			this.NextSibling = ptrType.nil;
			this.Type = 0;
			this.DataAtom = 0;
			this.Data = "";
			this.Namespace = "";
			this.Attr = sliceType$1.nil;
			return;
		}
		this.Parent = Parent_;
		this.FirstChild = FirstChild_;
		this.LastChild = LastChild_;
		this.PrevSibling = PrevSibling_;
		this.NextSibling = NextSibling_;
		this.Type = Type_;
		this.DataAtom = DataAtom_;
		this.Data = Data_;
		this.Namespace = Namespace_;
		this.Attr = Attr_;
	});
	nodeStack = $pkg.nodeStack = $newType(12, $kindSlice, "html.nodeStack", true, "github.com/b3log/lute/html", false, null);
	insertionModeStack = $pkg.insertionModeStack = $newType(12, $kindSlice, "html.insertionModeStack", true, "github.com/b3log/lute/html", false, null);
	parser = $pkg.parser = $newType(0, $kindStruct, "html.parser", true, "github.com/b3log/lute/html", false, function(tokenizer_, tok_, hasSelfClosingToken_, doc_, oe_, afe_, head_, form_, scripting_, framesetOK_, templateStack_, im_, originalIM_, fosterParenting_, quirks_, fragment_, context_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.tokenizer = ptrType$3.nil;
			this.tok = new Token.ptr(0, 0, "", sliceType$1.nil);
			this.hasSelfClosingToken = false;
			this.doc = ptrType.nil;
			this.oe = nodeStack.nil;
			this.afe = nodeStack.nil;
			this.head = ptrType.nil;
			this.form = ptrType.nil;
			this.scripting = false;
			this.framesetOK = false;
			this.templateStack = insertionModeStack.nil;
			this.im = $throwNilPointerError;
			this.originalIM = $throwNilPointerError;
			this.fosterParenting = false;
			this.quirks = false;
			this.fragment = false;
			this.context = ptrType.nil;
			return;
		}
		this.tokenizer = tokenizer_;
		this.tok = tok_;
		this.hasSelfClosingToken = hasSelfClosingToken_;
		this.doc = doc_;
		this.oe = oe_;
		this.afe = afe_;
		this.head = head_;
		this.form = form_;
		this.scripting = scripting_;
		this.framesetOK = framesetOK_;
		this.templateStack = templateStack_;
		this.im = im_;
		this.originalIM = originalIM_;
		this.fosterParenting = fosterParenting_;
		this.quirks = quirks_;
		this.fragment = fragment_;
		this.context = context_;
	});
	scope = $pkg.scope = $newType(4, $kindInt, "html.scope", true, "github.com/b3log/lute/html", false, null);
	insertionMode = $pkg.insertionMode = $newType(4, $kindFunc, "html.insertionMode", true, "github.com/b3log/lute/html", false, null);
	ParseOption = $pkg.ParseOption = $newType(4, $kindFunc, "html.ParseOption", true, "github.com/b3log/lute/html", true, null);
	TokenType = $pkg.TokenType = $newType(4, $kindUint32, "html.TokenType", true, "github.com/b3log/lute/html", true, null);
	Attribute = $pkg.Attribute = $newType(0, $kindStruct, "html.Attribute", true, "github.com/b3log/lute/html", true, function(Namespace_, Key_, Val_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Namespace = "";
			this.Key = "";
			this.Val = "";
			return;
		}
		this.Namespace = Namespace_;
		this.Key = Key_;
		this.Val = Val_;
	});
	Token = $pkg.Token = $newType(0, $kindStruct, "html.Token", true, "github.com/b3log/lute/html", true, function(Type_, DataAtom_, Data_, Attr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Type = 0;
			this.DataAtom = 0;
			this.Data = "";
			this.Attr = sliceType$1.nil;
			return;
		}
		this.Type = Type_;
		this.DataAtom = DataAtom_;
		this.Data = Data_;
		this.Attr = Attr_;
	});
	span = $pkg.span = $newType(0, $kindStruct, "html.span", true, "github.com/b3log/lute/html", false, function(start_, end_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.start = 0;
			this.end = 0;
			return;
		}
		this.start = start_;
		this.end = end_;
	});
	Tokenizer = $pkg.Tokenizer = $newType(0, $kindStruct, "html.Tokenizer", true, "github.com/b3log/lute/html", true, function(r_, tt_, err_, readErr_, raw_, buf_, maxBuf_, data_, pendingAttr_, attr_, nAttrReturned_, rawTag_, textIsRaw_, convertNUL_, allowCDATA_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.r = $ifaceNil;
			this.tt = 0;
			this.err = $ifaceNil;
			this.readErr = $ifaceNil;
			this.raw = new span.ptr(0, 0);
			this.buf = sliceType$3.nil;
			this.maxBuf = 0;
			this.data = new span.ptr(0, 0);
			this.pendingAttr = arrayType$1.zero();
			this.attr = sliceType$7.nil;
			this.nAttrReturned = 0;
			this.rawTag = "";
			this.textIsRaw = false;
			this.convertNUL = false;
			this.allowCDATA = false;
			return;
		}
		this.r = r_;
		this.tt = tt_;
		this.err = err_;
		this.readErr = readErr_;
		this.raw = raw_;
		this.buf = buf_;
		this.maxBuf = maxBuf_;
		this.data = data_;
		this.pendingAttr = pendingAttr_;
		this.attr = attr_;
		this.nAttrReturned = nAttrReturned_;
		this.rawTag = rawTag_;
		this.textIsRaw = textIsRaw_;
		this.convertNUL = convertNUL_;
		this.allowCDATA = allowCDATA_;
	});
	sliceType = $sliceType($String);
	ptrType = $ptrType(Node);
	sliceType$1 = $sliceType(Attribute);
	sliceType$2 = $sliceType(atom.Atom);
	sliceType$3 = $sliceType($Uint8);
	sliceType$4 = $sliceType($Int32);
	ptrType$1 = $ptrType(nodeStack);
	ptrType$2 = $ptrType(insertionModeStack);
	sliceType$5 = $sliceType(ParseOption);
	ptrType$3 = $ptrType(Tokenizer);
	sliceType$6 = $sliceType(ptrType);
	arrayType = $arrayType($Uint8, 2);
	arrayType$1 = $arrayType(span, 2);
	sliceType$7 = $sliceType(arrayType$1);
	ptrType$4 = $ptrType(parser);
	isSpecialElement = function(element) {
		var _1, _2, _3, _entry, element;
		_1 = element.Namespace;
		if (_1 === ("") || _1 === ("html")) {
			return (_entry = isSpecialElementMap[$String.keyFor(element.Data)], _entry !== undefined ? _entry.v : false);
		} else if (_1 === ("math")) {
			_2 = element.Data;
			if (_2 === ("mi") || _2 === ("mo") || _2 === ("mn") || _2 === ("ms") || _2 === ("mtext") || _2 === ("annotation-xml")) {
				return true;
			}
		} else if (_1 === ("svg")) {
			_3 = element.Data;
			if (_3 === ("foreignObject") || _3 === ("desc") || _3 === ("title")) {
				return true;
			}
		}
		return false;
	};
	unescapeEntity = function(b, dst, src, attribute) {
		var _entry, _entry$1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, attribute, b, c, c$1, dst, dst1, entityName, hex, i, j, maxLen, s, src, src1, x, x$1, x$2, x$3, x$4, x$5;
		dst1 = 0;
		src1 = 0;
		_tmp = 1;
		_tmp$1 = $subslice(b, src);
		i = _tmp;
		s = _tmp$1;
		if (s.$length <= 1) {
			((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]));
			_tmp$2 = dst + 1 >> 0;
			_tmp$3 = src + 1 >> 0;
			dst1 = _tmp$2;
			src1 = _tmp$3;
			return [dst1, src1];
		}
		if (((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === 35) {
			if (s.$length <= 3) {
				((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]));
				_tmp$4 = dst + 1 >> 0;
				_tmp$5 = src + 1 >> 0;
				dst1 = _tmp$4;
				src1 = _tmp$5;
				return [dst1, src1];
			}
			i = i + (1) >> 0;
			c = ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]);
			hex = false;
			if ((c === 120) || (c === 88)) {
				hex = true;
				i = i + (1) >> 0;
			}
			x = 0;
			while (true) {
				if (!(i < s.$length)) { break; }
				c = ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]);
				i = i + (1) >> 0;
				if (hex) {
					if (48 <= c && c <= 57) {
						x = (($imul(16, x)) + ((c >> 0)) >> 0) - 48 >> 0;
						continue;
					} else if (97 <= c && c <= 102) {
						x = ((($imul(16, x)) + ((c >> 0)) >> 0) - 97 >> 0) + 10 >> 0;
						continue;
					} else if (65 <= c && c <= 70) {
						x = ((($imul(16, x)) + ((c >> 0)) >> 0) - 65 >> 0) + 10 >> 0;
						continue;
					}
				} else if (48 <= c && c <= 57) {
					x = (($imul(10, x)) + ((c >> 0)) >> 0) - 48 >> 0;
					continue;
				}
				if (!((c === 59))) {
					i = i - (1) >> 0;
				}
				break;
			}
			if (i <= 3) {
				((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]));
				_tmp$6 = dst + 1 >> 0;
				_tmp$7 = src + 1 >> 0;
				dst1 = _tmp$6;
				src1 = _tmp$7;
				return [dst1, src1];
			}
			if (128 <= x && x <= 159) {
				x = (x$1 = x - 128 >> 0, ((x$1 < 0 || x$1 >= replacementTable.length) ? ($throwRuntimeError("index out of range"), undefined) : replacementTable[x$1]));
			} else if ((x === 0) || (55296 <= x && x <= 57343) || x > 1114111) {
				x = 65533;
			}
			_tmp$8 = dst + utf8.EncodeRune($subslice(b, dst), x) >> 0;
			_tmp$9 = src + i >> 0;
			dst1 = _tmp$8;
			src1 = _tmp$9;
			return [dst1, src1];
		}
		while (true) {
			if (!(i < s.$length)) { break; }
			c$1 = ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]);
			i = i + (1) >> 0;
			if (97 <= c$1 && c$1 <= 122 || 65 <= c$1 && c$1 <= 90 || 48 <= c$1 && c$1 <= 57) {
				continue;
			}
			if (!((c$1 === 59))) {
				i = i - (1) >> 0;
			}
			break;
		}
		entityName = ($bytesToString($subslice(s, 1, (i - 1 >> 0))));
		if (entityName === "") {
		} else if (attribute && !((entityName.charCodeAt((entityName.length - 1 >> 0)) === 59)) && s.$length > i && (((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === 61)) {
		} else {
			x$2 = (_entry = $pkg.Entities[$String.keyFor(entityName)], _entry !== undefined ? _entry.v : "");
			if (!(x$2 === "")) {
				_tmp$10 = dst + utf8.EncodeRune($subslice(b, dst), (x$3 = (new sliceType$4($stringToRunes(x$2))), (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0]))) >> 0;
				_tmp$11 = src + i >> 0;
				dst1 = _tmp$10;
				src1 = _tmp$11;
				return [dst1, src1];
			} else if (!attribute) {
				maxLen = entityName.length - 1 >> 0;
				if (maxLen > 6) {
					maxLen = 6;
				}
				j = maxLen;
				while (true) {
					if (!(j > 1)) { break; }
					x$4 = (_entry$1 = $pkg.Entities[$String.keyFor($substring(entityName, 0, j))], _entry$1 !== undefined ? _entry$1.v : "");
					if (!(x$4 === "")) {
						_tmp$12 = dst + utf8.EncodeRune($subslice(b, dst), (x$5 = (new sliceType$4($stringToRunes(x$4))), (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]))) >> 0;
						_tmp$13 = (src + j >> 0) + 1 >> 0;
						dst1 = _tmp$12;
						src1 = _tmp$13;
						return [dst1, src1];
					}
					j = j - (1) >> 0;
				}
			}
		}
		_tmp$14 = dst + i >> 0;
		_tmp$15 = src + i >> 0;
		dst1 = _tmp$14;
		src1 = _tmp$15;
		$copySlice($subslice(b, dst, dst1), $subslice(b, src, src1));
		_tmp$16 = dst1;
		_tmp$17 = src1;
		dst1 = _tmp$16;
		src1 = _tmp$17;
		return [dst1, src1];
	};
	unescape = function(b, attribute) {
		var _i, _ref, _tmp, _tmp$1, _tuple, _tuple$1, attribute, b, c, c$1, dst, i, src;
		_ref = b;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (c === 38) {
				_tuple = unescapeEntity(b, i, i, attribute);
				dst = _tuple[0];
				src = _tuple[1];
				while (true) {
					if (!(src < b.$length)) { break; }
					c$1 = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]);
					if (c$1 === 38) {
						_tuple$1 = unescapeEntity(b, dst, src, attribute);
						dst = _tuple$1[0];
						src = _tuple$1[1];
					} else {
						((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = c$1);
						_tmp = dst + 1 >> 0;
						_tmp$1 = src + 1 >> 0;
						dst = _tmp;
						src = _tmp$1;
					}
				}
				return $subslice(b, 0, dst);
			}
			_i++;
		}
		return b;
	};
	lower = function(b) {
		var _i, _ref, b, c, i;
		_ref = b;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (65 <= c && c <= 90) {
				((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i] = ((c + 97 << 24 >>> 24) - 65 << 24 >>> 24));
			}
			_i++;
		}
		return b;
	};
	escape = function(w, s) {
		var _1, _r, _r$1, _r$2, _tuple, _tuple$1, _tuple$2, err, err$1, err$2, esc, i, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; esc = $f.esc; i = $f.i; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = strings.IndexAny(s, "&'<>\"\r");
		/* while (true) { */ case 1:
			/* if (!(!((i === -1)))) { break; } */ if(!(!((i === -1)))) { $s = 2; continue; }
			_r = w.WriteString($substring(s, 0, i)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			esc = "";
			_1 = s.charCodeAt(i);
			if (_1 === (38)) {
				esc = "&amp;";
			} else if (_1 === (39)) {
				esc = "&#39;";
			} else if (_1 === (60)) {
				esc = "&lt;";
			} else if (_1 === (62)) {
				esc = "&gt;";
			} else if (_1 === (34)) {
				esc = "&#34;";
			} else if (_1 === (13)) {
				esc = "&#13;";
			} else {
				$panic(new $String("unrecognized escape character"));
			}
			s = $substring(s, (i + 1 >> 0));
			_r$1 = w.WriteString(esc); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			err$1 = _tuple$1[1];
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return err$1;
			}
			i = strings.IndexAny(s, "&'<>\"\r");
		/* } */ $s = 1; continue; case 2:
		_r$2 = w.WriteString(s); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple$2 = _r$2;
		err$2 = _tuple$2[1];
		$s = -1; return err$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: escape }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.esc = esc; $f.i = i; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	EscapeString = function(s) {
		var _r, buf, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		buf = [buf];
		if (strings.IndexAny(s, "&'<>\"\r") === -1) {
			$s = -1; return s;
		}
		buf[0] = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
		_r = escape(buf[0], s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return buf[0].String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: EscapeString }; } $f._r = _r; $f.buf = buf; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.EscapeString = EscapeString;
	adjustAttributeNames = function(aa, nameMap) {
		var _entry, _i, _ref, _tuple, aa, i, nameMap, newName, ok;
		_ref = aa;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			_tuple = (_entry = nameMap[$String.keyFor(((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Key)], _entry !== undefined ? [_entry.v, true] : ["", false]);
			newName = _tuple[0];
			ok = _tuple[1];
			if (ok) {
				((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Key = newName;
			}
			_i++;
		}
	};
	adjustForeignAttributes = function(aa) {
		var _1, _i, _ref, a, aa, i, j;
		_ref = aa;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
			if (a.Key === "" || !((a.Key.charCodeAt(0) === 120))) {
				_i++;
				continue;
			}
			_1 = a.Key;
			if (_1 === ("xlink:actuate") || _1 === ("xlink:arcrole") || _1 === ("xlink:href") || _1 === ("xlink:role") || _1 === ("xlink:show") || _1 === ("xlink:title") || _1 === ("xlink:type") || _1 === ("xml:base") || _1 === ("xml:lang") || _1 === ("xml:space") || _1 === ("xmlns:xlink")) {
				j = strings.Index(a.Key, ":");
				((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Namespace = $substring(a.Key, 0, j);
				((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Key = $substring(a.Key, (j + 1 >> 0));
			}
			_i++;
		}
	};
	htmlIntegrationPoint = function(n) {
		var _1, _2, _i, _r, _ref, a, n, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; n = $f.n; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (!((n.Type === 3))) {
			$s = -1; return false;
		}
			_1 = n.Namespace;
			/* */ if (_1 === ("math")) { $s = 2; continue; }
			/* */ if (_1 === ("svg")) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === ("math")) { */ case 2:
				/* */ if (n.Data === "annotation-xml") { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (n.Data === "annotation-xml") { */ case 5:
					_ref = n.Attr;
					_i = 0;
					/* while (true) { */ case 7:
						/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 8; continue; }
						a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
						/* */ if (a.Key === "encoding") { $s = 9; continue; }
						/* */ $s = 10; continue;
						/* if (a.Key === "encoding") { */ case 9:
							_r = strings.ToLower(a.Val); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
							val = _r;
							if (val === "text/html" || val === "application/xhtml+xml") {
								$s = -1; return true;
							}
						/* } */ case 10:
						_i++;
					/* } */ $s = 7; continue; case 8:
				/* } */ case 6:
				$s = 4; continue;
			/* } else if (_1 === ("svg")) { */ case 3:
				_2 = n.Data;
				if (_2 === ("desc") || _2 === ("foreignObject") || _2 === ("title")) {
					$s = -1; return true;
				}
			/* } */ case 4:
		case 1:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: htmlIntegrationPoint }; } $f._1 = _1; $f._2 = _2; $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.n = n; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	mathMLTextIntegrationPoint = function(n) {
		var _1, n;
		if (!(n.Namespace === "math")) {
			return false;
		}
		_1 = n.Data;
		if (_1 === ("mi") || _1 === ("mo") || _1 === ("mn") || _1 === ("ms") || _1 === ("mtext")) {
			return true;
		}
		return false;
	};
	Node.ptr.prototype.InsertBefore = function(newChild, oldChild) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, n, newChild, next, oldChild, prev;
		n = this;
		if (!(newChild.Parent === ptrType.nil) || !(newChild.PrevSibling === ptrType.nil) || !(newChild.NextSibling === ptrType.nil)) {
			$panic(new $String("html: InsertBefore called for an attached child Node"));
		}
		_tmp = ptrType.nil;
		_tmp$1 = ptrType.nil;
		prev = _tmp;
		next = _tmp$1;
		if (!(oldChild === ptrType.nil)) {
			_tmp$2 = oldChild.PrevSibling;
			_tmp$3 = oldChild;
			prev = _tmp$2;
			next = _tmp$3;
		} else {
			prev = n.LastChild;
		}
		if (!(prev === ptrType.nil)) {
			prev.NextSibling = newChild;
		} else {
			n.FirstChild = newChild;
		}
		if (!(next === ptrType.nil)) {
			next.PrevSibling = newChild;
		} else {
			n.LastChild = newChild;
		}
		newChild.Parent = n;
		newChild.PrevSibling = prev;
		newChild.NextSibling = next;
	};
	Node.prototype.InsertBefore = function(newChild, oldChild) { return this.$val.InsertBefore(newChild, oldChild); };
	Node.ptr.prototype.AppendChild = function(c) {
		var c, last, n;
		n = this;
		if (!(c.Parent === ptrType.nil) || !(c.PrevSibling === ptrType.nil) || !(c.NextSibling === ptrType.nil)) {
			$panic(new $String("html: AppendChild called for an attached child Node"));
		}
		last = n.LastChild;
		if (!(last === ptrType.nil)) {
			last.NextSibling = c;
		} else {
			n.FirstChild = c;
		}
		n.LastChild = c;
		c.Parent = n;
		c.PrevSibling = last;
	};
	Node.prototype.AppendChild = function(c) { return this.$val.AppendChild(c); };
	Node.ptr.prototype.RemoveChild = function(c) {
		var c, n;
		n = this;
		if (!(c.Parent === n)) {
			$panic(new $String("html: RemoveChild called for a non-child Node"));
		}
		if (n.FirstChild === c) {
			n.FirstChild = c.NextSibling;
		}
		if (!(c.NextSibling === ptrType.nil)) {
			c.NextSibling.PrevSibling = c.PrevSibling;
		}
		if (n.LastChild === c) {
			n.LastChild = c.PrevSibling;
		}
		if (!(c.PrevSibling === ptrType.nil)) {
			c.PrevSibling.NextSibling = c.NextSibling;
		}
		c.Parent = ptrType.nil;
		c.PrevSibling = ptrType.nil;
		c.NextSibling = ptrType.nil;
	};
	Node.prototype.RemoveChild = function(c) { return this.$val.RemoveChild(c); };
	reparentChildren = function(dst, src) {
		var child, dst, src;
		while (true) {
			child = src.FirstChild;
			if (child === ptrType.nil) {
				break;
			}
			src.RemoveChild(child);
			dst.AppendChild(child);
		}
	};
	Node.ptr.prototype.clone = function() {
		var m, n;
		n = this;
		m = new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, n.Type, n.DataAtom, n.Data, "", $makeSlice(sliceType$1, n.Attr.$length));
		$copySlice(m.Attr, n.Attr);
		return m;
	};
	Node.prototype.clone = function() { return this.$val.clone(); };
	$ptrType(nodeStack).prototype.pop = function() {
		var i, n, s, x, x$1;
		s = this;
		i = s.$get().$length;
		n = (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		s.$set($subslice((s.$get()), 0, (i - 1 >> 0)));
		return n;
	};
	$ptrType(nodeStack).prototype.top = function() {
		var i, s, x, x$1;
		s = this;
		i = s.$get().$length;
		if (i > 0) {
			return (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		}
		return ptrType.nil;
	};
	$ptrType(nodeStack).prototype.index = function(n) {
		var i, n, s, x;
		s = this;
		i = s.$get().$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if ((x = s.$get(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])) === n) {
				return i;
			}
			i = i - (1) >> 0;
		}
		return -1;
	};
	$ptrType(nodeStack).prototype.contains = function(a) {
		var _i, _ref, a, n, s;
		s = this;
		_ref = s.$get();
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if ((n.DataAtom === a) && n.Namespace === "") {
				return true;
			}
			_i++;
		}
		return false;
	};
	$ptrType(nodeStack).prototype.insert = function(i, n) {
		var i, n, s, x;
		s = this;
		s.$set($append(s.$get(), ptrType.nil));
		$copySlice($subslice((s.$get()), (i + 1 >> 0)), $subslice((s.$get()), i));
		(x = s.$get(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i] = n));
	};
	$ptrType(nodeStack).prototype.remove = function(n) {
		var i, j, n, s, x;
		s = this;
		i = s.index(n);
		if (i === -1) {
			return;
		}
		$copySlice($subslice((s.$get()), i), $subslice((s.$get()), (i + 1 >> 0)));
		j = s.$get().$length - 1 >> 0;
		(x = s.$get(), ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j] = ptrType.nil));
		s.$set($subslice((s.$get()), 0, j));
	};
	$ptrType(insertionModeStack).prototype.pop = function() {
		var i, im, s, x, x$1;
		im = $throwNilPointerError;
		s = this;
		i = s.$get().$length;
		im = (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		s.$set($subslice((s.$get()), 0, (i - 1 >> 0)));
		im = im;
		return im;
	};
	$ptrType(insertionModeStack).prototype.top = function() {
		var i, s, x, x$1;
		s = this;
		i = s.$get().$length;
		if (i > 0) {
			return (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		}
		return $throwNilPointerError;
	};
	parser.ptr.prototype.top = function() {
		var n, p;
		p = this;
		n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
		if (!(n === ptrType.nil)) {
			return n;
		}
		return p.doc;
	};
	parser.prototype.top = function() { return this.$val.top(); };
	parser.ptr.prototype.popUntil = function(s, matchTags) {
		var i, matchTags, p, s;
		p = this;
		i = p.indexOfElementInScope(s, matchTags);
		if (!((i === -1))) {
			p.oe = $subslice(p.oe, 0, i);
			return true;
		}
		return false;
	};
	parser.prototype.popUntil = function(s, matchTags) { return this.$val.popUntil(s, matchTags); };
	parser.ptr.prototype.indexOfElementInScope = function(s, matchTags) {
		var _1, _2, _entry, _i, _i$1, _ref, _ref$1, i, matchTags, p, s, t, t$1, tagAtom, x, x$1, x$2;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			tagAtom = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom;
			if ((x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).Namespace === "") {
				_ref = matchTags;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					t = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (t === tagAtom) {
						return i;
					}
					_i++;
				}
				_1 = s;
				if (_1 === (0)) {
				} else if (_1 === (1)) {
					if ((tagAtom === 79618) || (tagAtom === 42754)) {
						return -1;
					}
				} else if (_1 === (2)) {
					if (tagAtom === 102662) {
						return -1;
					}
				} else if (_1 === (3)) {
					if ((tagAtom === 22020) || (tagAtom === 365829) || (tagAtom === 463880)) {
						return -1;
					}
				} else if (_1 === (6)) {
					if (!((tagAtom === 24328)) && !((tagAtom === 451334))) {
						return -1;
					}
				} else {
					$panic(new $String("unreachable"));
				}
			}
			_2 = s;
			if ((_2 === (0)) || (_2 === (1)) || (_2 === (2))) {
				_ref$1 = (_entry = defaultScopeStopTags[$String.keyFor((x$2 = p.oe, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i])).Namespace)], _entry !== undefined ? _entry.v : sliceType$2.nil);
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					t$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
					if (t$1 === tagAtom) {
						return -1;
					}
					_i$1++;
				}
			}
			i = i - (1) >> 0;
		}
		return -1;
	};
	parser.prototype.indexOfElementInScope = function(s, matchTags) { return this.$val.indexOfElementInScope(s, matchTags); };
	parser.ptr.prototype.elementInScope = function(s, matchTags) {
		var matchTags, p, s;
		p = this;
		return !((p.indexOfElementInScope(s, matchTags) === -1));
	};
	parser.prototype.elementInScope = function(s, matchTags) { return this.$val.elementInScope(s, matchTags); };
	parser.ptr.prototype.clearStackToContext = function(s) {
		var _1, i, p, s, tagAtom, x;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			tagAtom = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom;
			_1 = s;
			if (_1 === (3)) {
				if ((tagAtom === 22020) || (tagAtom === 365829) || (tagAtom === 463880)) {
					p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
					return;
				}
			} else if (_1 === (4)) {
				if ((tagAtom === 22020) || (tagAtom === 52226) || (tagAtom === 463880)) {
					p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
					return;
				}
			} else if (_1 === (5)) {
				if ((tagAtom === 22020) || (tagAtom === 9989) || (tagAtom === 62725) || (tagAtom === 208901) || (tagAtom === 463880)) {
					p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
					return;
				}
			} else {
				$panic(new $String("unreachable"));
			}
			i = i - (1) >> 0;
		}
	};
	parser.prototype.clearStackToContext = function(s) { return this.$val.clearStackToContext(s); };
	parser.ptr.prototype.generateImpliedEndTags = function(exceptions) {
		var _1, _i, _ref, except, exceptions, i, n, p, x;
		p = this;
		i = 0;
		i = p.oe.$length - 1 >> 0;
		loop:
		while (true) {
			if (!(i >= 0)) { break; }
			n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (n.Type === 3) {
				_1 = n.DataAtom;
				if ((_1 === (186114)) || (_1 === (412418)) || (_1 === (45570)) || (_1 === (24328)) || (_1 === (451334)) || (_1 === (3073)) || (_1 === (14850)) || (_1 === (146434)) || (_1 === (104962)) || (_1 === (104963))) {
					_ref = exceptions;
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						except = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
						if (n.Data === except) {
							break loop;
						}
						_i++;
					}
					i = i - (1) >> 0;
					continue;
				}
			}
			break;
		}
		p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
	};
	parser.prototype.generateImpliedEndTags = function(exceptions) { return this.$val.generateImpliedEndTags(exceptions); };
	parser.ptr.prototype.addChild = function(n) {
		var n, p;
		p = this;
		if (p.shouldFosterParent()) {
			p.fosterParent(n);
		} else {
			p.top().AppendChild(n);
		}
		if (n.Type === 3) {
			p.oe = $append(p.oe, n);
		}
	};
	parser.prototype.addChild = function(n) { return this.$val.addChild(n); };
	parser.ptr.prototype.shouldFosterParent = function() {
		var _1, p;
		p = this;
		if (p.fosterParenting) {
			_1 = p.top().DataAtom;
			if ((_1 === (365829)) || (_1 === (9989)) || (_1 === (62725)) || (_1 === (208901)) || (_1 === (52226))) {
				return true;
			}
		}
		return false;
	};
	parser.prototype.shouldFosterParent = function() { return this.$val.shouldFosterParent(); };
	parser.ptr.prototype.fosterParent = function(n) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, j, n, p, parent, prev, table, template, x, x$1, x$2, x$3, x$4, x$5, x$6;
		p = this;
		_tmp = ptrType.nil;
		_tmp$1 = ptrType.nil;
		_tmp$2 = ptrType.nil;
		_tmp$3 = ptrType.nil;
		table = _tmp;
		parent = _tmp$1;
		prev = _tmp$2;
		template = _tmp$3;
		i = 0;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if ((x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom === 365829) {
				table = (x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]));
				break;
			}
			i = i - (1) >> 0;
		}
		j = 0;
		j = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(j >= 0)) { break; }
			if ((x$2 = p.oe, ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j])).DataAtom === 463880) {
				template = (x$3 = p.oe, ((j < 0 || j >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + j]));
				break;
			}
			j = j - (1) >> 0;
		}
		if (!(template === ptrType.nil) && (table === ptrType.nil || j > i)) {
			template.AppendChild(n);
			return;
		}
		if (table === ptrType.nil) {
			parent = (x$4 = p.oe, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0]));
		} else {
			parent = table.Parent;
		}
		if (parent === ptrType.nil) {
			parent = (x$5 = p.oe, x$6 = i - 1 >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6]));
		}
		if (!(table === ptrType.nil)) {
			prev = table.PrevSibling;
		} else {
			prev = parent.LastChild;
		}
		if (!(prev === ptrType.nil) && (prev.Type === 1) && (n.Type === 1)) {
			prev.Data = prev.Data + (n.Data);
			return;
		}
		parent.InsertBefore(n, table);
	};
	parser.prototype.fosterParent = function(n) { return this.$val.fosterParent(n); };
	parser.ptr.prototype.addText = function(text) {
		var n, p, t, text;
		p = this;
		if (text === "") {
			return;
		}
		if (p.shouldFosterParent()) {
			p.fosterParent(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, text, "", sliceType$1.nil));
			return;
		}
		t = p.top();
		n = t.LastChild;
		if (!(n === ptrType.nil) && (n.Type === 1)) {
			n.Data = n.Data + (text);
			return;
		}
		p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, text, "", sliceType$1.nil));
	};
	parser.prototype.addText = function(text) { return this.$val.addText(text); };
	parser.ptr.prototype.addElement = function() {
		var p;
		p = this;
		p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, p.tok.DataAtom, p.tok.Data, "", p.tok.Attr));
	};
	parser.prototype.addElement = function() { return this.$val.addElement(); };
	parser.ptr.prototype.addFormattingElement = function() {
		var _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, attr, i, identicalElements, n, p, t0, t1, tagAtom, x;
		p = this;
		_tmp = p.tok.DataAtom;
		_tmp$1 = p.tok.Attr;
		tagAtom = _tmp;
		attr = _tmp$1;
		p.addElement();
		identicalElements = 0;
		i = p.afe.$length - 1 >> 0;
		findIdenticalElements:
		while (true) {
			if (!(i >= 0)) { break; }
			n = (x = p.afe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (n.Type === 6) {
				break;
			}
			if (!((n.Type === 3))) {
				i = i - (1) >> 0;
				continue;
			}
			if (!(n.Namespace === "")) {
				i = i - (1) >> 0;
				continue;
			}
			if (!((n.DataAtom === tagAtom))) {
				i = i - (1) >> 0;
				continue;
			}
			if (!((n.Attr.$length === attr.$length))) {
				i = i - (1) >> 0;
				continue;
			}
			_ref = n.Attr;
			_i = 0;
			compareAttributes:
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				t0 = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
				_ref$1 = attr;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					t1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), Attribute);
					if (t0.Key === t1.Key && t0.Namespace === t1.Namespace && t0.Val === t1.Val) {
						_i++;
						continue compareAttributes;
					}
					_i$1++;
				}
				i = i - (1) >> 0;
				continue findIdenticalElements;
			}
			identicalElements = identicalElements + (1) >> 0;
			if (identicalElements >= 3) {
				(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(n);
			}
			i = i - (1) >> 0;
		}
		p.afe = $append(p.afe, p.top());
	};
	parser.prototype.addFormattingElement = function() { return this.$val.addFormattingElement(); };
	parser.ptr.prototype.clearActiveFormattingElements = function() {
		var n, p;
		p = this;
		while (true) {
			n = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).pop();
			if ((p.afe.$length === 0) || (n.Type === 6)) {
				return;
			}
		}
	};
	parser.prototype.clearActiveFormattingElements = function() { return this.$val.clearActiveFormattingElements(); };
	parser.ptr.prototype.reconstructActiveFormattingElements = function() {
		var clone, i, n, p, x, x$1, x$2;
		p = this;
		n = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).top();
		if (n === ptrType.nil) {
			return;
		}
		if ((n.Type === 6) || !(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(n) === -1))) {
			return;
		}
		i = p.afe.$length - 1 >> 0;
		while (true) {
			if (!(!((n.Type === 6)) && ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(n) === -1))) { break; }
			if (i === 0) {
				i = -1;
				break;
			}
			i = i - (1) >> 0;
			n = (x = p.afe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		}
		while (true) {
			i = i + (1) >> 0;
			clone = (x$1 = p.afe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).clone();
			p.addChild(clone);
			(x$2 = p.afe, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i] = clone));
			if (i === (p.afe.$length - 1 >> 0)) {
				break;
			}
		}
	};
	parser.prototype.reconstructActiveFormattingElements = function() { return this.$val.reconstructActiveFormattingElements(); };
	parser.ptr.prototype.acknowledgeSelfClosingTag = function() {
		var p;
		p = this;
		p.hasSelfClosingToken = false;
	};
	parser.prototype.acknowledgeSelfClosingTag = function() { return this.$val.acknowledgeSelfClosingTag(); };
	parser.ptr.prototype.setOriginalIM = function() {
		var p;
		p = this;
		if (!(p.originalIM === $throwNilPointerError)) {
			$panic(new $String("html: bad parser state: originalIM was set twice"));
		}
		p.originalIM = p.im;
	};
	parser.prototype.setOriginalIM = function() { return this.$val.setOriginalIM(); };
	parser.ptr.prototype.resetInsertionMode = function() {
		var _1, _2, _tmp, _tmp$1, ancestor, first, i, last, n, p, x, x$1, x$2, x$3;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			last = i === 0;
			if (last && !(p.context === ptrType.nil)) {
				n = p.context;
			}
			_1 = n.DataAtom;
			if (_1 === (408582)) {
				if (!last) {
					_tmp = n;
					_tmp$1 = (x$1 = p.oe, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
					ancestor = _tmp;
					first = _tmp$1;
					while (true) {
						if (!(!(ancestor === first))) { break; }
						ancestor = (x$2 = p.oe, x$3 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(ancestor) - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
						_2 = ancestor.DataAtom;
						if (_2 === (463880)) {
							p.im = inSelectIM;
							return;
						} else if (_2 === (365829)) {
							p.im = inSelectInTableIM;
							return;
						}
					}
				}
				p.im = inSelectIM;
			} else if ((_1 === (37378)) || (_1 === (87554))) {
				p.im = inCellIM;
			} else if (_1 === (52226)) {
				p.im = inRowIM;
			} else if ((_1 === (9989)) || (_1 === (208901)) || (_1 === (62725))) {
				p.im = inTableBodyIM;
			} else if (_1 === (143623)) {
				p.im = inCaptionIM;
			} else if (_1 === (109320)) {
				p.im = inColumnGroupIM;
			} else if (_1 === (365829)) {
				p.im = inTableIM;
			} else if (_1 === (463880)) {
				if (!(n.Namespace === "")) {
					i = i - (1) >> 0;
					continue;
				}
				p.im = (p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).top();
			} else if (_1 === (209156)) {
				p.im = inHeadIM;
			} else if (_1 === (10244)) {
				p.im = inBodyIM;
			} else if (_1 === (35592)) {
				p.im = inFramesetIM;
			} else if (_1 === (22020)) {
				if (p.head === ptrType.nil) {
					p.im = beforeHeadIM;
				} else {
					p.im = afterHeadIM;
				}
			} else {
				if (last) {
					p.im = inBodyIM;
					return;
				}
				i = i - (1) >> 0;
				continue;
			}
			return;
		}
	};
	parser.prototype.resetInsertionMode = function() { return this.$val.resetInsertionMode(); };
	beforeHeadIM = function(p) {
		var _1, _2, _3, _r, _r$1, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				p.tok.Data = _r;
				if (p.tok.Data.length === 0) {
					$s = -1; return true;
				}
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (209156)) { $s = 10; continue; }
					/* */ if (_2 === (22020)) { $s = 11; continue; }
					/* */ $s = 12; continue;
					/* if (_2 === (209156)) { */ case 10:
						p.addElement();
						p.head = p.top();
						p.im = inHeadIM;
						$s = -1; return true;
					/* } else if (_2 === (22020)) { */ case 11:
						_r$1 = inBodyIM(p); /* */ $s = 13; case 13: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } */ case 12:
				case 9:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if ((_3 === (209156)) || (_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if ((_3 === (209156)) || (_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { */ case 15:
						$r = p.parseImpliedToken(2, 209156, new atom.Atom(209156).String()); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else { */ case 16:
						$s = -1; return true;
					/* } */ case 17:
				case 14:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		$r = p.parseImpliedToken(2, 209156, new atom.Atom(209156).String()); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: beforeHeadIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inHeadIM = function(p) {
		var _1, _2, _3, _r, _r$1, i, n, p, s, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; i = $f.i; n = $f.n; p = $f.p; s = $f.s; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (s.length < p.tok.Data.length) {
					p.addText($substring(p.tok.Data, 0, (p.tok.Data.length - s.length >> 0)));
					if (s === "") {
						$s = -1; return true;
					}
					p.tok.Data = s;
				}
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 10; continue; }
					/* */ if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (120583)) || (_2 === (95236)) || (_2 === (309252))) { $s = 11; continue; }
					/* */ if (_2 === (136712)) { $s = 12; continue; }
					/* */ if ((_2 === (137222)) || (_2 === (69637)) || (_2 === (35080)) || (_2 === (458501))) { $s = 13; continue; }
					/* */ if (_2 === (209156)) { $s = 14; continue; }
					/* */ if (_2 === (463880)) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if (_2 === (22020)) { */ case 10:
						_r$1 = inBodyIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (120583)) || (_2 === (95236)) || (_2 === (309252))) { */ case 11:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = -1; return true;
					/* } else if (_2 === (136712)) { */ case 12:
						p.addElement();
						if (p.scripting) {
							p.setOriginalIM();
							p.im = textIM;
						} else {
							p.im = inHeadNoscriptIM;
						}
						$s = -1; return true;
					/* } else if ((_2 === (137222)) || (_2 === (69637)) || (_2 === (35080)) || (_2 === (458501))) { */ case 13:
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = -1; return true;
					/* } else if (_2 === (209156)) { */ case 14:
						$s = -1; return true;
					/* } else if (_2 === (463880)) { */ case 15:
						p.addElement();
						p.afe = $append(p.afe, scopeMarker);
						p.framesetOK = false;
						p.im = inTemplateIM;
						p.templateStack = $append(p.templateStack, inTemplateIM);
						$s = -1; return true;
					/* } */ case 16:
				case 9:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (209156)) { $s = 19; continue; }
					/* */ if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { $s = 20; continue; }
					/* */ if (_3 === (463880)) { $s = 21; continue; }
					/* */ $s = 22; continue;
					/* if (_3 === (209156)) { */ case 19:
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.im = afterHeadIM;
						$s = -1; return true;
					/* } else if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { */ case 20:
						$r = p.parseImpliedToken(3, 209156, new atom.Atom(209156).String()); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if (_3 === (463880)) { */ case 21:
						if (!(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						p.generateImpliedEndTags(new sliceType([]));
						i = p.oe.$length - 1 >> 0;
						while (true) {
							if (!(i >= 0)) { break; }
							n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
							if (n.Namespace === "" && (n.DataAtom === 463880)) {
								p.oe = $subslice(p.oe, 0, i);
								break;
							}
							i = i - (1) >> 0;
						}
						p.clearActiveFormattingElements();
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.resetInsertionMode();
						$s = -1; return true;
					/* } else { */ case 22:
						$s = -1; return true;
					/* } */ case 23:
				case 18:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		$r = p.parseImpliedToken(3, 209156, new atom.Atom(209156).String()); /* */ $s = 25; case 25: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inHeadIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.n = n; $f.p = p; $f.s = s; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	inHeadNoscriptIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, _r$4, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (6)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (1)) { $s = 5; continue; }
			/* */ if (_1 === (5)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (6)) { */ case 2:
				$s = -1; return true;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 9; continue; }
					/* */ if ((_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (458501))) { $s = 10; continue; }
					/* */ if ((_2 === (209156)) || (_2 === (136712))) { $s = 11; continue; }
					/* */ $s = 12; continue;
					/* if (_2 === (22020)) { */ case 9:
						_r = inBodyIM(p); /* */ $s = 13; case 13: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						$s = -1; return _r;
					/* } else if ((_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (458501))) { */ case 10:
						_r$1 = inHeadIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if ((_2 === (209156)) || (_2 === (136712))) { */ case 11:
						$s = -1; return true;
					/* } */ case 12:
				case 8:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
				_3 = p.tok.DataAtom;
				if ((_3 === (136712)) || (_3 === (514))) {
				} else {
					$s = -1; return true;
				}
				$s = 7; continue;
			/* } else if (_1 === (1)) { */ case 5:
				_r$2 = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				s = _r$2;
				/* */ if (s.length === 0) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (s.length === 0) { */ case 16:
					_r$3 = inHeadIM(p); /* */ $s = 18; case 18: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					$s = -1; return _r$3;
				/* } */ case 17:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 6:
				_r$4 = inHeadIM(p); /* */ $s = 19; case 19: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 7:
		case 1:
		(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		if (!((p.top().DataAtom === 209156))) {
			$panic(new $String("html: the new current node will be a head element."));
		}
		p.im = inHeadIM;
		if (p.tok.DataAtom === 136712) {
			$s = -1; return true;
		}
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inHeadNoscriptIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterHeadIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, p, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; p = $f.p; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (s.length < p.tok.Data.length) {
					p.addText($substring(p.tok.Data, 0, (p.tok.Data.length - s.length >> 0)));
					if (s === "") {
						$s = -1; return true;
					}
					p.tok.Data = s;
				}
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 10; continue; }
					/* */ if (_2 === (10244)) { $s = 11; continue; }
					/* */ if (_2 === (35592)) { $s = 12; continue; }
					/* */ if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { $s = 13; continue; }
					/* */ if (_2 === (209156)) { $s = 14; continue; }
					/* */ $s = 15; continue;
					/* if (_2 === (22020)) { */ case 10:
						_r$1 = inBodyIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_2 === (10244)) { */ case 11:
						p.addElement();
						p.framesetOK = false;
						p.im = inBodyIM;
						$s = -1; return true;
					/* } else if (_2 === (35592)) { */ case 12:
						p.addElement();
						p.im = inFramesetIM;
						$s = -1; return true;
					/* } else if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { */ case 13:
						p.oe = $append(p.oe, p.head);
						$deferred.push([$methodVal((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))), "remove"), [p.head]]);
						_r$2 = inHeadIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } else if (_2 === (209156)) { */ case 14:
						$s = -1; return true;
					/* } */ case 15:
				case 9:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { $s = 19; continue; }
					/* */ if (_3 === (463880)) { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { */ case 19:
						$s = 22; continue;
					/* } else if (_3 === (463880)) { */ case 20:
						_r$3 = inHeadIM(p); /* */ $s = 23; case 23: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } else { */ case 21:
						$s = -1; return true;
					/* } */ case 22:
				case 18:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		$r = p.parseImpliedToken(2, 10244, new atom.Atom(10244).String()); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		p.framesetOK = true;
		$s = -1; return false;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return false; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: afterHeadIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.p = p; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	copyAttributes = function(dst, src) {
		var _entry, _i, _i$1, _key, _key$1, _ref, _ref$1, _tuple, attr, dst, ok, src, t, t$1;
		if (src.Attr.$length === 0) {
			return;
		}
		attr = $makeMap($String.keyFor, []);
		_ref = dst.Attr;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			t = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
			_key = t.Key; (attr || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: t.Val };
			_i++;
		}
		_ref$1 = src.Attr;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			t$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), Attribute);
			_tuple = (_entry = attr[$String.keyFor(t$1.Key)], _entry !== undefined ? [_entry.v, true] : ["", false]);
			ok = _tuple[1];
			if (!ok) {
				dst.Attr = $append(dst.Attr, t$1);
				_key$1 = t$1.Key; (attr || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: t$1.Val };
			}
			_i$1++;
		}
	};
	inBodyIM = function(p) {
		var _1, _2, _3, _4, _5, _6, _7, _8, _9, _i, _i$1, _i$2, _r, _r$1, _r$2, _r$3, _ref, _ref$1, _ref$2, _v, action, attr, body, body$1, d, e, i, i$1, i$2, i$3, i$4, n, n$1, n$2, node, node$1, node$2, p, prompt, t, t$1, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _7 = $f._7; _8 = $f._8; _9 = $f._9; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _v = $f._v; action = $f.action; attr = $f.attr; body = $f.body; body$1 = $f.body$1; d = $f.d; e = $f.e; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; n = $f.n; n$1 = $f.n$1; n$2 = $f.n$2; node = $f.node; node$1 = $f.node$1; node$2 = $f.node$2; p = $f.p; prompt = $f.prompt; t = $f.t; t$1 = $f.t$1; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (0)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				d = p.tok.Data;
				n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
				_2 = n.DataAtom;
				if ((_2 === (290819)) || (_2 === (305415))) {
					if (n.FirstChild === ptrType.nil) {
						if (!(d === "") && (d.charCodeAt(0) === 13)) {
							d = $substring(d, 1);
						}
						if (!(d === "") && (d.charCodeAt(0) === 10)) {
							d = $substring(d, 1);
						}
					}
				}
				d = strings.Replace(d, "\x00", "", -1);
				if (d === "") {
					$s = -1; return true;
				}
				p.reconstructActiveFormattingElements();
				p.addText(d);
				if (!(p.framesetOK)) { _v = false; $s = 10; continue s; }
				_r = strings.TrimLeft(d, " \t\r\n\f"); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = !(_r === ""); case 10:
				/* */ if (_v) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (_v) { */ case 8:
					p.framesetOK = false;
				/* } */ case 9:
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 13; continue; }
					/* */ if ((_3 === (15108)) || (_3 === (15112)) || (_3 === (89607)) || (_3 === (120583)) || (_3 === (95236)) || (_3 === (309252)) || (_3 === (35080)) || (_3 === (137222)) || (_3 === (458501)) || (_3 === (463880)) || (_3 === (69637))) { $s = 14; continue; }
					/* */ if (_3 === (10244)) { $s = 15; continue; }
					/* */ if (_3 === (35592)) { $s = 16; continue; }
					/* */ if ((_3 === (455431)) || (_3 === (261127)) || (_3 === (67333)) || (_3 === (100106)) || (_3 === (139270)) || (_3 === (29191)) || (_3 === (37635)) || (_3 === (92931)) || (_3 === (386562)) || (_3 === (140808)) || (_3 === (142858)) || (_3 === (149510)) || (_3 === (62982)) || (_3 === (209158)) || (_3 === (182790)) || (_3 === (231172)) || (_3 === (4867)) || (_3 === (79618)) || (_3 === (3073)) || (_3 === (354311)) || (_3 === (459783)) || (_3 === (42754))) { $s = 17; continue; }
					/* */ if ((_3 === (89090)) || (_3 === (187906)) || (_3 === (199938)) || (_3 === (214274)) || (_3 === (216834)) || (_3 === (412930))) { $s = 18; continue; }
					/* */ if ((_3 === (290819)) || (_3 === (305415))) { $s = 19; continue; }
					/* */ if (_3 === (159236)) { $s = 20; continue; }
					/* */ if (_3 === (45570)) { $s = 21; continue; }
					/* */ if ((_3 === (186114)) || (_3 === (412418))) { $s = 22; continue; }
					/* */ if (_3 === (111113)) { $s = 23; continue; }
					/* */ if (_3 === (102662)) { $s = 24; continue; }
					/* */ if (_3 === (1)) { $s = 25; continue; }
					/* */ if ((_3 === (257)) || (_3 === (94211)) || (_3 === (378116)) || (_3 === (28162)) || (_3 === (16132)) || (_3 === (1537)) || (_3 === (9473)) || (_3 === (132613)) || (_3 === (53766)) || (_3 === (449798)) || (_3 === (26626)) || (_3 === (2817))) { $s = 26; continue; }
					/* */ if (_3 === (14084)) { $s = 27; continue; }
					/* */ if ((_3 === (203014)) || (_3 === (206599)) || (_3 === (157702))) { $s = 28; continue; }
					/* */ if (_3 === (365829)) { $s = 29; continue; }
					/* */ if ((_3 === (218628)) || (_3 === (514)) || (_3 === (28165)) || (_3 === (198403)) || (_3 === (281349)) || (_3 === (12806)) || (_3 === (359427))) { $s = 30; continue; }
					/* */ if ((_3 === (3077)) || (_3 === (227334)) || (_3 === (113157))) { $s = 31; continue; }
					/* */ if (_3 === (87810)) { $s = 32; continue; }
					/* */ if (_3 === (197125)) { $s = 33; continue; }
					/* */ if (_3 === (200455)) { $s = 34; continue; }
					/* */ if (_3 === (217608)) { $s = 35; continue; }
					/* */ if (_3 === (77571)) { $s = 36; continue; }
					/* */ if (_3 === (195590)) { $s = 37; continue; }
					/* */ if ((_3 === (27655)) || (_3 === (136712))) { $s = 38; continue; }
					/* */ if (_3 === (408582)) { $s = 39; continue; }
					/* */ if ((_3 === (24328)) || (_3 === (451334))) { $s = 40; continue; }
					/* */ if ((_3 === (14850)) || (_3 === (104963))) { $s = 41; continue; }
					/* */ if ((_3 === (146434)) || (_3 === (104962))) { $s = 42; continue; }
					/* */ if ((_3 === (208388)) || (_3 === (462339))) { $s = 43; continue; }
					/* */ if ((_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (35589)) || (_3 === (209156)) || (_3 === (9989)) || (_3 === (37378)) || (_3 === (62725)) || (_3 === (87554)) || (_3 === (208901)) || (_3 === (52226))) { $s = 44; continue; }
					/* */ $s = 45; continue;
					/* if (_3 === (22020)) { */ case 13:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						copyAttributes((x = p.oe, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])), $clone(p.tok, Token));
						$s = 46; continue;
					/* } else if ((_3 === (15108)) || (_3 === (15112)) || (_3 === (89607)) || (_3 === (120583)) || (_3 === (95236)) || (_3 === (309252)) || (_3 === (35080)) || (_3 === (137222)) || (_3 === (458501)) || (_3 === (463880)) || (_3 === (69637))) { */ case 14:
						_r$1 = inHeadIM(p); /* */ $s = 47; case 47: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (10244)) { */ case 15:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						if (p.oe.$length >= 2) {
							body = (x$1 = p.oe, (1 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 1]));
							if ((body.Type === 3) && (body.DataAtom === 10244)) {
								p.framesetOK = false;
								copyAttributes(body, $clone(p.tok, Token));
							}
						}
						$s = 46; continue;
					/* } else if (_3 === (35592)) { */ case 16:
						if (!p.framesetOK || p.oe.$length < 2 || !(((x$2 = p.oe, (1 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 1])).DataAtom === 10244))) {
							$s = -1; return true;
						}
						body$1 = (x$3 = p.oe, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1]));
						if (!(body$1.Parent === ptrType.nil)) {
							body$1.Parent.RemoveChild(body$1);
						}
						p.oe = $subslice(p.oe, 0, 1);
						p.addElement();
						p.im = inFramesetIM;
						$s = -1; return true;
					/* } else if ((_3 === (455431)) || (_3 === (261127)) || (_3 === (67333)) || (_3 === (100106)) || (_3 === (139270)) || (_3 === (29191)) || (_3 === (37635)) || (_3 === (92931)) || (_3 === (386562)) || (_3 === (140808)) || (_3 === (142858)) || (_3 === (149510)) || (_3 === (62982)) || (_3 === (209158)) || (_3 === (182790)) || (_3 === (231172)) || (_3 === (4867)) || (_3 === (79618)) || (_3 === (3073)) || (_3 === (354311)) || (_3 === (459783)) || (_3 === (42754))) { */ case 17:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (89090)) || (_3 === (187906)) || (_3 === (199938)) || (_3 === (214274)) || (_3 === (216834)) || (_3 === (412930))) { */ case 18:
						p.popUntil(2, new sliceType$2([3073]));
						n$1 = p.top();
						_4 = n$1.DataAtom;
						if ((_4 === (89090)) || (_4 === (187906)) || (_4 === (199938)) || (_4 === (214274)) || (_4 === (216834)) || (_4 === (412930))) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (290819)) || (_3 === (305415))) { */ case 19:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (159236)) { */ case 20:
						if (!(p.form === ptrType.nil) && !(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						if (!(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							p.form = p.top();
						}
						$s = 46; continue;
					/* } else if (_3 === (45570)) { */ case 21:
						p.framesetOK = false;
						i = p.oe.$length - 1 >> 0;
						/* while (true) { */ case 48:
							/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 49; continue; }
							node = (x$4 = p.oe, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i]));
							_5 = node.DataAtom;
							if (_5 === (45570)) {
								p.oe = $subslice(p.oe, 0, i);
							} else if ((_5 === (455431)) || (_5 === (92931)) || (_5 === (3073))) {
								i = i - (1) >> 0;
								/* continue; */ $s = 48; continue;
							} else if (!isSpecialElement(node)) {
								i = i - (1) >> 0;
								/* continue; */ $s = 48; continue;
							}
							/* break; */ $s = 49; continue;
						/* } */ $s = 48; continue; case 49:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (186114)) || (_3 === (412418))) { */ case 22:
						p.framesetOK = false;
						i$1 = p.oe.$length - 1 >> 0;
						/* while (true) { */ case 50:
							/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 51; continue; }
							node$1 = (x$5 = p.oe, ((i$1 < 0 || i$1 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i$1]));
							_6 = node$1.DataAtom;
							if ((_6 === (186114)) || (_6 === (412418))) {
								p.oe = $subslice(p.oe, 0, i$1);
							} else if ((_6 === (455431)) || (_6 === (92931)) || (_6 === (3073))) {
								i$1 = i$1 - (1) >> 0;
								/* continue; */ $s = 50; continue;
							} else if (!isSpecialElement(node$1)) {
								i$1 = i$1 - (1) >> 0;
								/* continue; */ $s = 50; continue;
							}
							/* break; */ $s = 51; continue;
						/* } */ $s = 50; continue; case 51:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if (_3 === (111113)) { */ case 23:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if (_3 === (102662)) { */ case 24:
						p.popUntil(0, new sliceType$2([102662]));
						p.reconstructActiveFormattingElements();
						p.addElement();
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (1)) { */ case 25:
						i$2 = p.afe.$length - 1 >> 0;
						while (true) {
							if (!(i$2 >= 0 && !(((x$6 = p.afe, ((i$2 < 0 || i$2 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i$2])).Type === 6)))) { break; }
							n$2 = (x$7 = p.afe, ((i$2 < 0 || i$2 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + i$2]));
							if ((n$2.Type === 3) && (n$2.DataAtom === 1)) {
								p.inBodyEndTagFormatting(1, "a");
								(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(n$2);
								(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(n$2);
								break;
							}
							i$2 = i$2 - (1) >> 0;
						}
						p.reconstructActiveFormattingElements();
						p.addFormattingElement();
						$s = 46; continue;
					/* } else if ((_3 === (257)) || (_3 === (94211)) || (_3 === (378116)) || (_3 === (28162)) || (_3 === (16132)) || (_3 === (1537)) || (_3 === (9473)) || (_3 === (132613)) || (_3 === (53766)) || (_3 === (449798)) || (_3 === (26626)) || (_3 === (2817))) { */ case 26:
						p.reconstructActiveFormattingElements();
						p.addFormattingElement();
						$s = 46; continue;
					/* } else if (_3 === (14084)) { */ case 27:
						p.reconstructActiveFormattingElements();
						if (p.elementInScope(0, new sliceType$2([14084]))) {
							p.inBodyEndTagFormatting(14084, "nobr");
							p.reconstructActiveFormattingElements();
						}
						p.addFormattingElement();
						$s = 46; continue;
					/* } else if ((_3 === (203014)) || (_3 === (206599)) || (_3 === (157702))) { */ case 28:
						p.reconstructActiveFormattingElements();
						p.addElement();
						p.afe = $append(p.afe, scopeMarker);
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (365829)) { */ case 29:
						if (!p.quirks) {
							p.popUntil(2, new sliceType$2([3073]));
						}
						p.addElement();
						p.framesetOK = false;
						p.im = inTableIM;
						$s = -1; return true;
					/* } else if ((_3 === (218628)) || (_3 === (514)) || (_3 === (28165)) || (_3 === (198403)) || (_3 === (281349)) || (_3 === (12806)) || (_3 === (359427))) { */ case 30:
						p.reconstructActiveFormattingElements();
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						/* */ if (p.tok.DataAtom === 281349) { $s = 52; continue; }
						/* */ $s = 53; continue;
						/* if (p.tok.DataAtom === 281349) { */ case 52:
							_ref = p.tok.Attr;
							_i = 0;
							/* while (true) { */ case 54:
								/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 55; continue; }
								t = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
								/* */ if (t.Key === "type") { $s = 56; continue; }
								/* */ $s = 57; continue;
								/* if (t.Key === "type") { */ case 56:
									_r$2 = strings.ToLower(t.Val); /* */ $s = 60; case 60: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
									/* */ if (_r$2 === "hidden") { $s = 58; continue; }
									/* */ $s = 59; continue;
									/* if (_r$2 === "hidden") { */ case 58:
										$s = -1; return true;
									/* } */ case 59:
								/* } */ case 57:
								_i++;
							/* } */ $s = 54; continue; case 55:
						/* } */ case 53:
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if ((_3 === (3077)) || (_3 === (227334)) || (_3 === (113157))) { */ case 31:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = 46; continue;
					/* } else if (_3 === (87810)) { */ case 32:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (197125)) { */ case 33:
						p.tok.DataAtom = 198403;
						p.tok.Data = new atom.Atom(198403).String();
						$s = -1; return false;
					/* } else if (_3 === (200455)) { */ case 34:
						if (!(p.form === ptrType.nil)) {
							$s = -1; return true;
						}
						action = "";
						prompt = "This is a searchable index. Enter search keywords: ";
						attr = new sliceType$1([new Attribute.ptr("", "name", "isindex")]);
						_ref$1 = p.tok.Attr;
						_i$1 = 0;
						while (true) {
							if (!(_i$1 < _ref$1.$length)) { break; }
							t$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), Attribute);
							_7 = t$1.Key;
							if (_7 === ("action")) {
								action = t$1.Val;
							} else if (_7 === ("name")) {
							} else if (_7 === ("prompt")) {
								prompt = t$1.Val;
							} else {
								attr = $append(attr, t$1);
							}
							_i$1++;
						}
						p.acknowledgeSelfClosingTag();
						p.popUntil(2, new sliceType$2([3073]));
						$r = p.parseImpliedToken(2, 159236, new atom.Atom(159236).String()); /* */ $s = 61; case 61: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						if (p.form === ptrType.nil) {
							$s = -1; return true;
						}
						if (!(action === "")) {
							p.form.Attr = new sliceType$1([new Attribute.ptr("", "action", action)]);
						}
						$r = p.parseImpliedToken(2, 87810, new atom.Atom(87810).String()); /* */ $s = 62; case 62: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$r = p.parseImpliedToken(2, 22789, new atom.Atom(22789).String()); /* */ $s = 63; case 63: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						p.addText(prompt);
						p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, 281349, new atom.Atom(281349).String(), "", attr));
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						$r = p.parseImpliedToken(3, 22789, new atom.Atom(22789).String()); /* */ $s = 64; case 64: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$r = p.parseImpliedToken(2, 87810, new atom.Atom(87810).String()); /* */ $s = 65; case 65: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$r = p.parseImpliedToken(3, 159236, new atom.Atom(159236).String()); /* */ $s = 66; case 66: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = 46; continue;
					/* } else if (_3 === (217608)) { */ case 35:
						p.addElement();
						p.setOriginalIM();
						p.framesetOK = false;
						p.im = textIM;
						$s = 46; continue;
					/* } else if (_3 === (77571)) { */ case 36:
						p.popUntil(2, new sliceType$2([3073]));
						p.reconstructActiveFormattingElements();
						p.framesetOK = false;
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = 46; continue;
					/* } else if (_3 === (195590)) { */ case 37:
						p.framesetOK = false;
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = 46; continue;
					/* } else if ((_3 === (27655)) || (_3 === (136712))) { */ case 38:
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = 46; continue;
					/* } else if (_3 === (408582)) { */ case 39:
						p.reconstructActiveFormattingElements();
						p.addElement();
						p.framesetOK = false;
						p.im = inSelectIM;
						$s = -1; return true;
					/* } else if ((_3 === (24328)) || (_3 === (451334))) { */ case 40:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.reconstructActiveFormattingElements();
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (14850)) || (_3 === (104963))) { */ case 41:
						if (p.elementInScope(0, new sliceType$2([64260]))) {
							p.generateImpliedEndTags(new sliceType([]));
						}
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (146434)) || (_3 === (104962))) { */ case 42:
						if (p.elementInScope(0, new sliceType$2([64260]))) {
							p.generateImpliedEndTags(new sliceType(["rtc"]));
						}
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (208388)) || (_3 === (462339))) { */ case 43:
						p.reconstructActiveFormattingElements();
						if (p.tok.DataAtom === 208388) {
							adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments);
						} else {
							adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments);
						}
						adjustForeignAttributes(p.tok.Attr);
						p.addElement();
						p.top().Namespace = p.tok.Data;
						if (p.hasSelfClosingToken) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
							p.acknowledgeSelfClosingTag();
						}
						$s = -1; return true;
					/* } else if ((_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (35589)) || (_3 === (209156)) || (_3 === (9989)) || (_3 === (37378)) || (_3 === (62725)) || (_3 === (87554)) || (_3 === (208901)) || (_3 === (52226))) { */ case 44:
						$s = 46; continue;
					/* } else { */ case 45:
						p.reconstructActiveFormattingElements();
						p.addElement();
					/* } */ case 46:
				case 12:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_8 = p.tok.DataAtom;
					/* */ if (_8 === (10244)) { $s = 68; continue; }
					/* */ if (_8 === (22020)) { $s = 69; continue; }
					/* */ if ((_8 === (455431)) || (_8 === (261127)) || (_8 === (67333)) || (_8 === (100106)) || (_8 === (102662)) || (_8 === (139270)) || (_8 === (29191)) || (_8 === (37635)) || (_8 === (92931)) || (_8 === (386562)) || (_8 === (140808)) || (_8 === (142858)) || (_8 === (149510)) || (_8 === (62982)) || (_8 === (209158)) || (_8 === (182790)) || (_8 === (305415)) || (_8 === (231172)) || (_8 === (4867)) || (_8 === (79618)) || (_8 === (290819)) || (_8 === (354311)) || (_8 === (459783)) || (_8 === (42754))) { $s = 70; continue; }
					/* */ if (_8 === (159236)) { $s = 71; continue; }
					/* */ if (_8 === (3073)) { $s = 72; continue; }
					/* */ if (_8 === (45570)) { $s = 73; continue; }
					/* */ if ((_8 === (186114)) || (_8 === (412418))) { $s = 74; continue; }
					/* */ if ((_8 === (89090)) || (_8 === (187906)) || (_8 === (199938)) || (_8 === (214274)) || (_8 === (216834)) || (_8 === (412930))) { $s = 75; continue; }
					/* */ if ((_8 === (1)) || (_8 === (257)) || (_8 === (94211)) || (_8 === (378116)) || (_8 === (28162)) || (_8 === (16132)) || (_8 === (1537)) || (_8 === (14084)) || (_8 === (9473)) || (_8 === (132613)) || (_8 === (53766)) || (_8 === (449798)) || (_8 === (26626)) || (_8 === (2817))) { $s = 76; continue; }
					/* */ if ((_8 === (203014)) || (_8 === (206599)) || (_8 === (157702))) { $s = 77; continue; }
					/* */ if (_8 === (514)) { $s = 78; continue; }
					/* */ if (_8 === (463880)) { $s = 79; continue; }
					/* */ $s = 80; continue;
					/* if (_8 === (10244)) { */ case 68:
						if (p.elementInScope(0, new sliceType$2([10244]))) {
							p.im = afterBodyIM;
						}
						$s = 81; continue;
					/* } else if (_8 === (22020)) { */ case 69:
						/* */ if (p.elementInScope(0, new sliceType$2([10244]))) { $s = 82; continue; }
						/* */ $s = 83; continue;
						/* if (p.elementInScope(0, new sliceType$2([10244]))) { */ case 82:
							$r = p.parseImpliedToken(3, 10244, new atom.Atom(10244).String()); /* */ $s = 84; case 84: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return false;
						/* } */ case 83:
						$s = -1; return true;
					/* } else if ((_8 === (455431)) || (_8 === (261127)) || (_8 === (67333)) || (_8 === (100106)) || (_8 === (102662)) || (_8 === (139270)) || (_8 === (29191)) || (_8 === (37635)) || (_8 === (92931)) || (_8 === (386562)) || (_8 === (140808)) || (_8 === (142858)) || (_8 === (149510)) || (_8 === (62982)) || (_8 === (209158)) || (_8 === (182790)) || (_8 === (305415)) || (_8 === (231172)) || (_8 === (4867)) || (_8 === (79618)) || (_8 === (290819)) || (_8 === (354311)) || (_8 === (459783)) || (_8 === (42754))) { */ case 70:
						p.popUntil(0, new sliceType$2([p.tok.DataAtom]));
						$s = 81; continue;
					/* } else if (_8 === (159236)) { */ case 71:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							i$3 = p.indexOfElementInScope(0, new sliceType$2([159236]));
							if (i$3 === -1) {
								$s = -1; return true;
							}
							p.generateImpliedEndTags(new sliceType([]));
							if (!(((x$8 = p.oe, ((i$3 < 0 || i$3 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + i$3])).DataAtom === 159236))) {
								$s = -1; return true;
							}
							p.popUntil(0, new sliceType$2([159236]));
						} else {
							node$2 = p.form;
							p.form = ptrType.nil;
							i$4 = p.indexOfElementInScope(0, new sliceType$2([159236]));
							if (node$2 === ptrType.nil || (i$4 === -1) || !((x$9 = p.oe, ((i$4 < 0 || i$4 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + i$4])) === node$2)) {
								$s = -1; return true;
							}
							p.generateImpliedEndTags(new sliceType([]));
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(node$2);
						}
						$s = 81; continue;
					/* } else if (_8 === (3073)) { */ case 72:
						/* */ if (!p.elementInScope(2, new sliceType$2([3073]))) { $s = 85; continue; }
						/* */ $s = 86; continue;
						/* if (!p.elementInScope(2, new sliceType$2([3073]))) { */ case 85:
							$r = p.parseImpliedToken(2, 3073, new atom.Atom(3073).String()); /* */ $s = 87; case 87: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						/* } */ case 86:
						p.popUntil(2, new sliceType$2([3073]));
						$s = 81; continue;
					/* } else if (_8 === (45570)) { */ case 73:
						p.popUntil(1, new sliceType$2([45570]));
						$s = 81; continue;
					/* } else if ((_8 === (186114)) || (_8 === (412418))) { */ case 74:
						p.popUntil(0, new sliceType$2([p.tok.DataAtom]));
						$s = 81; continue;
					/* } else if ((_8 === (89090)) || (_8 === (187906)) || (_8 === (199938)) || (_8 === (214274)) || (_8 === (216834)) || (_8 === (412930))) { */ case 75:
						p.popUntil(0, new sliceType$2([89090, 187906, 199938, 214274, 216834, 412930]));
						$s = 81; continue;
					/* } else if ((_8 === (1)) || (_8 === (257)) || (_8 === (94211)) || (_8 === (378116)) || (_8 === (28162)) || (_8 === (16132)) || (_8 === (1537)) || (_8 === (14084)) || (_8 === (9473)) || (_8 === (132613)) || (_8 === (53766)) || (_8 === (449798)) || (_8 === (26626)) || (_8 === (2817))) { */ case 76:
						p.inBodyEndTagFormatting(p.tok.DataAtom, p.tok.Data);
						$s = 81; continue;
					/* } else if ((_8 === (203014)) || (_8 === (206599)) || (_8 === (157702))) { */ case 77:
						if (p.popUntil(0, new sliceType$2([p.tok.DataAtom]))) {
							p.clearActiveFormattingElements();
						}
						$s = 81; continue;
					/* } else if (_8 === (514)) { */ case 78:
						p.tok.Type = 2;
						$s = -1; return false;
					/* } else if (_8 === (463880)) { */ case 79:
						_r$3 = inHeadIM(p); /* */ $s = 88; case 88: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } else { */ case 80:
						p.inBodyEndTagOther(p.tok.DataAtom, p.tok.Data);
					/* } */ case 81:
				case 67:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 7; continue;
			/* } else if (_1 === (0)) { */ case 6:
				if (p.templateStack.$length > 0) {
					p.im = inTemplateIM;
					$s = -1; return false;
				} else {
					_ref$2 = p.oe;
					_i$2 = 0;
					while (true) {
						if (!(_i$2 < _ref$2.$length)) { break; }
						e = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
						_9 = e.DataAtom;
						if ((_9 === (186114)) || (_9 === (412418)) || (_9 === (45570)) || (_9 === (24328)) || (_9 === (451334)) || (_9 === (3073)) || (_9 === (14850)) || (_9 === (146434)) || (_9 === (104962)) || (_9 === (104963)) || (_9 === (9989)) || (_9 === (37378)) || (_9 === (62725)) || (_9 === (87554)) || (_9 === (208901)) || (_9 === (52226)) || (_9 === (10244)) || (_9 === (22020))) {
						} else {
							$s = -1; return true;
						}
						_i$2++;
					}
				}
			/* } */ case 7:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inBodyIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._7 = _7; $f._8 = _8; $f._9 = _9; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._v = _v; $f.action = action; $f.attr = attr; $f.body = body; $f.body$1 = body$1; $f.d = d; $f.e = e; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.n = n; $f.n$1 = n$1; $f.n$2 = n$2; $f.node = node; $f.node$1 = node$1; $f.node$2 = node$2; $f.p = p; $f.prompt = prompt; $f.t = t; $f.t$1 = t$1; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.ptr.prototype.inBodyEndTagFormatting = function(tagAtom, tagName) {
		var _1, _i, _ref, bookmark, clone, clone$1, commonAncestor, e, e$1, feIndex, formattingElement, furthestBlock, i, j, j$1, lastNode, node, oldLoc, p, tagAtom, tagName, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		p = this;
		i = 0;
		while (true) {
			if (!(i < 8)) { break; }
			formattingElement = ptrType.nil;
			j = p.afe.$length - 1 >> 0;
			while (true) {
				if (!(j >= 0)) { break; }
				if ((x = p.afe, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j])).Type === 6) {
					break;
				}
				if ((x$1 = p.afe, ((j < 0 || j >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + j])).DataAtom === tagAtom) {
					formattingElement = (x$2 = p.afe, ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j]));
					break;
				}
				j = j - (1) >> 0;
			}
			if (formattingElement === ptrType.nil) {
				p.inBodyEndTagOther(tagAtom, tagName);
				return;
			}
			feIndex = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(formattingElement);
			if (feIndex === -1) {
				(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(formattingElement);
				return;
			}
			if (!p.elementInScope(0, new sliceType$2([tagAtom]))) {
				return;
			}
			furthestBlock = ptrType.nil;
			_ref = $subslice(p.oe, feIndex);
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				e = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (isSpecialElement(e)) {
					furthestBlock = e;
					break;
				}
				_i++;
			}
			if (furthestBlock === ptrType.nil) {
				e$1 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
				while (true) {
					if (!(!(e$1 === formattingElement))) { break; }
					e$1 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
				}
				(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(e$1);
				return;
			}
			commonAncestor = (x$3 = p.oe, x$4 = feIndex - 1 >> 0, ((x$4 < 0 || x$4 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + x$4]));
			bookmark = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(formattingElement);
			lastNode = furthestBlock;
			node = furthestBlock;
			x$5 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(node);
			j$1 = 0;
			while (true) {
				if (!(j$1 < 3)) { break; }
				x$5 = x$5 - (1) >> 0;
				node = (x$6 = p.oe, ((x$5 < 0 || x$5 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$5]));
				if ((p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(node) === -1) {
					(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(node);
					j$1 = j$1 + (1) >> 0;
					continue;
				}
				if (node === formattingElement) {
					break;
				}
				clone = node.clone();
				(x$7 = p.afe, x$8 = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(node), ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8] = clone));
				(x$9 = p.oe, x$10 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(node), ((x$10 < 0 || x$10 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + x$10] = clone));
				node = clone;
				if (lastNode === furthestBlock) {
					bookmark = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(node) + 1 >> 0;
				}
				if (!(lastNode.Parent === ptrType.nil)) {
					lastNode.Parent.RemoveChild(lastNode);
				}
				node.AppendChild(lastNode);
				lastNode = node;
				j$1 = j$1 + (1) >> 0;
			}
			if (!(lastNode.Parent === ptrType.nil)) {
				lastNode.Parent.RemoveChild(lastNode);
			}
			_1 = commonAncestor.DataAtom;
			if ((_1 === (365829)) || (_1 === (9989)) || (_1 === (62725)) || (_1 === (208901)) || (_1 === (52226))) {
				p.fosterParent(lastNode);
			} else {
				commonAncestor.AppendChild(lastNode);
			}
			clone$1 = formattingElement.clone();
			reparentChildren(clone$1, furthestBlock);
			furthestBlock.AppendChild(clone$1);
			oldLoc = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(formattingElement);
			if (!((oldLoc === -1)) && oldLoc < bookmark) {
				bookmark = bookmark - (1) >> 0;
			}
			(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(formattingElement);
			(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).insert(bookmark, clone$1);
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(formattingElement);
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).insert((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(furthestBlock) + 1 >> 0, clone$1);
			i = i + (1) >> 0;
		}
	};
	parser.prototype.inBodyEndTagFormatting = function(tagAtom, tagName) { return this.$val.inBodyEndTagFormatting(tagAtom, tagName); };
	parser.ptr.prototype.inBodyEndTagOther = function(tagAtom, tagName) {
		var i, p, tagAtom, tagName, x, x$1, x$2;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if ((((x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom === tagAtom)) && ((!((tagAtom === 0))) || ((x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).Data === tagName))) {
				p.oe = $subslice(p.oe, 0, i);
				break;
			}
			if (isSpecialElement((x$2 = p.oe, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i])))) {
				break;
			}
			i = i - (1) >> 0;
		}
	};
	parser.prototype.inBodyEndTagOther = function(tagAtom, tagName) { return this.$val.inBodyEndTagOther(tagAtom, tagName); };
	textIM = function(p) {
		var _1, d, n, p;
		_1 = p.tok.Type;
		if (_1 === (0)) {
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		} else if (_1 === (1)) {
			d = p.tok.Data;
			n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
			if ((n.DataAtom === 217608) && n.FirstChild === ptrType.nil) {
				if (!(d === "") && (d.charCodeAt(0) === 13)) {
					d = $substring(d, 1);
				}
				if (!(d === "") && (d.charCodeAt(0) === 10)) {
					d = $substring(d, 1);
				}
			}
			if (d === "") {
				return true;
			}
			p.addText(d);
			return true;
		} else if (_1 === (3)) {
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		}
		p.im = p.originalIM;
		p.originalIM = $throwNilPointerError;
		return p.tok.Type === 3;
	};
	inTableIM = function(p) {
		var _1, _2, _3, _4, _5, _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _ref, _v, p, t, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; _v = $f._v; p = $f.p; t = $f.t; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		p = [p];
			_1 = p[0].tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ if (_1 === (0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (1)) { */ case 2:
				p[0].tok.Data = strings.Replace(p[0].tok.Data, "\x00", "", -1);
					_2 = (p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).top().DataAtom;
					/* */ if ((_2 === (365829)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if ((_2 === (365829)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) { */ case 10:
						_r = strings.Trim(p[0].tok.Data, " \t\r\n\f"); /* */ $s = 14; case 14: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						/* */ if (_r === "") { $s = 12; continue; }
						/* */ $s = 13; continue;
						/* if (_r === "") { */ case 12:
							p[0].addText(p[0].tok.Data);
							$s = -1; return true;
						/* } */ case 13:
					/* } */ case 11:
				case 9:
				$s = 8; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_3 = p[0].tok.DataAtom;
					/* */ if (_3 === (143623)) { $s = 16; continue; }
					/* */ if (_3 === (109320)) { $s = 17; continue; }
					/* */ if (_3 === (109315)) { $s = 18; continue; }
					/* */ if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { $s = 19; continue; }
					/* */ if ((_3 === (37378)) || (_3 === (87554)) || (_3 === (52226))) { $s = 20; continue; }
					/* */ if (_3 === (365829)) { $s = 21; continue; }
					/* */ if ((_3 === (458501)) || (_3 === (137222)) || (_3 === (463880))) { $s = 22; continue; }
					/* */ if (_3 === (281349)) { $s = 23; continue; }
					/* */ if (_3 === (159236)) { $s = 24; continue; }
					/* */ if (_3 === (408582)) { $s = 25; continue; }
					/* */ $s = 26; continue;
					/* if (_3 === (143623)) { */ case 16:
						p[0].clearStackToContext(3);
						p[0].afe = $append(p[0].afe, scopeMarker);
						p[0].addElement();
						p[0].im = inCaptionIM;
						$s = -1; return true;
					/* } else if (_3 === (109320)) { */ case 17:
						p[0].clearStackToContext(3);
						p[0].addElement();
						p[0].im = inColumnGroupIM;
						$s = -1; return true;
					/* } else if (_3 === (109315)) { */ case 18:
						$r = p[0].parseImpliedToken(2, 109320, new atom.Atom(109320).String()); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { */ case 19:
						p[0].clearStackToContext(3);
						p[0].addElement();
						p[0].im = inTableBodyIM;
						$s = -1; return true;
					/* } else if ((_3 === (37378)) || (_3 === (87554)) || (_3 === (52226))) { */ case 20:
						$r = p[0].parseImpliedToken(2, 9989, new atom.Atom(9989).String()); /* */ $s = 28; case 28: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if (_3 === (365829)) { */ case 21:
						if (p[0].popUntil(3, new sliceType$2([365829]))) {
							p[0].resetInsertionMode();
							$s = -1; return false;
						}
						$s = -1; return true;
					/* } else if ((_3 === (458501)) || (_3 === (137222)) || (_3 === (463880))) { */ case 22:
						_r$1 = inHeadIM(p[0]); /* */ $s = 29; case 29: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (281349)) { */ case 23:
						_ref = p[0].tok.Attr;
						_i = 0;
						/* while (true) { */ case 30:
							/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 31; continue; }
							t = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
							if (!(t.Key === "type")) { _v = false; $s = 34; continue s; }
							_r$2 = strings.ToLower(t.Val); /* */ $s = 35; case 35: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
							_v = _r$2 === "hidden"; case 34:
							/* */ if (_v) { $s = 32; continue; }
							/* */ $s = 33; continue;
							/* if (_v) { */ case 32:
								p[0].addElement();
								(p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).pop();
								$s = -1; return true;
							/* } */ case 33:
							_i++;
						/* } */ $s = 30; continue; case 31:
						$s = 26; continue;
					/* } else if (_3 === (159236)) { */ case 24:
						if ((p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).contains(463880) || !(p[0].form === ptrType.nil)) {
							$s = -1; return true;
						}
						p[0].addElement();
						p[0].form = (p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).pop();
						$s = 26; continue;
					/* } else if (_3 === (408582)) { */ case 25:
						p[0].reconstructActiveFormattingElements();
						_4 = p[0].top().DataAtom;
						if ((_4 === (365829)) || (_4 === (9989)) || (_4 === (62725)) || (_4 === (208901)) || (_4 === (52226))) {
							p[0].fosterParenting = true;
						}
						p[0].addElement();
						p[0].fosterParenting = false;
						p[0].framesetOK = false;
						p[0].im = inSelectInTableIM;
						$s = -1; return true;
					/* } */ case 26:
				case 15:
				$s = 8; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_5 = p[0].tok.DataAtom;
					/* */ if (_5 === (365829)) { $s = 37; continue; }
					/* */ if ((_5 === (10244)) || (_5 === (143623)) || (_5 === (109315)) || (_5 === (109320)) || (_5 === (22020)) || (_5 === (9989)) || (_5 === (37378)) || (_5 === (62725)) || (_5 === (87554)) || (_5 === (208901)) || (_5 === (52226))) { $s = 38; continue; }
					/* */ if (_5 === (463880)) { $s = 39; continue; }
					/* */ $s = 40; continue;
					/* if (_5 === (365829)) { */ case 37:
						if (p[0].popUntil(3, new sliceType$2([365829]))) {
							p[0].resetInsertionMode();
							$s = -1; return true;
						}
						$s = -1; return true;
					/* } else if ((_5 === (10244)) || (_5 === (143623)) || (_5 === (109315)) || (_5 === (109320)) || (_5 === (22020)) || (_5 === (9989)) || (_5 === (37378)) || (_5 === (62725)) || (_5 === (87554)) || (_5 === (208901)) || (_5 === (52226))) { */ case 38:
						$s = -1; return true;
					/* } else if (_5 === (463880)) { */ case 39:
						_r$3 = inHeadIM(p[0]); /* */ $s = 41; case 41: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } */ case 40:
				case 36:
				$s = 8; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p[0].addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p[0].tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } else if (_1 === (0)) { */ case 7:
				_r$4 = inBodyIM(p[0]); /* */ $s = 42; case 42: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 8:
		case 1:
		p[0].fosterParenting = true;
		$deferred.push([(function(p) { return function() {
			p[0].fosterParenting = false;
		}; })(p), []]);
		_r$5 = inBodyIM(p[0]); /* */ $s = 43; case 43: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		$s = -1; return _r$5;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return false; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: inTableIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f._v = _v; $f.p = p; $f.t = t; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	inCaptionIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_1 = p.tok.Type;
		if (_1 === (2)) {
			_2 = p.tok.DataAtom;
			if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (37378)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) {
				if (p.popUntil(3, new sliceType$2([143623]))) {
					p.clearActiveFormattingElements();
					p.im = inTableIM;
					$s = -1; return false;
				} else {
					$s = -1; return true;
				}
			} else if (_2 === (408582)) {
				p.reconstructActiveFormattingElements();
				p.addElement();
				p.framesetOK = false;
				p.im = inSelectInTableIM;
				$s = -1; return true;
			}
		} else if (_1 === (3)) {
			_3 = p.tok.DataAtom;
			if (_3 === (143623)) {
				if (p.popUntil(3, new sliceType$2([143623]))) {
					p.clearActiveFormattingElements();
					p.im = inTableIM;
				}
				$s = -1; return true;
			} else if (_3 === (365829)) {
				if (p.popUntil(3, new sliceType$2([143623]))) {
					p.clearActiveFormattingElements();
					p.im = inTableIM;
					$s = -1; return false;
				} else {
					$s = -1; return true;
				}
			} else if ((_3 === (10244)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (9989)) || (_3 === (37378)) || (_3 === (62725)) || (_3 === (87554)) || (_3 === (208901)) || (_3 === (52226))) {
				$s = -1; return true;
			}
		}
		_r = inBodyIM(p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inCaptionIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inColumnGroupIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, _r$4, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (5)) { $s = 3; continue; }
			/* */ if (_1 === (6)) { $s = 4; continue; }
			/* */ if (_1 === (2)) { $s = 5; continue; }
			/* */ if (_1 === (3)) { $s = 6; continue; }
			/* */ if (_1 === (0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (s.length < p.tok.Data.length) {
					p.addText($substring(p.tok.Data, 0, (p.tok.Data.length - s.length >> 0)));
					if (s === "") {
						$s = -1; return true;
					}
					p.tok.Data = s;
				}
				$s = 8; continue;
			/* } else if (_1 === (5)) { */ case 3:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 4:
				$s = -1; return true;
			/* } else if (_1 === (2)) { */ case 5:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 11; continue; }
					/* */ if (_2 === (109315)) { $s = 12; continue; }
					/* */ if (_2 === (463880)) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if (_2 === (22020)) { */ case 11:
						_r$1 = inBodyIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_2 === (109315)) { */ case 12:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = -1; return true;
					/* } else if (_2 === (463880)) { */ case 13:
						_r$2 = inHeadIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 14:
				case 10:
				$s = 8; continue;
			/* } else if (_1 === (3)) { */ case 6:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (109320)) { $s = 18; continue; }
					/* */ if (_3 === (109315)) { $s = 19; continue; }
					/* */ if (_3 === (463880)) { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if (_3 === (109320)) { */ case 18:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 109320) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
							p.im = inTableIM;
						}
						$s = -1; return true;
					/* } else if (_3 === (109315)) { */ case 19:
						$s = -1; return true;
					/* } else if (_3 === (463880)) { */ case 20:
						_r$3 = inHeadIM(p); /* */ $s = 22; case 22: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } */ case 21:
				case 17:
				$s = 8; continue;
			/* } else if (_1 === (0)) { */ case 7:
				_r$4 = inBodyIM(p); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 8:
		case 1:
		if (!(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 109320))) {
			$s = -1; return true;
		}
		(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		p.im = inTableIM;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inColumnGroupIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	inTableBodyIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (2)) { $s = 2; continue; }
			/* */ if (_1 === (3)) { $s = 3; continue; }
			/* */ if (_1 === (5)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === (2)) { */ case 2:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (52226)) { $s = 7; continue; }
					/* */ if ((_2 === (37378)) || (_2 === (87554))) { $s = 8; continue; }
					/* */ if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (_2 === (52226)) { */ case 7:
						p.clearStackToContext(5);
						p.addElement();
						p.im = inRowIM;
						$s = -1; return true;
					/* } else if ((_2 === (37378)) || (_2 === (87554))) { */ case 8:
						$r = p.parseImpliedToken(2, 52226, new atom.Atom(52226).String()); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { */ case 9:
						if (p.popUntil(3, new sliceType$2([9989, 208901, 62725]))) {
							p.im = inTableIM;
							$s = -1; return false;
						}
						$s = -1; return true;
					/* } */ case 10:
				case 6:
				$s = 5; continue;
			/* } else if (_1 === (3)) { */ case 3:
				_3 = p.tok.DataAtom;
				if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) {
					if (p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) {
						p.clearStackToContext(5);
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.im = inTableIM;
					}
					$s = -1; return true;
				} else if (_3 === (365829)) {
					if (p.popUntil(3, new sliceType$2([9989, 208901, 62725]))) {
						p.im = inTableIM;
						$s = -1; return false;
					}
					$s = -1; return true;
				} else if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (37378)) || (_3 === (87554)) || (_3 === (52226))) {
					$s = -1; return true;
				}
				$s = 5; continue;
			/* } else if (_1 === (5)) { */ case 4:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } */ case 5:
		case 1:
		_r = inTableIM(p); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inTableBodyIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inRowIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (2)) { $s = 2; continue; }
			/* */ if (_1 === (3)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === (2)) { */ case 2:
				_2 = p.tok.DataAtom;
				if ((_2 === (37378)) || (_2 === (87554))) {
					p.clearStackToContext(4);
					p.addElement();
					p.afe = $append(p.afe, scopeMarker);
					p.im = inCellIM;
					$s = -1; return true;
				} else if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) {
					if (p.popUntil(3, new sliceType$2([52226]))) {
						p.im = inTableBodyIM;
						$s = -1; return false;
					}
					$s = -1; return true;
				}
				$s = 4; continue;
			/* } else if (_1 === (3)) { */ case 3:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (52226)) { $s = 6; continue; }
					/* */ if (_3 === (365829)) { $s = 7; continue; }
					/* */ if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { $s = 8; continue; }
					/* */ if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (37378)) || (_3 === (87554))) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (_3 === (52226)) { */ case 6:
						if (p.popUntil(3, new sliceType$2([52226]))) {
							p.im = inTableBodyIM;
							$s = -1; return true;
						}
						$s = -1; return true;
					/* } else if (_3 === (365829)) { */ case 7:
						if (p.popUntil(3, new sliceType$2([52226]))) {
							p.im = inTableBodyIM;
							$s = -1; return false;
						}
						$s = -1; return true;
					/* } else if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { */ case 8:
						/* */ if (p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) { $s = 11; continue; }
						/* */ $s = 12; continue;
						/* if (p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) { */ case 11:
							$r = p.parseImpliedToken(3, 52226, new atom.Atom(52226).String()); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return false;
						/* } */ case 12:
						$s = -1; return true;
					/* } else if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (37378)) || (_3 === (87554))) { */ case 9:
						$s = -1; return true;
					/* } */ case 10:
				case 5:
			/* } */ case 4:
		case 1:
		_r = inTableIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inRowIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inCellIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_1 = p.tok.Type;
		if (_1 === (2)) {
			_2 = p.tok.DataAtom;
			if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (37378)) || (_2 === (62725)) || (_2 === (87554)) || (_2 === (208901)) || (_2 === (52226))) {
				if (p.popUntil(3, new sliceType$2([37378, 87554]))) {
					p.clearActiveFormattingElements();
					p.im = inRowIM;
					$s = -1; return false;
				}
				$s = -1; return true;
			} else if (_2 === (408582)) {
				p.reconstructActiveFormattingElements();
				p.addElement();
				p.framesetOK = false;
				p.im = inSelectInTableIM;
				$s = -1; return true;
			}
		} else if (_1 === (3)) {
			_3 = p.tok.DataAtom;
			if ((_3 === (37378)) || (_3 === (87554))) {
				if (!p.popUntil(3, new sliceType$2([p.tok.DataAtom]))) {
					$s = -1; return true;
				}
				p.clearActiveFormattingElements();
				p.im = inRowIM;
				$s = -1; return true;
			} else if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020))) {
				$s = -1; return true;
			} else if ((_3 === (365829)) || (_3 === (9989)) || (_3 === (62725)) || (_3 === (208901)) || (_3 === (52226))) {
				if (!p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) {
					$s = -1; return true;
				}
				if (p.popUntil(3, new sliceType$2([37378, 87554]))) {
					p.clearActiveFormattingElements();
				}
				p.im = inRowIM;
				$s = -1; return false;
			}
		}
		_r = inBodyIM(p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inCellIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inSelectIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, i, p, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; i = $f.i; p = $f.p; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ if (_1 === (0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (1)) { */ case 2:
				p.addText(strings.Replace(p.tok.Data, "\x00", "", -1));
				$s = 8; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 10; continue; }
					/* */ if (_2 === (451334)) { $s = 11; continue; }
					/* */ if (_2 === (24328)) { $s = 12; continue; }
					/* */ if (_2 === (408582)) { $s = 13; continue; }
					/* */ if ((_2 === (281349)) || (_2 === (12806)) || (_2 === (217608))) { $s = 14; continue; }
					/* */ if ((_2 === (137222)) || (_2 === (463880))) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if (_2 === (22020)) { */ case 10:
						_r = inBodyIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						$s = -1; return _r;
					/* } else if (_2 === (451334)) { */ case 11:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.addElement();
						$s = 16; continue;
					/* } else if (_2 === (24328)) { */ case 12:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						if (p.top().DataAtom === 24328) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.addElement();
						$s = 16; continue;
					/* } else if (_2 === (408582)) { */ case 13:
						if (p.popUntil(6, new sliceType$2([408582]))) {
							p.resetInsertionMode();
						} else {
							$s = -1; return true;
						}
						$s = 16; continue;
					/* } else if ((_2 === (281349)) || (_2 === (12806)) || (_2 === (217608))) { */ case 14:
						/* */ if (p.elementInScope(6, new sliceType$2([408582]))) { $s = 18; continue; }
						/* */ $s = 19; continue;
						/* if (p.elementInScope(6, new sliceType$2([408582]))) { */ case 18:
							$r = p.parseImpliedToken(3, 408582, new atom.Atom(408582).String()); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return false;
						/* } */ case 19:
						p.tokenizer.NextIsNotRawText();
						$s = -1; return true;
					/* } else if ((_2 === (137222)) || (_2 === (463880))) { */ case 15:
						_r$1 = inHeadIM(p); /* */ $s = 21; case 21: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } */ case 16:
				case 9:
				$s = 8; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (451334)) { $s = 23; continue; }
					/* */ if (_3 === (24328)) { $s = 24; continue; }
					/* */ if (_3 === (408582)) { $s = 25; continue; }
					/* */ if (_3 === (463880)) { $s = 26; continue; }
					/* */ $s = 27; continue;
					/* if (_3 === (451334)) { */ case 23:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						$s = 27; continue;
					/* } else if (_3 === (24328)) { */ case 24:
						i = p.oe.$length - 1 >> 0;
						if ((x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom === 451334) {
							i = i - (1) >> 0;
						}
						if ((x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).DataAtom === 24328) {
							p.oe = $subslice(p.oe, 0, i);
						}
						$s = 27; continue;
					/* } else if (_3 === (408582)) { */ case 25:
						if (p.popUntil(6, new sliceType$2([408582]))) {
							p.resetInsertionMode();
						} else {
							$s = -1; return true;
						}
						$s = 27; continue;
					/* } else if (_3 === (463880)) { */ case 26:
						_r$2 = inHeadIM(p); /* */ $s = 28; case 28: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 27:
				case 22:
				$s = 8; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 8; continue;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } else if (_1 === (0)) { */ case 7:
				_r$3 = inBodyIM(p); /* */ $s = 29; case 29: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$s = -1; return _r$3;
			/* } */ case 8:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inSelectIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.i = i; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	inSelectInTableIM = function(p) {
		var _1, _2, _r, i, n, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; i = $f.i; n = $f.n; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_1 = p.tok.Type;
		if ((_1 === (2)) || (_1 === (3))) {
			_2 = p.tok.DataAtom;
			if ((_2 === (143623)) || (_2 === (365829)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226)) || (_2 === (37378)) || (_2 === (87554))) {
				if ((p.tok.Type === 3) && !p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) {
					$s = -1; return true;
				}
				i = p.oe.$length - 1 >> 0;
				while (true) {
					if (!(i >= 0)) { break; }
					n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
					if (n.DataAtom === 408582) {
						p.oe = $subslice(p.oe, 0, i);
						break;
					}
					i = i - (1) >> 0;
				}
				p.resetInsertionMode();
				$s = -1; return false;
			}
		}
		_r = inSelectIM(p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inSelectInTableIM }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f.i = i; $f.n = n; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	inTemplateIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, i, n, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; i = $f.i; n = $f.n; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (0)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
				_r = inBodyIM(p); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { $s = 9; continue; }
					/* */ if ((_2 === (143623)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { $s = 10; continue; }
					/* */ if (_2 === (109315)) { $s = 11; continue; }
					/* */ if (_2 === (52226)) { $s = 12; continue; }
					/* */ if ((_2 === (37378)) || (_2 === (87554))) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { */ case 9:
						_r$1 = inHeadIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if ((_2 === (143623)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { */ case 10:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inTableIM);
						p.im = inTableIM;
						$s = -1; return false;
					/* } else if (_2 === (109315)) { */ case 11:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inColumnGroupIM);
						p.im = inColumnGroupIM;
						$s = -1; return false;
					/* } else if (_2 === (52226)) { */ case 12:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inTableBodyIM);
						p.im = inTableBodyIM;
						$s = -1; return false;
					/* } else if ((_2 === (37378)) || (_2 === (87554))) { */ case 13:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inRowIM);
						p.im = inRowIM;
						$s = -1; return false;
					/* } else { */ case 14:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inBodyIM);
						p.im = inBodyIM;
						$s = -1; return false;
					/* } */ case 15:
				case 8:
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (463880)) { $s = 18; continue; }
					/* */ $s = 19; continue;
					/* if (_3 === (463880)) { */ case 18:
						_r$2 = inHeadIM(p); /* */ $s = 21; case 21: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } else { */ case 19:
						$s = -1; return true;
					/* } */ case 20:
				case 17:
				$s = 6; continue;
			/* } else if (_1 === (0)) { */ case 5:
				if (!(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
					$s = -1; return true;
				}
				p.generateImpliedEndTags(new sliceType([]));
				i = p.oe.$length - 1 >> 0;
				while (true) {
					if (!(i >= 0)) { break; }
					n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
					if (n.Namespace === "" && (n.DataAtom === 463880)) {
						p.oe = $subslice(p.oe, 0, i);
						break;
					}
					i = i - (1) >> 0;
				}
				p.clearActiveFormattingElements();
				(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
				p.resetInsertionMode();
				$s = -1; return false;
			/* } */ case 6:
		case 1:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inTemplateIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.i = i; $f.n = n; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterBodyIM = function(p) {
		var _1, _r, _r$1, _r$2, p, s, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; p = $f.p; s = $f.s; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (5)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return true;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				/* */ if (s.length === 0) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if (s.length === 0) { */ case 9:
					_r$1 = inBodyIM(p); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					$s = -1; return _r$1;
				/* } */ case 10:
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 4:
				/* */ if (p.tok.DataAtom === 22020) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (p.tok.DataAtom === 22020) { */ case 12:
					_r$2 = inBodyIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					$s = -1; return _r$2;
				/* } */ case 13:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 5:
				if (p.tok.DataAtom === 22020) {
					if (!p.fragment) {
						p.im = afterAfterBodyIM;
					}
					$s = -1; return true;
				}
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 6:
				if (p.oe.$length < 1 || !(((x = p.oe, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])).DataAtom === 22020))) {
					$panic(new $String("html: bad parser state: <html> element not found, in the after-body insertion mode"));
				}
				(x$1 = p.oe, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])).AppendChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		p.im = inBodyIM;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterBodyIM }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.p = p; $f.s = s; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	inFramesetIM = function(p) {
		var _1, _3, _4, _r, _r$1, _r$2, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (5)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (5)) { */ case 2:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.Map((function(c) {
					var _2, c;
					_2 = c;
					if ((_2 === (32)) || (_2 === (9)) || (_2 === (10)) || (_2 === (12)) || (_2 === (13))) {
						return c;
					}
					return -1;
				}), p.tok.Data); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (!(s === "")) {
					p.addText(s);
				}
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 9; continue; }
					/* */ if (_3 === (35592)) { $s = 10; continue; }
					/* */ if (_3 === (35589)) { $s = 11; continue; }
					/* */ if (_3 === (35080)) { $s = 12; continue; }
					/* */ $s = 13; continue;
					/* if (_3 === (22020)) { */ case 9:
						_r$1 = inBodyIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (35592)) { */ case 10:
						p.addElement();
						$s = 13; continue;
					/* } else if (_3 === (35589)) { */ case 11:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = 13; continue;
					/* } else if (_3 === (35080)) { */ case 12:
						_r$2 = inHeadIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 13:
				case 8:
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 5:
				_4 = p.tok.DataAtom;
				if (_4 === (35592)) {
					if (!(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 22020))) {
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						if (!(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 35592))) {
							p.im = afterFramesetIM;
							$s = -1; return true;
						}
					}
				}
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inFramesetIM }; } $f._1 = _1; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterFramesetIM = function(p) {
		var _1, _3, _4, _r, _r$1, _r$2, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (5)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (5)) { */ case 2:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.Map((function(c) {
					var _2, c;
					_2 = c;
					if ((_2 === (32)) || (_2 === (9)) || (_2 === (10)) || (_2 === (12)) || (_2 === (13))) {
						return c;
					}
					return -1;
				}), p.tok.Data); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (!(s === "")) {
					p.addText(s);
				}
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 9; continue; }
					/* */ if (_3 === (35080)) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if (_3 === (22020)) { */ case 9:
						_r$1 = inBodyIM(p); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (35080)) { */ case 10:
						_r$2 = inHeadIM(p); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 11:
				case 8:
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 5:
				_4 = p.tok.DataAtom;
				if (_4 === (22020)) {
					p.im = afterAfterFramesetIM;
					$s = -1; return true;
				}
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterFramesetIM }; } $f._1 = _1; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterAfterBodyIM = function(p) {
		var _1, _r, _r$1, _r$2, _r$3, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return true;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				/* */ if (s.length === 0) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if (s.length === 0) { */ case 9:
					_r$1 = inBodyIM(p); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					$s = -1; return _r$1;
				/* } */ case 10:
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 4:
				/* */ if (p.tok.DataAtom === 22020) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (p.tok.DataAtom === 22020) { */ case 12:
					_r$2 = inBodyIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					$s = -1; return _r$2;
				/* } */ case 13:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.doc.AppendChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				_r$3 = inBodyIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$s = -1; return _r$3;
			/* } */ case 7:
		case 1:
		p.im = inBodyIM;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterAfterBodyIM }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterAfterFramesetIM = function(p) {
		var _1, _3, _r, _r$1, _r$2, _r$3, _r$4, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (5)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (6)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (5)) { */ case 2:
				p.doc.AppendChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.Map((function(c) {
					var _2, c;
					_2 = c;
					if ((_2 === (32)) || (_2 === (9)) || (_2 === (10)) || (_2 === (12)) || (_2 === (13))) {
						return c;
					}
					return -1;
				}), p.tok.Data); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				/* */ if (!(s === "")) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (!(s === "")) { */ case 8:
					p.tok.Data = s;
					_r$1 = inBodyIM(p); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					$s = -1; return _r$1;
				/* } */ case 9:
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 12; continue; }
					/* */ if (_3 === (35080)) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if (_3 === (22020)) { */ case 12:
						_r$2 = inBodyIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } else if (_3 === (35080)) { */ case 13:
						_r$3 = inHeadIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } */ case 14:
				case 11:
				$s = 6; continue;
			/* } else if (_1 === (6)) { */ case 5:
				_r$4 = inBodyIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterAfterFramesetIM }; } $f._1 = _1; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	parseForeignContent = function(p) {
		var _1, _2, _3, _entry, _entry$1, _i, _r, _r$1, _r$2, _ref, _v, attr, b, i, i$1, n, namespace, p, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _entry = $f._entry; _entry$1 = $f._entry$1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _v = $f._v; attr = $f.attr; b = $f.b; i = $f.i; i$1 = $f.i$1; n = $f.n; namespace = $f.namespace; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (5)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (1)) { */ case 2:
				/* */ if (p.framesetOK) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (p.framesetOK) { */ case 7:
					_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f\x00"); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					p.framesetOK = _r === "";
				/* } */ case 8:
				p.tok.Data = strings.Replace(p.tok.Data, "\x00", "\xEF\xBF\xBD", -1);
				p.addText(p.tok.Data);
				$s = 6; continue;
			/* } else if (_1 === (5)) { */ case 3:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
				b = (_entry = breakout[$String.keyFor(p.tok.Data)], _entry !== undefined ? _entry.v : false);
				if (p.tok.DataAtom === 16132) {
					_ref = p.tok.Attr;
					_i = 0;
					loop:
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
						_2 = attr.Key;
						if (_2 === ("color") || _2 === ("face") || _2 === ("size")) {
							b = true;
							break loop;
						}
						_i++;
					}
				}
				/* */ if (b) { $s = 10; continue; }
				/* */ $s = 11; continue;
				/* if (b) { */ case 10:
					i = p.oe.$length - 1 >> 0;
					/* while (true) { */ case 12:
						/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 13; continue; }
						n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
						if (n.Namespace === "") { _v = true; $s = 16; continue s; }
						_r$1 = htmlIntegrationPoint(n); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						_v = _r$1; case 16:
						/* */ if (_v || mathMLTextIntegrationPoint(n)) { $s = 14; continue; }
						/* */ $s = 15; continue;
						/* if (_v || mathMLTextIntegrationPoint(n)) { */ case 14:
							p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
							/* break; */ $s = 13; continue;
						/* } */ case 15:
						i = i - (1) >> 0;
					/* } */ $s = 12; continue; case 13:
					$s = -1; return false;
				/* } */ case 11:
				_3 = p.top().Namespace;
				if (_3 === ("math")) {
					adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments);
				} else if (_3 === ("svg")) {
					x$1 = (_entry$1 = svgTagNameAdjustments[$String.keyFor(p.tok.Data)], _entry$1 !== undefined ? _entry$1.v : "");
					if (!(x$1 === "")) {
						p.tok.DataAtom = atom.Lookup((new sliceType$3($stringToBytes(x$1))));
						p.tok.Data = x$1;
					}
					adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments);
				} else {
					$panic(new $String("html: bad parser state: unexpected namespace"));
				}
				adjustForeignAttributes(p.tok.Attr);
				namespace = p.top().Namespace;
				p.addElement();
				p.top().Namespace = namespace;
				if (!(namespace === "")) {
					p.tokenizer.NextIsNotRawText();
				}
				if (p.hasSelfClosingToken) {
					(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
					p.acknowledgeSelfClosingTag();
				}
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 5:
				i$1 = p.oe.$length - 1 >> 0;
				/* while (true) { */ case 18:
					/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 19; continue; }
					/* */ if ((x$2 = p.oe, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1])).Namespace === "") { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if ((x$2 = p.oe, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1])).Namespace === "") { */ case 20:
						_r$2 = p.im(p); /* */ $s = 22; case 22: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 21:
					if (strings.EqualFold((x$3 = p.oe, ((i$1 < 0 || i$1 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i$1])).Data, p.tok.Data)) {
						p.oe = $subslice(p.oe, 0, i$1);
						/* break; */ $s = 19; continue;
					}
					i$1 = i$1 - (1) >> 0;
				/* } */ $s = 18; continue; case 19:
				$s = -1; return true;
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parseForeignContent }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._entry = _entry; $f._entry$1 = _entry$1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._v = _v; $f.attr = attr; $f.b = b; $f.i = i; $f.i$1 = i$1; $f.n = n; $f.namespace = namespace; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.ptr.prototype.inForeignContent = function() {
		var _r, n, p, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; p = $f.p; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (p.oe.$length === 0) {
			$s = -1; return false;
		}
		n = (x = p.oe, x$1 = p.oe.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (n.Namespace === "") {
			$s = -1; return false;
		}
		if (mathMLTextIntegrationPoint(n)) {
			if ((p.tok.Type === 2) && !((p.tok.DataAtom === 198662)) && !((p.tok.DataAtom === 45066))) {
				$s = -1; return false;
			}
			if (p.tok.Type === 1) {
				$s = -1; return false;
			}
		}
		if (n.Namespace === "math" && (n.DataAtom === 117006) && (p.tok.Type === 2) && (p.tok.DataAtom === 462339)) {
			$s = -1; return false;
		}
		_r = htmlIntegrationPoint(n); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r && ((p.tok.Type === 2) || (p.tok.Type === 1))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r && ((p.tok.Type === 2) || (p.tok.Type === 1))) { */ case 1:
			$s = -1; return false;
		/* } */ case 2:
		if (p.tok.Type === 0) {
			$s = -1; return false;
		}
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.inForeignContent }; } $f._r = _r; $f.n = n; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.inForeignContent = function() { return this.$val.inForeignContent(); };
	parser.ptr.prototype.parseImpliedToken = function(t, dataAtom, data) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, data, dataAtom, p, realToken, selfClosing, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; data = $f.data; dataAtom = $f.dataAtom; p = $f.p; realToken = $f.realToken; selfClosing = $f.selfClosing; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_tmp = $clone(p.tok, Token);
		_tmp$1 = p.hasSelfClosingToken;
		realToken = $clone(_tmp, Token);
		selfClosing = _tmp$1;
		Token.copy(p.tok, new Token.ptr(t, dataAtom, data, sliceType$1.nil));
		p.hasSelfClosingToken = false;
		$r = p.parseCurrentToken(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tmp$2 = $clone(realToken, Token);
		_tmp$3 = selfClosing;
		Token.copy(p.tok, _tmp$2);
		p.hasSelfClosingToken = _tmp$3;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseImpliedToken }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.data = data; $f.dataAtom = dataAtom; $f.p = p; $f.realToken = realToken; $f.selfClosing = selfClosing; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseImpliedToken = function(t, dataAtom, data) { return this.$val.parseImpliedToken(t, dataAtom, data); };
	parser.ptr.prototype.parseCurrentToken = function() {
		var _r, _r$1, _r$2, consumed, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; consumed = $f.consumed; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (p.tok.Type === 4) {
			p.hasSelfClosingToken = true;
			p.tok.Type = 2;
		}
		consumed = false;
		/* while (true) { */ case 1:
			/* if (!(!consumed)) { break; } */ if(!(!consumed)) { $s = 2; continue; }
			_r = p.inForeignContent(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r) { */ case 3:
				_r$1 = parseForeignContent(p); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				consumed = _r$1;
				$s = 5; continue;
			/* } else { */ case 4:
				_r$2 = p.im(p); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				consumed = _r$2;
			/* } */ case 5:
		/* } */ $s = 1; continue; case 2:
		if (p.hasSelfClosingToken) {
			p.hasSelfClosingToken = false;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseCurrentToken }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.consumed = consumed; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseCurrentToken = function() { return this.$val.parseCurrentToken(); };
	parser.ptr.prototype.parse = function() {
		var _r, err, n, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; n = $f.n; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		err = $ifaceNil;
		/* while (true) { */ case 1:
			/* if (!(!($interfaceIsEqual(err, io.EOF)))) { break; } */ if(!(!($interfaceIsEqual(err, io.EOF)))) { $s = 2; continue; }
			n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
			p.tokenizer.AllowCDATA(!(n === ptrType.nil) && !(n.Namespace === ""));
			_r = p.tokenizer.Next(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
			Token.copy(p.tok, p.tokenizer.Token());
			if (p.tok.Type === 0) {
				err = p.tokenizer.Err();
				if (!($interfaceIsEqual(err, $ifaceNil)) && !($interfaceIsEqual(err, io.EOF))) {
					$s = -1; return err;
				}
			}
			$r = p.parseCurrentToken(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parse }; } $f._r = _r; $f.err = err; $f.n = n; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parse = function() { return this.$val.parse(); };
	ParseFragment = function(r, context) {
		var _r, context, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; context = $f.context; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = ParseFragmentWithOptions(r, context, new sliceType$5([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ParseFragment }; } $f._r = _r; $f.context = context; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ParseFragment = ParseFragment;
	ParseFragmentWithOptions = function(r, context, opts) {
		var _i, _r, _r$1, _ref, c, context, contextTag, err, f, n, next, opts, p, parent, r, result, root, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; c = $f.c; context = $f.context; contextTag = $f.contextTag; err = $f.err; f = $f.f; n = $f.n; next = $f.next; opts = $f.opts; p = $f.p; parent = $f.parent; r = $f.r; result = $f.result; root = $f.root; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		contextTag = "";
		if (!(context === ptrType.nil)) {
			if (!((context.Type === 3))) {
				$s = -1; return [sliceType$6.nil, errors.New("html: ParseFragment of non-element Node")];
			}
			if (!((context.DataAtom === atom.Lookup((new sliceType$3($stringToBytes(context.Data))))))) {
				$s = -1; return [sliceType$6.nil, errors.New("html: inconsistent Node: DataAtom=" + strconv.Itoa(((context.DataAtom >> 0))) + ", Data=" + context.Data)];
			}
			contextTag = new atom.Atom(context.DataAtom).String();
		}
		_r = NewTokenizerFragment(r, contextTag); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = new parser.ptr(_r, new Token.ptr(0, 0, "", sliceType$1.nil), false, new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 2, 0, "", "", sliceType$1.nil), nodeStack.nil, nodeStack.nil, ptrType.nil, ptrType.nil, true, false, insertionModeStack.nil, $throwNilPointerError, $throwNilPointerError, false, false, true, context);
		_ref = opts;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			$r = f(p); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 2; continue; case 3:
		root = new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, 22020, new atom.Atom(22020).String(), "", sliceType$1.nil);
		p.doc.AppendChild(root);
		p.oe = new nodeStack([root]);
		if (!(context === ptrType.nil) && (context.DataAtom === 463880)) {
			p.templateStack = $append(p.templateStack, inTemplateIM);
		}
		p.resetInsertionMode();
		n = context;
		while (true) {
			if (!(!(n === ptrType.nil))) { break; }
			if ((n.Type === 3) && (n.DataAtom === 159236)) {
				p.form = n;
				break;
			}
			n = n.Parent;
		}
		_r$1 = p.parse(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [sliceType$6.nil, err];
		}
		parent = p.doc;
		if (!(context === ptrType.nil)) {
			parent = root;
		}
		result = sliceType$6.nil;
		c = parent.FirstChild;
		while (true) {
			if (!(!(c === ptrType.nil))) { break; }
			next = c.NextSibling;
			parent.RemoveChild(c);
			result = $append(result, c);
			c = next;
		}
		$s = -1; return [result, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: ParseFragmentWithOptions }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f.c = c; $f.context = context; $f.contextTag = contextTag; $f.err = err; $f.f = f; $f.n = n; $f.next = next; $f.opts = opts; $f.p = p; $f.parent = parent; $f.r = r; $f.result = result; $f.root = root; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ParseFragmentWithOptions = ParseFragmentWithOptions;
	TokenType.prototype.String = function() {
		var _1, t;
		t = this.$val;
		_1 = t;
		if (_1 === (0)) {
			return "Error";
		} else if (_1 === (1)) {
			return "Text";
		} else if (_1 === (2)) {
			return "StartTag";
		} else if (_1 === (3)) {
			return "EndTag";
		} else if (_1 === (4)) {
			return "SelfClosingTag";
		} else if (_1 === (5)) {
			return "Comment";
		} else if (_1 === (6)) {
			return "Doctype";
		}
		return "Invalid(" + strconv.Itoa(((t >> 0))) + ")";
	};
	$ptrType(TokenType).prototype.String = function() { return new TokenType(this.$get()).String(); };
	Token.ptr.prototype.tagString = function() {
		var _i, _r, _ref, a, buf, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; buf = $f.buf; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (t.Attr.$length === 0) {
			$s = -1; return t.Data;
		}
		buf = bytes.NewBufferString(t.Data);
		_ref = t.Attr;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
			buf.WriteByte(32);
			buf.WriteString(a.Key);
			buf.WriteString("=\"");
			_r = escape(buf, a.Val); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
			buf.WriteByte(34);
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return buf.String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Token.ptr.prototype.tagString }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.buf = buf; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Token.prototype.tagString = function() { return this.$val.tagString(); };
	Token.ptr.prototype.String = function() {
		var _1, _r, _r$1, _r$2, _r$3, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
			_1 = t.Type;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (4)) { $s = 6; continue; }
			/* */ if (_1 === (5)) { $s = 7; continue; }
			/* */ if (_1 === (6)) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return "";
			/* } else if (_1 === (1)) { */ case 3:
				_r = EscapeString(t.Data); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (2)) { */ case 4:
				_r$1 = $clone(t, Token).tagString(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return "<" + _r$1 + ">";
			/* } else if (_1 === (3)) { */ case 5:
				_r$2 = $clone(t, Token).tagString(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$s = -1; return "</" + _r$2 + ">";
			/* } else if (_1 === (4)) { */ case 6:
				_r$3 = $clone(t, Token).tagString(); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$s = -1; return "<" + _r$3 + "/>";
			/* } else if (_1 === (5)) { */ case 7:
				$s = -1; return "<!--" + t.Data + "-->";
			/* } else if (_1 === (6)) { */ case 8:
				$s = -1; return "<!DOCTYPE " + t.Data + ">";
			/* } */ case 9:
		case 1:
		$s = -1; return "Invalid(" + strconv.Itoa(((t.Type >> 0))) + ")";
		/* */ } return; } if ($f === undefined) { $f = { $blk: Token.ptr.prototype.String }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Token.prototype.String = function() { return this.$val.String(); };
	Tokenizer.ptr.prototype.AllowCDATA = function(allowCDATA) {
		var allowCDATA, z;
		z = this;
		z.allowCDATA = allowCDATA;
	};
	Tokenizer.prototype.AllowCDATA = function(allowCDATA) { return this.$val.AllowCDATA(allowCDATA); };
	Tokenizer.ptr.prototype.NextIsNotRawText = function() {
		var z;
		z = this;
		z.rawTag = "";
	};
	Tokenizer.prototype.NextIsNotRawText = function() { return this.$val.NextIsNotRawText(); };
	Tokenizer.ptr.prototype.Err = function() {
		var z;
		z = this;
		if (!((z.tt === 0))) {
			return $ifaceNil;
		}
		return z.err;
	};
	Tokenizer.prototype.Err = function() { return this.$val.Err(); };
	Tokenizer.ptr.prototype.readByte = function() {
		var _i, _r, _ref, _tmp, _tmp$1, _tmp$2, _tuple, buf1, c, d, i, n, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; buf1 = $f.buf1; c = $f.c; d = $f.d; i = $f.i; n = $f.n; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		/* */ if (z.raw.end >= z.buf.$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (z.raw.end >= z.buf.$length) { */ case 1:
			if (!($interfaceIsEqual(z.readErr, $ifaceNil))) {
				z.err = z.readErr;
				$s = -1; return 0;
			}
			c = z.buf.$capacity;
			d = z.raw.end - z.raw.start >> 0;
			buf1 = sliceType$3.nil;
			if (($imul(2, d)) > c) {
				buf1 = $makeSlice(sliceType$3, d, ($imul(2, c)));
			} else {
				buf1 = $subslice(z.buf, 0, d);
			}
			$copySlice(buf1, $subslice(z.buf, z.raw.start, z.raw.end));
			x = z.raw.start;
			if (!((x === 0))) {
				z.data.start = z.data.start - (x) >> 0;
				z.data.end = z.data.end - (x) >> 0;
				z.pendingAttr[0].start = z.pendingAttr[0].start - (x) >> 0;
				z.pendingAttr[0].end = z.pendingAttr[0].end - (x) >> 0;
				z.pendingAttr[1].start = z.pendingAttr[1].start - (x) >> 0;
				z.pendingAttr[1].end = z.pendingAttr[1].end - (x) >> 0;
				_ref = z.attr;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i = _i;
					(x$2 = z.attr, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]))[0].start = (x$1 = z.attr, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]))[0].start - (x) >> 0;
					(x$4 = z.attr, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i]))[0].end = (x$3 = z.attr, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i]))[0].end - (x) >> 0;
					(x$6 = z.attr, ((i < 0 || i >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i]))[1].start = (x$5 = z.attr, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i]))[1].start - (x) >> 0;
					(x$8 = z.attr, ((i < 0 || i >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + i]))[1].end = (x$7 = z.attr, ((i < 0 || i >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + i]))[1].end - (x) >> 0;
					_i++;
				}
			}
			_tmp = 0;
			_tmp$1 = d;
			_tmp$2 = $subslice(buf1, 0, d);
			z.raw.start = _tmp;
			z.raw.end = _tmp$1;
			z.buf = _tmp$2;
			n = 0;
			_r = readAtLeastOneByte(z.r, $subslice(buf1, d, buf1.$capacity)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			n = _tuple[0];
			z.readErr = _tuple[1];
			if (n === 0) {
				z.err = z.readErr;
				$s = -1; return 0;
			}
			z.buf = $subslice(buf1, 0, (d + n >> 0));
		/* } */ case 2:
		x$11 = (x$9 = z.buf, x$10 = z.raw.end, ((x$10 < 0 || x$10 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + x$10]));
		z.raw.end = z.raw.end + (1) >> 0;
		if (z.maxBuf > 0 && (z.raw.end - z.raw.start >> 0) >= z.maxBuf) {
			z.err = $pkg.ErrBufferExceeded;
			$s = -1; return 0;
		}
		$s = -1; return x$11;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readByte }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f.buf1 = buf1; $f.c = c; $f.d = d; $f.i = i; $f.n = n; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readByte = function() { return this.$val.readByte(); };
	Tokenizer.ptr.prototype.Buffered = function() {
		var z;
		z = this;
		return $subslice(z.buf, z.raw.end);
	};
	Tokenizer.prototype.Buffered = function() { return this.$val.Buffered(); };
	readAtLeastOneByte = function(r, b) {
		var _r, _tuple, b, err, i, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; i = $f.i; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 100)) { break; } */ if(!(i < 100)) { $s = 2; continue; }
			_r = r.Read(b); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			n = _tuple[0];
			err = _tuple[1];
			if (!((n === 0)) || !($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [n, err];
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [0, io.ErrNoProgress];
		/* */ } return; } if ($f === undefined) { $f = { $blk: readAtLeastOneByte }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.i = i; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.ptr.prototype.skipWhiteSpace = function() {
		var _1, _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				$s = -1; return;
			}
			_1 = c;
			if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12))) {
			} else {
				z.raw.end = z.raw.end - (1) >> 0;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.skipWhiteSpace }; } $f._1 = _1; $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.skipWhiteSpace = function() { return this.$val.skipWhiteSpace(); };
	Tokenizer.ptr.prototype.readRawOrRCDATA = function() {
		var _r, _r$1, _r$2, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		/* */ if (z.rawTag === "script") { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (z.rawTag === "script") { */ case 1:
			$r = z.readScript(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			z.textIsRaw = true;
			z.rawTag = "";
			$s = -1; return;
		/* } */ case 2:
		/* while (true) { */ case 4:
			_r = z.readByte(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 5; continue s;
			}
			/* */ if (!((c === 60))) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!((c === 60))) { */ case 7:
				/* continue loop; */ $s = 4; continue s;
			/* } */ case 8:
			_r$1 = z.readByte(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c = _r$1;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 5; continue s;
			}
			/* */ if (!((c === 47))) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (!((c === 47))) { */ case 10:
				/* continue loop; */ $s = 4; continue s;
			/* } */ case 11:
			_r$2 = z.readRawEndTag(); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			/* */ if (_r$2 || !($interfaceIsEqual(z.err, $ifaceNil))) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (_r$2 || !($interfaceIsEqual(z.err, $ifaceNil))) { */ case 12:
				/* break loop; */ $s = 5; continue s;
			/* } */ case 13:
		/* } */ $s = 4; continue; case 5:
		z.data.end = z.raw.end;
		z.textIsRaw = !(z.rawTag === "textarea") && !(z.rawTag === "title");
		z.rawTag = "";
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readRawOrRCDATA }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readRawOrRCDATA = function() { return this.$val.readRawOrRCDATA(); };
	Tokenizer.ptr.prototype.readRawEndTag = function() {
		var _1, _r, _r$1, c, c$1, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; c = $f.c; c$1 = $f.c$1; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < z.rawTag.length)) { break; } */ if(!(i < z.rawTag.length)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				$s = -1; return false;
			}
			if (!((c === z.rawTag.charCodeAt(i))) && !((c === (z.rawTag.charCodeAt(i) - 32 << 24 >>> 24)))) {
				z.raw.end = z.raw.end - (1) >> 0;
				$s = -1; return false;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		_r$1 = z.readByte(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		c$1 = _r$1;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return false;
		}
		_1 = c$1;
		if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12)) || (_1 === (47)) || (_1 === (62))) {
			z.raw.end = z.raw.end - ((3 + z.rawTag.length >> 0)) >> 0;
			$s = -1; return true;
		}
		z.raw.end = z.raw.end - (1) >> 0;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readRawEndTag }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readRawEndTag = function() { return this.$val.readRawEndTag(); };
	Tokenizer.ptr.prototype.readScript = function() {
		var _1, _2, _3, _4, _5, _6, _7, _8, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, c, i, z, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _7 = $f._7; _8 = $f._8; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; c = $f.c; i = $f.i; z = $f.z; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		z = [z];
		z[0] = this;
		$deferred.push([(function(z) { return function() {
			z[0].data.end = z[0].raw.end;
		}; })(z), []]);
		c = 0;
		/* scriptData: */ case 1:
		_r = z[0].readByte(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		c = _r;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 60) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (c === 60) { */ case 3:
			/* goto scriptDataLessThanSign */ $s = 5; continue;
		/* } */ case 4:
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataLessThanSign: */ case 5:
		_r$1 = z[0].readByte(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		c = _r$1;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_1 = c;
			/* */ if (_1 === (47)) { $s = 8; continue; }
			/* */ if (_1 === (33)) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_1 === (47)) { */ case 8:
				/* goto scriptDataEndTagOpen */ $s = 11; continue;
				$s = 10; continue;
			/* } else if (_1 === (33)) { */ case 9:
				/* goto scriptDataEscapeStart */ $s = 12; continue;
			/* } */ case 10:
		case 7:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEndTagOpen: */ case 11:
		_r$2 = z[0].readRawEndTag(); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		/* */ if (_r$2 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { $s = 13; continue; }
		/* */ $s = 14; continue;
		/* if (_r$2 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { */ case 13:
			$s = -1; return;
		/* } */ case 14:
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscapeStart: */ case 12:
		_r$3 = z[0].readByte(); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		c = _r$3;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 45) { $s = 17; continue; }
		/* */ $s = 18; continue;
		/* if (c === 45) { */ case 17:
			/* goto scriptDataEscapeStartDash */ $s = 19; continue;
		/* } */ case 18:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscapeStartDash: */ case 19:
		_r$4 = z[0].readByte(); /* */ $s = 20; case 20: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		c = _r$4;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 45) { $s = 21; continue; }
		/* */ $s = 22; continue;
		/* if (c === 45) { */ case 21:
			/* goto scriptDataEscapedDashDash */ $s = 23; continue;
		/* } */ case 22:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscaped: */ case 24:
		_r$5 = z[0].readByte(); /* */ $s = 25; case 25: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		c = _r$5;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_2 = c;
			/* */ if (_2 === (45)) { $s = 27; continue; }
			/* */ if (_2 === (60)) { $s = 28; continue; }
			/* */ $s = 29; continue;
			/* if (_2 === (45)) { */ case 27:
				/* goto scriptDataEscapedDash */ $s = 30; continue;
				$s = 29; continue;
			/* } else if (_2 === (60)) { */ case 28:
				/* goto scriptDataEscapedLessThanSign */ $s = 31; continue;
			/* } */ case 29:
		case 26:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataEscapedDash: */ case 30:
		_r$6 = z[0].readByte(); /* */ $s = 32; case 32: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		c = _r$6;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_3 = c;
			/* */ if (_3 === (45)) { $s = 34; continue; }
			/* */ if (_3 === (60)) { $s = 35; continue; }
			/* */ $s = 36; continue;
			/* if (_3 === (45)) { */ case 34:
				/* goto scriptDataEscapedDashDash */ $s = 23; continue;
				$s = 36; continue;
			/* } else if (_3 === (60)) { */ case 35:
				/* goto scriptDataEscapedLessThanSign */ $s = 31; continue;
			/* } */ case 36:
		case 33:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataEscapedDashDash: */ case 23:
		_r$7 = z[0].readByte(); /* */ $s = 37; case 37: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		c = _r$7;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_4 = c;
			/* */ if (_4 === (45)) { $s = 39; continue; }
			/* */ if (_4 === (60)) { $s = 40; continue; }
			/* */ if (_4 === (62)) { $s = 41; continue; }
			/* */ $s = 42; continue;
			/* if (_4 === (45)) { */ case 39:
				/* goto scriptDataEscapedDashDash */ $s = 23; continue;
				$s = 42; continue;
			/* } else if (_4 === (60)) { */ case 40:
				/* goto scriptDataEscapedLessThanSign */ $s = 31; continue;
				$s = 42; continue;
			/* } else if (_4 === (62)) { */ case 41:
				/* goto scriptData */ $s = 1; continue;
			/* } */ case 42:
		case 38:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataEscapedLessThanSign: */ case 31:
		_r$8 = z[0].readByte(); /* */ $s = 43; case 43: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		c = _r$8;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 47) { $s = 44; continue; }
		/* */ $s = 45; continue;
		/* if (c === 47) { */ case 44:
			/* goto scriptDataEscapedEndTagOpen */ $s = 46; continue;
		/* } */ case 45:
		/* */ if (97 <= c && c <= 122 || 65 <= c && c <= 90) { $s = 47; continue; }
		/* */ $s = 48; continue;
		/* if (97 <= c && c <= 122 || 65 <= c && c <= 90) { */ case 47:
			/* goto scriptDataDoubleEscapeStart */ $s = 49; continue;
		/* } */ case 48:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscapedEndTagOpen: */ case 46:
		_r$9 = z[0].readRawEndTag(); /* */ $s = 52; case 52: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		/* */ if (_r$9 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { $s = 50; continue; }
		/* */ $s = 51; continue;
		/* if (_r$9 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { */ case 50:
			$s = -1; return;
		/* } */ case 51:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataDoubleEscapeStart: */ case 49:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		i = 0;
		/* while (true) { */ case 53:
			/* if (!(i < 6)) { break; } */ if(!(i < 6)) { $s = 54; continue; }
			_r$10 = z[0].readByte(); /* */ $s = 55; case 55: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			c = _r$10;
			if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
				$s = -1; return;
			}
			/* */ if (!((c === "script".charCodeAt(i))) && !((c === "SCRIPT".charCodeAt(i)))) { $s = 56; continue; }
			/* */ $s = 57; continue;
			/* if (!((c === "script".charCodeAt(i))) && !((c === "SCRIPT".charCodeAt(i)))) { */ case 56:
				z[0].raw.end = z[0].raw.end - (1) >> 0;
				/* goto scriptDataEscaped */ $s = 24; continue;
			/* } */ case 57:
			i = i + (1) >> 0;
		/* } */ $s = 53; continue; case 54:
		_r$11 = z[0].readByte(); /* */ $s = 58; case 58: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		c = _r$11;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_5 = c;
			/* */ if ((_5 === (32)) || (_5 === (10)) || (_5 === (13)) || (_5 === (9)) || (_5 === (12)) || (_5 === (47)) || (_5 === (62))) { $s = 60; continue; }
			/* */ $s = 61; continue;
			/* if ((_5 === (32)) || (_5 === (10)) || (_5 === (13)) || (_5 === (9)) || (_5 === (12)) || (_5 === (47)) || (_5 === (62))) { */ case 60:
				/* goto scriptDataDoubleEscaped */ $s = 62; continue;
			/* } */ case 61:
		case 59:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataDoubleEscaped: */ case 62:
		_r$12 = z[0].readByte(); /* */ $s = 63; case 63: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
		c = _r$12;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_6 = c;
			/* */ if (_6 === (45)) { $s = 65; continue; }
			/* */ if (_6 === (60)) { $s = 66; continue; }
			/* */ $s = 67; continue;
			/* if (_6 === (45)) { */ case 65:
				/* goto scriptDataDoubleEscapedDash */ $s = 68; continue;
				$s = 67; continue;
			/* } else if (_6 === (60)) { */ case 66:
				/* goto scriptDataDoubleEscapedLessThanSign */ $s = 69; continue;
			/* } */ case 67:
		case 64:
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapedDash: */ case 68:
		_r$13 = z[0].readByte(); /* */ $s = 70; case 70: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
		c = _r$13;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_7 = c;
			/* */ if (_7 === (45)) { $s = 72; continue; }
			/* */ if (_7 === (60)) { $s = 73; continue; }
			/* */ $s = 74; continue;
			/* if (_7 === (45)) { */ case 72:
				/* goto scriptDataDoubleEscapedDashDash */ $s = 75; continue;
				$s = 74; continue;
			/* } else if (_7 === (60)) { */ case 73:
				/* goto scriptDataDoubleEscapedLessThanSign */ $s = 69; continue;
			/* } */ case 74:
		case 71:
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapedDashDash: */ case 75:
		_r$14 = z[0].readByte(); /* */ $s = 76; case 76: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
		c = _r$14;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_8 = c;
			/* */ if (_8 === (45)) { $s = 78; continue; }
			/* */ if (_8 === (60)) { $s = 79; continue; }
			/* */ if (_8 === (62)) { $s = 80; continue; }
			/* */ $s = 81; continue;
			/* if (_8 === (45)) { */ case 78:
				/* goto scriptDataDoubleEscapedDashDash */ $s = 75; continue;
				$s = 81; continue;
			/* } else if (_8 === (60)) { */ case 79:
				/* goto scriptDataDoubleEscapedLessThanSign */ $s = 69; continue;
				$s = 81; continue;
			/* } else if (_8 === (62)) { */ case 80:
				/* goto scriptData */ $s = 1; continue;
			/* } */ case 81:
		case 77:
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapedLessThanSign: */ case 69:
		_r$15 = z[0].readByte(); /* */ $s = 82; case 82: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
		c = _r$15;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 47) { $s = 83; continue; }
		/* */ $s = 84; continue;
		/* if (c === 47) { */ case 83:
			/* goto scriptDataDoubleEscapeEnd */ $s = 85; continue;
		/* } */ case 84:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapeEnd: */ case 85:
		_r$16 = z[0].readRawEndTag(); /* */ $s = 88; case 88: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
		/* */ if (_r$16) { $s = 86; continue; }
		/* */ $s = 87; continue;
		/* if (_r$16) { */ case 86:
			z[0].raw.end = z[0].raw.end + (9) >> 0;
			/* goto scriptDataEscaped */ $s = 24; continue;
		/* } */ case 87:
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readScript }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._7 = _7; $f._8 = _8; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.c = c; $f.i = i; $f.z = z; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Tokenizer.prototype.readScript = function() { return this.$val.readScript(); };
	Tokenizer.ptr.prototype.readComment = function() {
		var _1, _r, _r$1, c, dashCount, z, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; c = $f.c; dashCount = $f.dashCount; z = $f.z; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		z = [z];
		z[0] = this;
		z[0].data.start = z[0].raw.end;
		$deferred.push([(function(z) { return function() {
			if (z[0].data.end < z[0].data.start) {
				z[0].data.end = z[0].data.start;
			}
		}; })(z), []]);
		dashCount = 2;
		/* while (true) { */ case 1:
			_r = z[0].readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
				if (dashCount > 2) {
					dashCount = 2;
				}
				z[0].data.end = z[0].raw.end - dashCount >> 0;
				$s = -1; return;
			}
				_1 = c;
				/* */ if (_1 === (45)) { $s = 5; continue; }
				/* */ if (_1 === (62)) { $s = 6; continue; }
				/* */ if (_1 === (33)) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (_1 === (45)) { */ case 5:
					dashCount = dashCount + (1) >> 0;
					/* continue; */ $s = 1; continue;
					$s = 8; continue;
				/* } else if (_1 === (62)) { */ case 6:
					if (dashCount >= 2) {
						z[0].data.end = z[0].raw.end - 3 >> 0;
						$s = -1; return;
					}
					$s = 8; continue;
				/* } else if (_1 === (33)) { */ case 7:
					/* */ if (dashCount >= 2) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (dashCount >= 2) { */ case 9:
						_r$1 = z[0].readByte(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						c = _r$1;
						if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
							z[0].data.end = z[0].raw.end;
							$s = -1; return;
						}
						if (c === 62) {
							z[0].data.end = z[0].raw.end - 4 >> 0;
							$s = -1; return;
						}
					/* } */ case 10:
				/* } */ case 8:
			case 4:
			dashCount = 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readComment }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.c = c; $f.dashCount = dashCount; $f.z = z; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Tokenizer.prototype.readComment = function() { return this.$val.readComment(); };
	Tokenizer.ptr.prototype.readUntilCloseAngle = function() {
		var _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.data.start = z.raw.end;
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return;
			}
			if (c === 62) {
				z.data.end = z.raw.end - 1 >> 0;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readUntilCloseAngle }; } $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readUntilCloseAngle = function() { return this.$val.readUntilCloseAngle(); };
	Tokenizer.ptr.prototype.readMarkupDeclaration = function() {
		var _r, _r$1, _r$2, _v, c, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _v = $f._v; c = $f.c; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.data.start = z.raw.end;
		c = arrayType.zero();
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 2)) { break; } */ if(!(i < 2)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			((i < 0 || i >= c.length) ? ($throwRuntimeError("index out of range"), undefined) : c[i] = _r);
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return 5;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		/* */ if ((c[0] === 45) && (c[1] === 45)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if ((c[0] === 45) && (c[1] === 45)) { */ case 4:
			$r = z.readComment(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return 5;
		/* } */ case 5:
		z.raw.end = z.raw.end - (2) >> 0;
		_r$1 = z.readDoctype(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (_r$1) { */ case 7:
			$s = -1; return 6;
		/* } */ case 8:
		if (!(z.allowCDATA)) { _v = false; $s = 12; continue s; }
		_r$2 = z.readCDATA(); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_v = _r$2; case 12:
		/* */ if (_v) { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (_v) { */ case 10:
			z.convertNUL = true;
			$s = -1; return 1;
		/* } */ case 11:
		$r = z.readUntilCloseAngle(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return 5;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readMarkupDeclaration }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._v = _v; $f.c = c; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readMarkupDeclaration = function() { return this.$val.readMarkupDeclaration(); };
	Tokenizer.ptr.prototype.readDoctype = function() {
		var _r, c, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 7)) { break; } */ if(!(i < 7)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return false;
			}
			if (!((c === "DOCTYPE".charCodeAt(i))) && !((c === ("DOCTYPE".charCodeAt(i) + 32 << 24 >>> 24)))) {
				z.raw.end = z.data.start;
				$s = -1; return false;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$r = z.skipWhiteSpace(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			z.data.start = z.raw.end;
			z.data.end = z.raw.end;
			$s = -1; return true;
		}
		$r = z.readUntilCloseAngle(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readDoctype }; } $f._r = _r; $f.c = c; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readDoctype = function() { return this.$val.readDoctype(); };
	Tokenizer.ptr.prototype.readCDATA = function() {
		var _1, _r, _r$1, brackets, c, c$1, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; brackets = $f.brackets; c = $f.c; c$1 = $f.c$1; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 7)) { break; } */ if(!(i < 7)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return false;
			}
			if (!((c === "[CDATA[".charCodeAt(i)))) {
				z.raw.end = z.data.start;
				$s = -1; return false;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		z.data.start = z.raw.end;
		brackets = 0;
		/* while (true) { */ case 4:
			_r$1 = z.readByte(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c$1 = _r$1;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return true;
			}
			_1 = c$1;
			if (_1 === (93)) {
				brackets = brackets + (1) >> 0;
			} else if (_1 === (62)) {
				if (brackets >= 2) {
					z.data.end = z.raw.end - 3 >> 0;
					$s = -1; return true;
				}
				brackets = 0;
			} else {
				brackets = 0;
			}
		/* } */ $s = 4; continue; case 5:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readCDATA }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.brackets = brackets; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readCDATA = function() { return this.$val.readCDATA(); };
	Tokenizer.ptr.prototype.startTagIn = function(ss) {
		var _i, _ref, c, i, s, ss, x, x$1, z;
		z = this;
		_ref = ss;
		_i = 0;
		loop:
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			s = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!(((z.data.end - z.data.start >> 0) === s.length))) {
				_i++;
				continue loop;
			}
			i = 0;
			while (true) {
				if (!(i < s.length)) { break; }
				c = (x = z.buf, x$1 = z.data.start + i >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
				if (65 <= c && c <= 90) {
					c = c + (32) << 24 >>> 24;
				}
				if (!((c === s.charCodeAt(i)))) {
					_i++;
					continue loop;
				}
				i = i + (1) >> 0;
			}
			return true;
		}
		return false;
	};
	Tokenizer.prototype.startTagIn = function(ss) { return this.$val.startTagIn(ss); };
	Tokenizer.ptr.prototype.readStartTag = function() {
		var _1, _r, _tmp, _tmp$1, c, raw, x, x$1, x$2, x$3, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; c = $f.c; raw = $f.raw; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		$r = z.readTag(true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return 0;
		}
		_tmp = (x = z.buf, x$1 = z.data.start, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		_tmp$1 = false;
		c = _tmp;
		raw = _tmp$1;
		if (65 <= c && c <= 90) {
			c = c + (32) << 24 >>> 24;
		}
		_1 = c;
		if (_1 === (105)) {
			raw = z.startTagIn(new sliceType(["iframe"]));
		} else if (_1 === (110)) {
			raw = z.startTagIn(new sliceType(["noembed", "noframes", "noscript"]));
		} else if (_1 === (112)) {
			raw = z.startTagIn(new sliceType(["plaintext"]));
		} else if (_1 === (115)) {
			raw = z.startTagIn(new sliceType(["script", "style"]));
		} else if (_1 === (116)) {
			raw = z.startTagIn(new sliceType(["textarea", "title"]));
		} else if (_1 === (120)) {
			raw = z.startTagIn(new sliceType(["xmp"]));
		}
		/* */ if (raw) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (raw) { */ case 2:
			_r = strings.ToLower(($bytesToString($subslice(z.buf, z.data.start, z.data.end)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			z.rawTag = _r;
		/* } */ case 3:
		if ($interfaceIsEqual(z.err, $ifaceNil) && ((x$2 = z.buf, x$3 = z.raw.end - 2 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])) === 47)) {
			$s = -1; return 4;
		}
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readStartTag }; } $f._1 = _1; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.c = c; $f.raw = raw; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readStartTag = function() { return this.$val.readStartTag(); };
	Tokenizer.ptr.prototype.readTag = function(saveAttr) {
		var _r, c, saveAttr, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; saveAttr = $f.saveAttr; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.attr = $subslice(z.attr, 0, 0);
		z.nAttrReturned = 0;
		$r = z.readTagName(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = z.skipWhiteSpace(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		/* while (true) { */ case 3:
			_r = z.readByte(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil)) || (c === 62)) {
				/* break; */ $s = 4; continue;
			}
			z.raw.end = z.raw.end - (1) >> 0;
			$r = z.readTagAttrKey(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = z.readTagAttrVal(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if (saveAttr && !((z.pendingAttr[0].start === z.pendingAttr[0].end))) {
				z.attr = $append(z.attr, z.pendingAttr);
			}
			$r = z.skipWhiteSpace(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break; */ $s = 4; continue;
			}
		/* } */ $s = 3; continue; case 4:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTag }; } $f._r = _r; $f.c = c; $f.saveAttr = saveAttr; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTag = function(saveAttr) { return this.$val.readTag(saveAttr); };
	Tokenizer.ptr.prototype.readTagName = function() {
		var _1, _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.data.start = z.raw.end - 1 >> 0;
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return;
			}
			_1 = c;
			if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12))) {
				z.data.end = z.raw.end - 1 >> 0;
				$s = -1; return;
			} else if ((_1 === (47)) || (_1 === (62))) {
				z.raw.end = z.raw.end - (1) >> 0;
				z.data.end = z.raw.end;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTagName }; } $f._1 = _1; $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTagName = function() { return this.$val.readTagName(); };
	Tokenizer.ptr.prototype.readTagAttrKey = function() {
		var _1, _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.pendingAttr[0].start = z.raw.end;
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.pendingAttr[0].end = z.raw.end;
				$s = -1; return;
			}
			_1 = c;
			if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12)) || (_1 === (47))) {
				z.pendingAttr[0].end = z.raw.end - 1 >> 0;
				$s = -1; return;
			} else if ((_1 === (61)) || (_1 === (62))) {
				z.raw.end = z.raw.end - (1) >> 0;
				z.pendingAttr[0].end = z.raw.end;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTagAttrKey }; } $f._1 = _1; $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTagAttrKey = function() { return this.$val.readTagAttrKey(); };
	Tokenizer.ptr.prototype.readTagAttrVal = function() {
		var _1, _2, _r, _r$1, _r$2, _r$3, c, c$1, c$2, quote, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; c = $f.c; c$1 = $f.c$1; c$2 = $f.c$2; quote = $f.quote; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.pendingAttr[1].start = z.raw.end;
		z.pendingAttr[1].end = z.raw.end;
		$r = z.skipWhiteSpace(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		_r = z.readByte(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		c = _r;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		if (!((c === 61))) {
			z.raw.end = z.raw.end - (1) >> 0;
			$s = -1; return;
		}
		$r = z.skipWhiteSpace(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		_r$1 = z.readByte(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		quote = _r$1;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
			_1 = quote;
			/* */ if (_1 === (62)) { $s = 6; continue; }
			/* */ if ((_1 === (39)) || (_1 === (34))) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (62)) { */ case 6:
				z.raw.end = z.raw.end - (1) >> 0;
				$s = -1; return;
			/* } else if ((_1 === (39)) || (_1 === (34))) { */ case 7:
				z.pendingAttr[1].start = z.raw.end;
				/* while (true) { */ case 10:
					_r$2 = z.readByte(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					c$1 = _r$2;
					if (!($interfaceIsEqual(z.err, $ifaceNil))) {
						z.pendingAttr[1].end = z.raw.end;
						$s = -1; return;
					}
					if (c$1 === quote) {
						z.pendingAttr[1].end = z.raw.end - 1 >> 0;
						$s = -1; return;
					}
				/* } */ $s = 10; continue; case 11:
				$s = 9; continue;
			/* } else { */ case 8:
				z.pendingAttr[1].start = z.raw.end - 1 >> 0;
				/* while (true) { */ case 13:
					_r$3 = z.readByte(); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					c$2 = _r$3;
					if (!($interfaceIsEqual(z.err, $ifaceNil))) {
						z.pendingAttr[1].end = z.raw.end;
						$s = -1; return;
					}
					_2 = c$2;
					if ((_2 === (32)) || (_2 === (10)) || (_2 === (13)) || (_2 === (9)) || (_2 === (12))) {
						z.pendingAttr[1].end = z.raw.end - 1 >> 0;
						$s = -1; return;
					} else if (_2 === (62)) {
						z.raw.end = z.raw.end - (1) >> 0;
						z.pendingAttr[1].end = z.raw.end;
						$s = -1; return;
					}
				/* } */ $s = 13; continue; case 14:
			/* } */ case 9:
		case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTagAttrVal }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.c = c; $f.c$1 = c$1; $f.c$2 = c$2; $f.quote = quote; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTagAttrVal = function() { return this.$val.readTagAttrVal(); };
	Tokenizer.ptr.prototype.Next = function() {
		var _1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, c, tokenType, x, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; c = $f.c; tokenType = $f.tokenType; x = $f.x; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.raw.start = z.raw.end;
		z.data.start = z.raw.end;
		z.data.end = z.raw.end;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			z.tt = 0;
			$s = -1; return z.tt;
		}
		/* */ if (!(z.rawTag === "")) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(z.rawTag === "")) { */ case 1:
			/* */ if (z.rawTag === "plaintext") { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (z.rawTag === "plaintext") { */ case 3:
				/* while (true) { */ case 6:
					/* if (!($interfaceIsEqual(z.err, $ifaceNil))) { break; } */ if(!($interfaceIsEqual(z.err, $ifaceNil))) { $s = 7; continue; }
					_r = z.readByte(); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_r;
				/* } */ $s = 6; continue; case 7:
				z.data.end = z.raw.end;
				z.textIsRaw = true;
				$s = 5; continue;
			/* } else { */ case 4:
				$r = z.readRawOrRCDATA(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 5:
			if (z.data.end > z.data.start) {
				z.tt = 1;
				z.convertNUL = true;
				$s = -1; return z.tt;
			}
		/* } */ case 2:
		z.textIsRaw = false;
		z.convertNUL = false;
		/* while (true) { */ case 10:
			_r$1 = z.readByte(); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c = _r$1;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 11; continue s;
			}
			/* */ if (!((c === 60))) { $s = 13; continue; }
			/* */ $s = 14; continue;
			/* if (!((c === 60))) { */ case 13:
				/* continue loop; */ $s = 10; continue s;
			/* } */ case 14:
			_r$2 = z.readByte(); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			c = _r$2;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 11; continue s;
			}
			tokenType = 0;
				if (97 <= c && c <= 122 || 65 <= c && c <= 90) {
					tokenType = 2;
				} else if ((c === 47)) {
					tokenType = 3;
				} else if ((c === 33) || (c === 63)) {
					tokenType = 5;
				} else {
					z.raw.end = z.raw.end - (1) >> 0;
					/* continue; */ $s = 10; continue;
				}
			case 16:
			x = z.raw.end - 2 >> 0;
			if (z.raw.start < x) {
				z.raw.end = x;
				z.data.end = x;
				z.tt = 1;
				$s = -1; return z.tt;
			}
				_1 = tokenType;
				/* */ if (_1 === (2)) { $s = 18; continue; }
				/* */ if (_1 === (3)) { $s = 19; continue; }
				/* */ if (_1 === (5)) { $s = 20; continue; }
				/* */ $s = 21; continue;
				/* if (_1 === (2)) { */ case 18:
					_r$3 = z.readStartTag(); /* */ $s = 22; case 22: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					z.tt = _r$3;
					$s = -1; return z.tt;
				/* } else if (_1 === (3)) { */ case 19:
					_r$4 = z.readByte(); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					c = _r$4;
					if (!($interfaceIsEqual(z.err, $ifaceNil))) {
						/* break loop; */ $s = 11; continue s;
					}
					if (c === 62) {
						z.tt = 5;
						$s = -1; return z.tt;
					}
					/* */ if (97 <= c && c <= 122 || 65 <= c && c <= 90) { $s = 24; continue; }
					/* */ $s = 25; continue;
					/* if (97 <= c && c <= 122 || 65 <= c && c <= 90) { */ case 24:
						$r = z.readTag(false); /* */ $s = 26; case 26: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						if (!($interfaceIsEqual(z.err, $ifaceNil))) {
							z.tt = 0;
						} else {
							z.tt = 3;
						}
						$s = -1; return z.tt;
					/* } */ case 25:
					z.raw.end = z.raw.end - (1) >> 0;
					$r = z.readUntilCloseAngle(); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					z.tt = 5;
					$s = -1; return z.tt;
				/* } else if (_1 === (5)) { */ case 20:
					/* */ if (c === 33) { $s = 28; continue; }
					/* */ $s = 29; continue;
					/* if (c === 33) { */ case 28:
						_r$5 = z.readMarkupDeclaration(); /* */ $s = 30; case 30: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
						z.tt = _r$5;
						$s = -1; return z.tt;
					/* } */ case 29:
					z.raw.end = z.raw.end - (1) >> 0;
					$r = z.readUntilCloseAngle(); /* */ $s = 31; case 31: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					z.tt = 5;
					$s = -1; return z.tt;
				/* } */ case 21:
			case 17:
		/* } */ $s = 10; continue; case 11:
		if (z.raw.start < z.raw.end) {
			z.data.end = z.raw.end;
			z.tt = 1;
			$s = -1; return z.tt;
		}
		z.tt = 0;
		$s = -1; return z.tt;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.Next }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.c = c; $f.tokenType = tokenType; $f.x = x; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.Next = function() { return this.$val.Next(); };
	Tokenizer.ptr.prototype.Raw = function() {
		var z;
		z = this;
		return $subslice(z.buf, z.raw.start, z.raw.end);
	};
	Tokenizer.prototype.Raw = function() { return this.$val.Raw(); };
	convertNewlines = function(s) {
		var _i, _ref, c, dst, i, s, src, x;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((c === 13))) {
				_i++;
				continue;
			}
			src = i + 1 >> 0;
			if (src >= s.$length || !((((src < 0 || src >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + src]) === 10))) {
				((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = 10);
				_i++;
				continue;
			}
			dst = i;
			while (true) {
				if (!(src < s.$length)) { break; }
				if (((src < 0 || src >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + src]) === 13) {
					if ((src + 1 >> 0) < s.$length && ((x = src + 1 >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) === 10)) {
						src = src + (1) >> 0;
					}
					((dst < 0 || dst >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + dst] = 10);
				} else {
					((dst < 0 || dst >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + dst] = ((src < 0 || src >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + src]));
				}
				src = src + (1) >> 0;
				dst = dst + (1) >> 0;
			}
			return $subslice(s, 0, dst);
		}
		return s;
	};
	Tokenizer.ptr.prototype.Text = function() {
		var _1, s, z;
		z = this;
		_1 = z.tt;
		if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) {
			s = $subslice(z.buf, z.data.start, z.data.end);
			z.data.start = z.raw.end;
			z.data.end = z.raw.end;
			s = convertNewlines(s);
			if ((z.convertNUL || (z.tt === 5)) && bytes.Contains(s, nul)) {
				s = bytes.Replace(s, nul, replacement, -1);
			}
			if (!z.textIsRaw) {
				s = unescape(s, false);
			}
			return s;
		}
		return sliceType$3.nil;
	};
	Tokenizer.prototype.Text = function() { return this.$val.Text(); };
	Tokenizer.ptr.prototype.TagName = function() {
		var _1, _tmp, _tmp$1, _tmp$2, _tmp$3, hasAttr, name, s, z;
		name = sliceType$3.nil;
		hasAttr = false;
		z = this;
		if (z.data.start < z.data.end) {
			_1 = z.tt;
			if ((_1 === (2)) || (_1 === (3)) || (_1 === (4))) {
				s = $subslice(z.buf, z.data.start, z.data.end);
				z.data.start = z.raw.end;
				z.data.end = z.raw.end;
				_tmp = lower(s);
				_tmp$1 = z.nAttrReturned < z.attr.$length;
				name = _tmp;
				hasAttr = _tmp$1;
				return [name, hasAttr];
			}
		}
		_tmp$2 = sliceType$3.nil;
		_tmp$3 = false;
		name = _tmp$2;
		hasAttr = _tmp$3;
		return [name, hasAttr];
	};
	Tokenizer.prototype.TagName = function() { return this.$val.TagName(); };
	Tokenizer.ptr.prototype.TagAttr = function() {
		var _1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, key, moreAttr, val, x, x$1, x$2, z;
		key = sliceType$3.nil;
		val = sliceType$3.nil;
		moreAttr = false;
		z = this;
		if (z.nAttrReturned < z.attr.$length) {
			_1 = z.tt;
			if ((_1 === (2)) || (_1 === (4))) {
				x$2 = $clone((x = z.attr, x$1 = z.nAttrReturned, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])), arrayType$1);
				z.nAttrReturned = z.nAttrReturned + (1) >> 0;
				key = $subslice(z.buf, x$2[0].start, x$2[0].end);
				val = $subslice(z.buf, x$2[1].start, x$2[1].end);
				_tmp = lower(key);
				_tmp$1 = unescape(convertNewlines(val), true);
				_tmp$2 = z.nAttrReturned < z.attr.$length;
				key = _tmp;
				val = _tmp$1;
				moreAttr = _tmp$2;
				return [key, val, moreAttr];
			}
		}
		_tmp$3 = sliceType$3.nil;
		_tmp$4 = sliceType$3.nil;
		_tmp$5 = false;
		key = _tmp$3;
		val = _tmp$4;
		moreAttr = _tmp$5;
		return [key, val, moreAttr];
	};
	Tokenizer.prototype.TagAttr = function() { return this.$val.TagAttr(); };
	Tokenizer.ptr.prototype.Token = function() {
		var _1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, a, key, moreAttr, name, t, val, z;
		z = this;
		t = new Token.ptr(z.tt, 0, "", sliceType$1.nil);
		_1 = z.tt;
		if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) {
			t.Data = ($bytesToString(z.Text()));
		} else if ((_1 === (2)) || (_1 === (4)) || (_1 === (3))) {
			_tuple = z.TagName();
			name = _tuple[0];
			moreAttr = _tuple[1];
			while (true) {
				if (!(moreAttr)) { break; }
				_tmp = sliceType$3.nil;
				_tmp$1 = sliceType$3.nil;
				key = _tmp;
				val = _tmp$1;
				_tuple$1 = z.TagAttr();
				key = _tuple$1[0];
				val = _tuple$1[1];
				moreAttr = _tuple$1[2];
				t.Attr = $append(t.Attr, new Attribute.ptr("", atom.String(key), ($bytesToString(val))));
			}
			a = atom.Lookup(name);
			if (!((a === 0))) {
				_tmp$2 = a;
				_tmp$3 = new atom.Atom(a).String();
				t.DataAtom = _tmp$2;
				t.Data = _tmp$3;
			} else {
				_tmp$4 = 0;
				_tmp$5 = ($bytesToString(name));
				t.DataAtom = _tmp$4;
				t.Data = _tmp$5;
			}
		}
		return t;
	};
	Tokenizer.prototype.Token = function() { return this.$val.Token(); };
	Tokenizer.ptr.prototype.SetMaxBuf = function(n) {
		var n, z;
		z = this;
		z.maxBuf = n;
	};
	Tokenizer.prototype.SetMaxBuf = function(n) { return this.$val.SetMaxBuf(n); };
	NewTokenizerFragment = function(r, contextTag) {
		var _1, _r, contextTag, r, s, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; contextTag = $f.contextTag; r = $f.r; s = $f.s; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = new Tokenizer.ptr(r, 0, $ifaceNil, $ifaceNil, new span.ptr(0, 0), $makeSlice(sliceType$3, 0, 4096), 0, new span.ptr(0, 0), arrayType$1.zero(), sliceType$7.nil, 0, "", false, false, false);
		/* */ if (!(contextTag === "")) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(contextTag === "")) { */ case 1:
				_r = strings.ToLower(contextTag); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				_1 = s;
				if (_1 === ("iframe") || _1 === ("noembed") || _1 === ("noframes") || _1 === ("noscript") || _1 === ("plaintext") || _1 === ("script") || _1 === ("style") || _1 === ("title") || _1 === ("textarea") || _1 === ("xmp")) {
					z.rawTag = s;
				}
			case 3:
		/* } */ case 2:
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewTokenizerFragment }; } $f._1 = _1; $f._r = _r; $f.contextTag = contextTag; $f.r = r; $f.s = s; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewTokenizerFragment = NewTokenizerFragment;
	ptrType.methods = [{prop: "InsertBefore", name: "InsertBefore", pkg: "", typ: $funcType([ptrType, ptrType], [], false)}, {prop: "AppendChild", name: "AppendChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "RemoveChild", name: "RemoveChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "clone", name: "clone", pkg: "github.com/b3log/lute/html", typ: $funcType([], [ptrType], false)}];
	ptrType$1.methods = [{prop: "pop", name: "pop", pkg: "github.com/b3log/lute/html", typ: $funcType([], [ptrType], false)}, {prop: "top", name: "top", pkg: "github.com/b3log/lute/html", typ: $funcType([], [ptrType], false)}, {prop: "index", name: "index", pkg: "github.com/b3log/lute/html", typ: $funcType([ptrType], [$Int], false)}, {prop: "contains", name: "contains", pkg: "github.com/b3log/lute/html", typ: $funcType([atom.Atom], [$Bool], false)}, {prop: "insert", name: "insert", pkg: "github.com/b3log/lute/html", typ: $funcType([$Int, ptrType], [], false)}, {prop: "remove", name: "remove", pkg: "github.com/b3log/lute/html", typ: $funcType([ptrType], [], false)}];
	ptrType$2.methods = [{prop: "pop", name: "pop", pkg: "github.com/b3log/lute/html", typ: $funcType([], [insertionMode], false)}, {prop: "top", name: "top", pkg: "github.com/b3log/lute/html", typ: $funcType([], [insertionMode], false)}];
	ptrType$4.methods = [{prop: "top", name: "top", pkg: "github.com/b3log/lute/html", typ: $funcType([], [ptrType], false)}, {prop: "popUntil", name: "popUntil", pkg: "github.com/b3log/lute/html", typ: $funcType([scope, sliceType$2], [$Bool], true)}, {prop: "indexOfElementInScope", name: "indexOfElementInScope", pkg: "github.com/b3log/lute/html", typ: $funcType([scope, sliceType$2], [$Int], true)}, {prop: "elementInScope", name: "elementInScope", pkg: "github.com/b3log/lute/html", typ: $funcType([scope, sliceType$2], [$Bool], true)}, {prop: "clearStackToContext", name: "clearStackToContext", pkg: "github.com/b3log/lute/html", typ: $funcType([scope], [], false)}, {prop: "generateImpliedEndTags", name: "generateImpliedEndTags", pkg: "github.com/b3log/lute/html", typ: $funcType([sliceType], [], true)}, {prop: "addChild", name: "addChild", pkg: "github.com/b3log/lute/html", typ: $funcType([ptrType], [], false)}, {prop: "shouldFosterParent", name: "shouldFosterParent", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$Bool], false)}, {prop: "fosterParent", name: "fosterParent", pkg: "github.com/b3log/lute/html", typ: $funcType([ptrType], [], false)}, {prop: "addText", name: "addText", pkg: "github.com/b3log/lute/html", typ: $funcType([$String], [], false)}, {prop: "addElement", name: "addElement", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "addFormattingElement", name: "addFormattingElement", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "clearActiveFormattingElements", name: "clearActiveFormattingElements", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "reconstructActiveFormattingElements", name: "reconstructActiveFormattingElements", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "acknowledgeSelfClosingTag", name: "acknowledgeSelfClosingTag", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "setOriginalIM", name: "setOriginalIM", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "resetInsertionMode", name: "resetInsertionMode", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "inBodyEndTagFormatting", name: "inBodyEndTagFormatting", pkg: "github.com/b3log/lute/html", typ: $funcType([atom.Atom, $String], [], false)}, {prop: "inBodyEndTagOther", name: "inBodyEndTagOther", pkg: "github.com/b3log/lute/html", typ: $funcType([atom.Atom, $String], [], false)}, {prop: "inForeignContent", name: "inForeignContent", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$Bool], false)}, {prop: "parseImpliedToken", name: "parseImpliedToken", pkg: "github.com/b3log/lute/html", typ: $funcType([TokenType, atom.Atom, $String], [], false)}, {prop: "parseCurrentToken", name: "parseCurrentToken", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "parse", name: "parse", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$error], false)}];
	TokenType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Token.methods = [{prop: "tagString", name: "tagString", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$String], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$3.methods = [{prop: "AllowCDATA", name: "AllowCDATA", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "NextIsNotRawText", name: "NextIsNotRawText", pkg: "", typ: $funcType([], [], false)}, {prop: "Err", name: "Err", pkg: "", typ: $funcType([], [$error], false)}, {prop: "readByte", name: "readByte", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$Uint8], false)}, {prop: "Buffered", name: "Buffered", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "skipWhiteSpace", name: "skipWhiteSpace", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "readRawOrRCDATA", name: "readRawOrRCDATA", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "readRawEndTag", name: "readRawEndTag", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$Bool], false)}, {prop: "readScript", name: "readScript", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "readComment", name: "readComment", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "readUntilCloseAngle", name: "readUntilCloseAngle", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "readMarkupDeclaration", name: "readMarkupDeclaration", pkg: "github.com/b3log/lute/html", typ: $funcType([], [TokenType], false)}, {prop: "readDoctype", name: "readDoctype", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$Bool], false)}, {prop: "readCDATA", name: "readCDATA", pkg: "github.com/b3log/lute/html", typ: $funcType([], [$Bool], false)}, {prop: "startTagIn", name: "startTagIn", pkg: "github.com/b3log/lute/html", typ: $funcType([sliceType], [$Bool], true)}, {prop: "readStartTag", name: "readStartTag", pkg: "github.com/b3log/lute/html", typ: $funcType([], [TokenType], false)}, {prop: "readTag", name: "readTag", pkg: "github.com/b3log/lute/html", typ: $funcType([$Bool], [], false)}, {prop: "readTagName", name: "readTagName", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "readTagAttrKey", name: "readTagAttrKey", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "readTagAttrVal", name: "readTagAttrVal", pkg: "github.com/b3log/lute/html", typ: $funcType([], [], false)}, {prop: "Next", name: "Next", pkg: "", typ: $funcType([], [TokenType], false)}, {prop: "Raw", name: "Raw", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "Text", name: "Text", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "TagName", name: "TagName", pkg: "", typ: $funcType([], [sliceType$3, $Bool], false)}, {prop: "TagAttr", name: "TagAttr", pkg: "", typ: $funcType([], [sliceType$3, sliceType$3, $Bool], false)}, {prop: "Token", name: "Token", pkg: "", typ: $funcType([], [Token], false)}, {prop: "SetMaxBuf", name: "SetMaxBuf", pkg: "", typ: $funcType([$Int], [], false)}];
	Node.init("", [{prop: "Parent", name: "Parent", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "FirstChild", name: "FirstChild", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "LastChild", name: "LastChild", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "PrevSibling", name: "PrevSibling", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "NextSibling", name: "NextSibling", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "Type", name: "Type", embedded: false, exported: true, typ: NodeType, tag: ""}, {prop: "DataAtom", name: "DataAtom", embedded: false, exported: true, typ: atom.Atom, tag: ""}, {prop: "Data", name: "Data", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Namespace", name: "Namespace", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Attr", name: "Attr", embedded: false, exported: true, typ: sliceType$1, tag: ""}]);
	nodeStack.init(ptrType);
	insertionModeStack.init(insertionMode);
	parser.init("github.com/b3log/lute/html", [{prop: "tokenizer", name: "tokenizer", embedded: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "tok", name: "tok", embedded: false, exported: false, typ: Token, tag: ""}, {prop: "hasSelfClosingToken", name: "hasSelfClosingToken", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "doc", name: "doc", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "oe", name: "oe", embedded: false, exported: false, typ: nodeStack, tag: ""}, {prop: "afe", name: "afe", embedded: false, exported: false, typ: nodeStack, tag: ""}, {prop: "head", name: "head", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "form", name: "form", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "scripting", name: "scripting", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "framesetOK", name: "framesetOK", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "templateStack", name: "templateStack", embedded: false, exported: false, typ: insertionModeStack, tag: ""}, {prop: "im", name: "im", embedded: false, exported: false, typ: insertionMode, tag: ""}, {prop: "originalIM", name: "originalIM", embedded: false, exported: false, typ: insertionMode, tag: ""}, {prop: "fosterParenting", name: "fosterParenting", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "quirks", name: "quirks", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "fragment", name: "fragment", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "context", name: "context", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	insertionMode.init([ptrType$4], [$Bool], false);
	ParseOption.init([ptrType$4], [], false);
	Attribute.init("", [{prop: "Namespace", name: "Namespace", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Key", name: "Key", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Val", name: "Val", embedded: false, exported: true, typ: $String, tag: ""}]);
	Token.init("", [{prop: "Type", name: "Type", embedded: false, exported: true, typ: TokenType, tag: ""}, {prop: "DataAtom", name: "DataAtom", embedded: false, exported: true, typ: atom.Atom, tag: ""}, {prop: "Data", name: "Data", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Attr", name: "Attr", embedded: false, exported: true, typ: sliceType$1, tag: ""}]);
	span.init("github.com/b3log/lute/html", [{prop: "start", name: "start", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "end", name: "end", embedded: false, exported: false, typ: $Int, tag: ""}]);
	Tokenizer.init("github.com/b3log/lute/html", [{prop: "r", name: "r", embedded: false, exported: false, typ: io.Reader, tag: ""}, {prop: "tt", name: "tt", embedded: false, exported: false, typ: TokenType, tag: ""}, {prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "readErr", name: "readErr", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "raw", name: "raw", embedded: false, exported: false, typ: span, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "maxBuf", name: "maxBuf", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "data", name: "data", embedded: false, exported: false, typ: span, tag: ""}, {prop: "pendingAttr", name: "pendingAttr", embedded: false, exported: false, typ: arrayType$1, tag: ""}, {prop: "attr", name: "attr", embedded: false, exported: false, typ: sliceType$7, tag: ""}, {prop: "nAttrReturned", name: "nAttrReturned", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "rawTag", name: "rawTag", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "textIsRaw", name: "textIsRaw", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "convertNUL", name: "convertNUL", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "allowCDATA", name: "allowCDATA", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bufio.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytes.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atom.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		isSpecialElementMap = $makeMap($String.keyFor, [{ k: "address", v: true }, { k: "applet", v: true }, { k: "area", v: true }, { k: "article", v: true }, { k: "aside", v: true }, { k: "base", v: true }, { k: "basefont", v: true }, { k: "bgsound", v: true }, { k: "blockquote", v: true }, { k: "body", v: true }, { k: "br", v: true }, { k: "button", v: true }, { k: "caption", v: true }, { k: "center", v: true }, { k: "col", v: true }, { k: "colgroup", v: true }, { k: "dd", v: true }, { k: "details", v: true }, { k: "dir", v: true }, { k: "div", v: true }, { k: "dl", v: true }, { k: "dt", v: true }, { k: "embed", v: true }, { k: "fieldset", v: true }, { k: "figcaption", v: true }, { k: "figure", v: true }, { k: "footer", v: true }, { k: "form", v: true }, { k: "frame", v: true }, { k: "frameset", v: true }, { k: "h1", v: true }, { k: "h2", v: true }, { k: "h3", v: true }, { k: "h4", v: true }, { k: "h5", v: true }, { k: "h6", v: true }, { k: "head", v: true }, { k: "header", v: true }, { k: "hgroup", v: true }, { k: "hr", v: true }, { k: "html", v: true }, { k: "iframe", v: true }, { k: "img", v: true }, { k: "input", v: true }, { k: "isindex", v: true }, { k: "keygen", v: true }, { k: "li", v: true }, { k: "link", v: true }, { k: "listing", v: true }, { k: "main", v: true }, { k: "marquee", v: true }, { k: "menu", v: true }, { k: "meta", v: true }, { k: "nav", v: true }, { k: "noembed", v: true }, { k: "noframes", v: true }, { k: "noscript", v: true }, { k: "object", v: true }, { k: "ol", v: true }, { k: "p", v: true }, { k: "param", v: true }, { k: "plaintext", v: true }, { k: "pre", v: true }, { k: "script", v: true }, { k: "section", v: true }, { k: "select", v: true }, { k: "source", v: true }, { k: "style", v: true }, { k: "summary", v: true }, { k: "table", v: true }, { k: "tbody", v: true }, { k: "td", v: true }, { k: "template", v: true }, { k: "textarea", v: true }, { k: "tfoot", v: true }, { k: "th", v: true }, { k: "thead", v: true }, { k: "title", v: true }, { k: "tr", v: true }, { k: "track", v: true }, { k: "ul", v: true }, { k: "wbr", v: true }, { k: "xmp", v: true }]);
		$pkg.Entities = $makeMap($String.keyFor, [{ k: "AElig", v: "\xC3\x86" }, { k: "AMP", v: "&" }, { k: "Aacute", v: "\xC3\x81" }, { k: "Abreve", v: "\xC4\x82" }, { k: "Acirc", v: "\xC3\x82" }, { k: "Acy", v: "\xD0\x90" }, { k: "Afr", v: "\xF0\x9D\x94\x84" }, { k: "Agrave", v: "\xC3\x80" }, { k: "Alpha", v: "\xCE\x91" }, { k: "Amacr", v: "\xC4\x80" }, { k: "And", v: "\xE2\xA9\x93" }, { k: "Aogon", v: "\xC4\x84" }, { k: "Aopf", v: "\xF0\x9D\x94\xB8" }, { k: "ApplyFunction", v: "\xE2\x81\xA1" }, { k: "Aring", v: "\xC3\x85" }, { k: "Ascr", v: "\xF0\x9D\x92\x9C" }, { k: "Assign", v: "\xE2\x89\x94" }, { k: "Atilde", v: "\xC3\x83" }, { k: "Auml", v: "\xC3\x84" }, { k: "Backslash", v: "\xE2\x88\x96" }, { k: "Barv", v: "\xE2\xAB\xA7" }, { k: "Barwed", v: "\xE2\x8C\x86" }, { k: "Bcy", v: "\xD0\x91" }, { k: "Because", v: "\xE2\x88\xB5" }, { k: "Bernoullis", v: "\xE2\x84\xAC" }, { k: "Beta", v: "\xCE\x92" }, { k: "Bfr", v: "\xF0\x9D\x94\x85" }, { k: "Bopf", v: "\xF0\x9D\x94\xB9" }, { k: "Breve", v: "\xCB\x98" }, { k: "Bscr", v: "\xE2\x84\xAC" }, { k: "Bumpeq", v: "\xE2\x89\x8E" }, { k: "CHcy", v: "\xD0\xA7" }, { k: "COPY", v: "\xC2\xA9" }, { k: "Cacute", v: "\xC4\x86" }, { k: "Cap", v: "\xE2\x8B\x92" }, { k: "CapitalDifferentialD", v: "\xE2\x85\x85" }, { k: "Cayleys", v: "\xE2\x84\xAD" }, { k: "Ccaron", v: "\xC4\x8C" }, { k: "Ccedil", v: "\xC3\x87" }, { k: "Ccirc", v: "\xC4\x88" }, { k: "Cconint", v: "\xE2\x88\xB0" }, { k: "Cdot", v: "\xC4\x8A" }, { k: "Cedilla", v: "\xC2\xB8" }, { k: "CenterDot", v: "\xC2\xB7" }, { k: "Cfr", v: "\xE2\x84\xAD" }, { k: "Chi", v: "\xCE\xA7" }, { k: "CircleDot", v: "\xE2\x8A\x99" }, { k: "CircleMinus", v: "\xE2\x8A\x96" }, { k: "CirclePlus", v: "\xE2\x8A\x95" }, { k: "CircleTimes", v: "\xE2\x8A\x97" }, { k: "ClockwiseContourIntegral", v: "\xE2\x88\xB2" }, { k: "CloseCurlyDoubleQuote", v: "\xE2\x80\x9D" }, { k: "CloseCurlyQuote", v: "\xE2\x80\x99" }, { k: "Colon", v: "\xE2\x88\xB7" }, { k: "Colone", v: "\xE2\xA9\xB4" }, { k: "Congruent", v: "\xE2\x89\xA1" }, { k: "Conint", v: "\xE2\x88\xAF" }, { k: "ContourIntegral", v: "\xE2\x88\xAE" }, { k: "Copf", v: "\xE2\x84\x82" }, { k: "Coproduct", v: "\xE2\x88\x90" }, { k: "CounterClockwiseContourIntegral", v: "\xE2\x88\xB3" }, { k: "Cross", v: "\xE2\xA8\xAF" }, { k: "Cscr", v: "\xF0\x9D\x92\x9E" }, { k: "Cup", v: "\xE2\x8B\x93" }, { k: "CupCap", v: "\xE2\x89\x8D" }, { k: "DD", v: "\xE2\x85\x85" }, { k: "DDotrahd", v: "\xE2\xA4\x91" }, { k: "DJcy", v: "\xD0\x82" }, { k: "DScy", v: "\xD0\x85" }, { k: "DZcy", v: "\xD0\x8F" }, { k: "Dagger", v: "\xE2\x80\xA1" }, { k: "Darr", v: "\xE2\x86\xA1" }, { k: "Dashv", v: "\xE2\xAB\xA4" }, { k: "Dcaron", v: "\xC4\x8E" }, { k: "Dcy", v: "\xD0\x94" }, { k: "Del", v: "\xE2\x88\x87" }, { k: "Delta", v: "\xCE\x94" }, { k: "Dfr", v: "\xF0\x9D\x94\x87" }, { k: "DiacriticalAcute", v: "\xC2\xB4" }, { k: "DiacriticalDot", v: "\xCB\x99" }, { k: "DiacriticalDoubleAcute", v: "\xCB\x9D" }, { k: "DiacriticalGrave", v: "`" }, { k: "DiacriticalTilde", v: "\xCB\x9C" }, { k: "Diamond", v: "\xE2\x8B\x84" }, { k: "DifferentialD", v: "\xE2\x85\x86" }, { k: "Dopf", v: "\xF0\x9D\x94\xBB" }, { k: "Dot", v: "\xC2\xA8" }, { k: "DotDot", v: "\xE2\x83\x9C" }, { k: "DotEqual", v: "\xE2\x89\x90" }, { k: "DoubleContourIntegral", v: "\xE2\x88\xAF" }, { k: "DoubleDot", v: "\xC2\xA8" }, { k: "DoubleDownArrow", v: "\xE2\x87\x93" }, { k: "DoubleLeftArrow", v: "\xE2\x87\x90" }, { k: "DoubleLeftRightArrow", v: "\xE2\x87\x94" }, { k: "DoubleLeftTee", v: "\xE2\xAB\xA4" }, { k: "DoubleLongLeftArrow", v: "\xE2\x9F\xB8" }, { k: "DoubleLongLeftRightArrow", v: "\xE2\x9F\xBA" }, { k: "DoubleLongRightArrow", v: "\xE2\x9F\xB9" }, { k: "DoubleRightArrow", v: "\xE2\x87\x92" }, { k: "DoubleRightTee", v: "\xE2\x8A\xA8" }, { k: "DoubleUpArrow", v: "\xE2\x87\x91" }, { k: "DoubleUpDownArrow", v: "\xE2\x87\x95" }, { k: "DoubleVerticalBar", v: "\xE2\x88\xA5" }, { k: "DownArrow", v: "\xE2\x86\x93" }, { k: "DownArrowBar", v: "\xE2\xA4\x93" }, { k: "DownArrowUpArrow", v: "\xE2\x87\xB5" }, { k: "DownBreve", v: "\xCC\x91" }, { k: "DownLeftRightVector", v: "\xE2\xA5\x90" }, { k: "DownLeftTeeVector", v: "\xE2\xA5\x9E" }, { k: "DownLeftVector", v: "\xE2\x86\xBD" }, { k: "DownLeftVectorBar", v: "\xE2\xA5\x96" }, { k: "DownRightTeeVector", v: "\xE2\xA5\x9F" }, { k: "DownRightVector", v: "\xE2\x87\x81" }, { k: "DownRightVectorBar", v: "\xE2\xA5\x97" }, { k: "DownTee", v: "\xE2\x8A\xA4" }, { k: "DownTeeArrow", v: "\xE2\x86\xA7" }, { k: "Downarrow", v: "\xE2\x87\x93" }, { k: "Dscr", v: "\xF0\x9D\x92\x9F" }, { k: "Dstrok", v: "\xC4\x90" }, { k: "ENG", v: "\xC5\x8A" }, { k: "ETH", v: "\xC3\x90" }, { k: "Eacute", v: "\xC3\x89" }, { k: "Ecaron", v: "\xC4\x9A" }, { k: "Ecirc", v: "\xC3\x8A" }, { k: "Ecy", v: "\xD0\xAD" }, { k: "Edot", v: "\xC4\x96" }, { k: "Efr", v: "\xF0\x9D\x94\x88" }, { k: "Egrave", v: "\xC3\x88" }, { k: "Element", v: "\xE2\x88\x88" }, { k: "Emacr", v: "\xC4\x92" }, { k: "EmptySmallSquare", v: "\xE2\x97\xBB" }, { k: "EmptyVerySmallSquare", v: "\xE2\x96\xAB" }, { k: "Eogon", v: "\xC4\x98" }, { k: "Eopf", v: "\xF0\x9D\x94\xBC" }, { k: "Epsilon", v: "\xCE\x95" }, { k: "Equal", v: "\xE2\xA9\xB5" }, { k: "EqualTilde", v: "\xE2\x89\x82" }, { k: "Equilibrium", v: "\xE2\x87\x8C" }, { k: "Escr", v: "\xE2\x84\xB0" }, { k: "Esim", v: "\xE2\xA9\xB3" }, { k: "Eta", v: "\xCE\x97" }, { k: "Euml", v: "\xC3\x8B" }, { k: "Exists", v: "\xE2\x88\x83" }, { k: "ExponentialE", v: "\xE2\x85\x87" }, { k: "Fcy", v: "\xD0\xA4" }, { k: "Ffr", v: "\xF0\x9D\x94\x89" }, { k: "FilledSmallSquare", v: "\xE2\x97\xBC" }, { k: "FilledVerySmallSquare", v: "\xE2\x96\xAA" }, { k: "Fopf", v: "\xF0\x9D\x94\xBD" }, { k: "ForAll", v: "\xE2\x88\x80" }, { k: "Fouriertrf", v: "\xE2\x84\xB1" }, { k: "Fscr", v: "\xE2\x84\xB1" }, { k: "GJcy", v: "\xD0\x83" }, { k: "GT", v: ">" }, { k: "Gamma", v: "\xCE\x93" }, { k: "Gammad", v: "\xCF\x9C" }, { k: "Gbreve", v: "\xC4\x9E" }, { k: "Gcedil", v: "\xC4\xA2" }, { k: "Gcirc", v: "\xC4\x9C" }, { k: "Gcy", v: "\xD0\x93" }, { k: "Gdot", v: "\xC4\xA0" }, { k: "Gfr", v: "\xF0\x9D\x94\x8A" }, { k: "Gg", v: "\xE2\x8B\x99" }, { k: "Gopf", v: "\xF0\x9D\x94\xBE" }, { k: "GreaterEqual", v: "\xE2\x89\xA5" }, { k: "GreaterEqualLess", v: "\xE2\x8B\x9B" }, { k: "GreaterFullEqual", v: "\xE2\x89\xA7" }, { k: "GreaterGreater", v: "\xE2\xAA\xA2" }, { k: "GreaterLess", v: "\xE2\x89\xB7" }, { k: "GreaterSlantEqual", v: "\xE2\xA9\xBE" }, { k: "GreaterTilde", v: "\xE2\x89\xB3" }, { k: "Gscr", v: "\xF0\x9D\x92\xA2" }, { k: "Gt", v: "\xE2\x89\xAB" }, { k: "HARDcy", v: "\xD0\xAA" }, { k: "Hacek", v: "\xCB\x87" }, { k: "Hat", v: "^" }, { k: "Hcirc", v: "\xC4\xA4" }, { k: "Hfr", v: "\xE2\x84\x8C" }, { k: "HilbertSpace", v: "\xE2\x84\x8B" }, { k: "Hopf", v: "\xE2\x84\x8D" }, { k: "HorizontalLine", v: "\xE2\x94\x80" }, { k: "Hscr", v: "\xE2\x84\x8B" }, { k: "Hstrok", v: "\xC4\xA6" }, { k: "HumpDownHump", v: "\xE2\x89\x8E" }, { k: "HumpEqual", v: "\xE2\x89\x8F" }, { k: "IEcy", v: "\xD0\x95" }, { k: "IJlig", v: "\xC4\xB2" }, { k: "IOcy", v: "\xD0\x81" }, { k: "Iacute", v: "\xC3\x8D" }, { k: "Icirc", v: "\xC3\x8E" }, { k: "Icy", v: "\xD0\x98" }, { k: "Idot", v: "\xC4\xB0" }, { k: "Ifr", v: "\xE2\x84\x91" }, { k: "Igrave", v: "\xC3\x8C" }, { k: "Im", v: "\xE2\x84\x91" }, { k: "Imacr", v: "\xC4\xAA" }, { k: "ImaginaryI", v: "\xE2\x85\x88" }, { k: "Implies", v: "\xE2\x87\x92" }, { k: "Int", v: "\xE2\x88\xAC" }, { k: "Integral", v: "\xE2\x88\xAB" }, { k: "Intersection", v: "\xE2\x8B\x82" }, { k: "InvisibleComma", v: "\xE2\x81\xA3" }, { k: "InvisibleTimes", v: "\xE2\x81\xA2" }, { k: "Iogon", v: "\xC4\xAE" }, { k: "Iopf", v: "\xF0\x9D\x95\x80" }, { k: "Iota", v: "\xCE\x99" }, { k: "Iscr", v: "\xE2\x84\x90" }, { k: "Itilde", v: "\xC4\xA8" }, { k: "Iukcy", v: "\xD0\x86" }, { k: "Iuml", v: "\xC3\x8F" }, { k: "Jcirc", v: "\xC4\xB4" }, { k: "Jcy", v: "\xD0\x99" }, { k: "Jfr", v: "\xF0\x9D\x94\x8D" }, { k: "Jopf", v: "\xF0\x9D\x95\x81" }, { k: "Jscr", v: "\xF0\x9D\x92\xA5" }, { k: "Jsercy", v: "\xD0\x88" }, { k: "Jukcy", v: "\xD0\x84" }, { k: "KHcy", v: "\xD0\xA5" }, { k: "KJcy", v: "\xD0\x8C" }, { k: "Kappa", v: "\xCE\x9A" }, { k: "Kcedil", v: "\xC4\xB6" }, { k: "Kcy", v: "\xD0\x9A" }, { k: "Kfr", v: "\xF0\x9D\x94\x8E" }, { k: "Kopf", v: "\xF0\x9D\x95\x82" }, { k: "Kscr", v: "\xF0\x9D\x92\xA6" }, { k: "LJcy", v: "\xD0\x89" }, { k: "LT", v: "<" }, { k: "Lacute", v: "\xC4\xB9" }, { k: "Lambda", v: "\xCE\x9B" }, { k: "Lang", v: "\xE2\x9F\xAA" }, { k: "Laplacetrf", v: "\xE2\x84\x92" }, { k: "Larr", v: "\xE2\x86\x9E" }, { k: "Lcaron", v: "\xC4\xBD" }, { k: "Lcedil", v: "\xC4\xBB" }, { k: "Lcy", v: "\xD0\x9B" }, { k: "LeftAngleBracket", v: "\xE2\x9F\xA8" }, { k: "LeftArrow", v: "\xE2\x86\x90" }, { k: "LeftArrowBar", v: "\xE2\x87\xA4" }, { k: "LeftArrowRightArrow", v: "\xE2\x87\x86" }, { k: "LeftCeiling", v: "\xE2\x8C\x88" }, { k: "LeftDoubleBracket", v: "\xE2\x9F\xA6" }, { k: "LeftDownTeeVector", v: "\xE2\xA5\xA1" }, { k: "LeftDownVector", v: "\xE2\x87\x83" }, { k: "LeftDownVectorBar", v: "\xE2\xA5\x99" }, { k: "LeftFloor", v: "\xE2\x8C\x8A" }, { k: "LeftRightArrow", v: "\xE2\x86\x94" }, { k: "LeftRightVector", v: "\xE2\xA5\x8E" }, { k: "LeftTee", v: "\xE2\x8A\xA3" }, { k: "LeftTeeArrow", v: "\xE2\x86\xA4" }, { k: "LeftTeeVector", v: "\xE2\xA5\x9A" }, { k: "LeftTriangle", v: "\xE2\x8A\xB2" }, { k: "LeftTriangleBar", v: "\xE2\xA7\x8F" }, { k: "LeftTriangleEqual", v: "\xE2\x8A\xB4" }, { k: "LeftUpDownVector", v: "\xE2\xA5\x91" }, { k: "LeftUpTeeVector", v: "\xE2\xA5\xA0" }, { k: "LeftUpVector", v: "\xE2\x86\xBF" }, { k: "LeftUpVectorBar", v: "\xE2\xA5\x98" }, { k: "LeftVector", v: "\xE2\x86\xBC" }, { k: "LeftVectorBar", v: "\xE2\xA5\x92" }, { k: "Leftarrow", v: "\xE2\x87\x90" }, { k: "Leftrightarrow", v: "\xE2\x87\x94" }, { k: "LessEqualGreater", v: "\xE2\x8B\x9A" }, { k: "LessFullEqual", v: "\xE2\x89\xA6" }, { k: "LessGreater", v: "\xE2\x89\xB6" }, { k: "LessLess", v: "\xE2\xAA\xA1" }, { k: "LessSlantEqual", v: "\xE2\xA9\xBD" }, { k: "LessTilde", v: "\xE2\x89\xB2" }, { k: "Lfr", v: "\xF0\x9D\x94\x8F" }, { k: "Ll", v: "\xE2\x8B\x98" }, { k: "Lleftarrow", v: "\xE2\x87\x9A" }, { k: "Lmidot", v: "\xC4\xBF" }, { k: "LongLeftArrow", v: "\xE2\x9F\xB5" }, { k: "LongLeftRightArrow", v: "\xE2\x9F\xB7" }, { k: "LongRightArrow", v: "\xE2\x9F\xB6" }, { k: "Longleftarrow", v: "\xE2\x9F\xB8" }, { k: "Longleftrightarrow", v: "\xE2\x9F\xBA" }, { k: "Longrightarrow", v: "\xE2\x9F\xB9" }, { k: "Lopf", v: "\xF0\x9D\x95\x83" }, { k: "LowerLeftArrow", v: "\xE2\x86\x99" }, { k: "LowerRightArrow", v: "\xE2\x86\x98" }, { k: "Lscr", v: "\xE2\x84\x92" }, { k: "Lsh", v: "\xE2\x86\xB0" }, { k: "Lstrok", v: "\xC5\x81" }, { k: "Lt", v: "\xE2\x89\xAA" }, { k: "Map", v: "\xE2\xA4\x85" }, { k: "Mcy", v: "\xD0\x9C" }, { k: "MediumSpace", v: "\xE2\x81\x9F" }, { k: "Mellintrf", v: "\xE2\x84\xB3" }, { k: "Mfr", v: "\xF0\x9D\x94\x90" }, { k: "MinusPlus", v: "\xE2\x88\x93" }, { k: "Mopf", v: "\xF0\x9D\x95\x84" }, { k: "Mscr", v: "\xE2\x84\xB3" }, { k: "Mu", v: "\xCE\x9C" }, { k: "NJcy", v: "\xD0\x8A" }, { k: "Nacute", v: "\xC5\x83" }, { k: "Ncaron", v: "\xC5\x87" }, { k: "Ncedil", v: "\xC5\x85" }, { k: "Ncy", v: "\xD0\x9D" }, { k: "NegativeMediumSpace", v: "\xE2\x80\x8B" }, { k: "NegativeThickSpace", v: "\xE2\x80\x8B" }, { k: "NegativeThinSpace", v: "\xE2\x80\x8B" }, { k: "NegativeVeryThinSpace", v: "\xE2\x80\x8B" }, { k: "NestedGreaterGreater", v: "\xE2\x89\xAB" }, { k: "NestedLessLess", v: "\xE2\x89\xAA" }, { k: "NewLine", v: "\n" }, { k: "Nfr", v: "\xF0\x9D\x94\x91" }, { k: "NoBreak", v: "\xE2\x81\xA0" }, { k: "NonBreakingSpace", v: "\xC2\xA0" }, { k: "Nopf", v: "\xE2\x84\x95" }, { k: "Not", v: "\xE2\xAB\xAC" }, { k: "NotCongruent", v: "\xE2\x89\xA2" }, { k: "NotCupCap", v: "\xE2\x89\xAD" }, { k: "NotDoubleVerticalBar", v: "\xE2\x88\xA6" }, { k: "NotElement", v: "\xE2\x88\x89" }, { k: "NotEqual", v: "\xE2\x89\xA0" }, { k: "NotEqualTilde", v: "\xE2\x89\x82\xCC\xB8" }, { k: "NotExists", v: "\xE2\x88\x84" }, { k: "NotGreater", v: "\xE2\x89\xAF" }, { k: "NotGreaterEqual", v: "\xE2\x89\xB1" }, { k: "NotGreaterFullEqual", v: "\xE2\x89\xA7\xCC\xB8" }, { k: "NotGreaterGreater", v: "\xE2\x89\xAB\xCC\xB8" }, { k: "NotGreaterLess", v: "\xE2\x89\xB9" }, { k: "NotGreaterSlantEqual", v: "\xE2\xA9\xBE\xCC\xB8" }, { k: "NotGreaterTilde", v: "\xE2\x89\xB5" }, { k: "NotHumpDownHump", v: "\xE2\x89\x8E\xCC\xB8" }, { k: "NotHumpEqual", v: "\xE2\x89\x8F\xCC\xB8" }, { k: "NotLeftTriangle", v: "\xE2\x8B\xAA" }, { k: "NotLeftTriangleBar", v: "\xE2\xA7\x8F\xCC\xB8" }, { k: "NotLeftTriangleEqual", v: "\xE2\x8B\xAC" }, { k: "NotLess", v: "\xE2\x89\xAE" }, { k: "NotLessEqual", v: "\xE2\x89\xB0" }, { k: "NotLessGreater", v: "\xE2\x89\xB8" }, { k: "NotLessLess", v: "\xE2\x89\xAA\xCC\xB8" }, { k: "NotLessSlantEqual", v: "\xE2\xA9\xBD\xCC\xB8" }, { k: "NotLessTilde", v: "\xE2\x89\xB4" }, { k: "NotNestedGreaterGreater", v: "\xE2\xAA\xA2\xCC\xB8" }, { k: "NotNestedLessLess", v: "\xE2\xAA\xA1\xCC\xB8" }, { k: "NotPrecedes", v: "\xE2\x8A\x80" }, { k: "NotPrecedesEqual", v: "\xE2\xAA\xAF\xCC\xB8" }, { k: "NotPrecedesSlantEqual", v: "\xE2\x8B\xA0" }, { k: "NotReverseElement", v: "\xE2\x88\x8C" }, { k: "NotRightTriangle", v: "\xE2\x8B\xAB" }, { k: "NotRightTriangleBar", v: "\xE2\xA7\x90\xCC\xB8" }, { k: "NotRightTriangleEqual", v: "\xE2\x8B\xAD" }, { k: "NotSquareSubset", v: "\xE2\x8A\x8F\xCC\xB8" }, { k: "NotSquareSubsetEqual", v: "\xE2\x8B\xA2" }, { k: "NotSquareSuperset", v: "\xE2\x8A\x90\xCC\xB8" }, { k: "NotSquareSupersetEqual", v: "\xE2\x8B\xA3" }, { k: "NotSubset", v: "\xE2\x8A\x82\xE2\x83\x92" }, { k: "NotSubsetEqual", v: "\xE2\x8A\x88" }, { k: "NotSucceeds", v: "\xE2\x8A\x81" }, { k: "NotSucceedsEqual", v: "\xE2\xAA\xB0\xCC\xB8" }, { k: "NotSucceedsSlantEqual", v: "\xE2\x8B\xA1" }, { k: "NotSucceedsTilde", v: "\xE2\x89\xBF\xCC\xB8" }, { k: "NotSuperset", v: "\xE2\x8A\x83\xE2\x83\x92" }, { k: "NotSupersetEqual", v: "\xE2\x8A\x89" }, { k: "NotTilde", v: "\xE2\x89\x81" }, { k: "NotTildeEqual", v: "\xE2\x89\x84" }, { k: "NotTildeFullEqual", v: "\xE2\x89\x87" }, { k: "NotTildeTilde", v: "\xE2\x89\x89" }, { k: "NotVerticalBar", v: "\xE2\x88\xA4" }, { k: "Nscr", v: "\xF0\x9D\x92\xA9" }, { k: "Ntilde", v: "\xC3\x91" }, { k: "Nu", v: "\xCE\x9D" }, { k: "OElig", v: "\xC5\x92" }, { k: "Oacute", v: "\xC3\x93" }, { k: "Ocirc", v: "\xC3\x94" }, { k: "Ocy", v: "\xD0\x9E" }, { k: "Odblac", v: "\xC5\x90" }, { k: "Ofr", v: "\xF0\x9D\x94\x92" }, { k: "Ograve", v: "\xC3\x92" }, { k: "Omacr", v: "\xC5\x8C" }, { k: "Omega", v: "\xCE\xA9" }, { k: "Omicron", v: "\xCE\x9F" }, { k: "Oopf", v: "\xF0\x9D\x95\x86" }, { k: "OpenCurlyDoubleQuote", v: "\xE2\x80\x9C" }, { k: "OpenCurlyQuote", v: "\xE2\x80\x98" }, { k: "Or", v: "\xE2\xA9\x94" }, { k: "Oscr", v: "\xF0\x9D\x92\xAA" }, { k: "Oslash", v: "\xC3\x98" }, { k: "Otilde", v: "\xC3\x95" }, { k: "Otimes", v: "\xE2\xA8\xB7" }, { k: "Ouml", v: "\xC3\x96" }, { k: "OverBar", v: "\xE2\x80\xBE" }, { k: "OverBrace", v: "\xE2\x8F\x9E" }, { k: "OverBracket", v: "\xE2\x8E\xB4" }, { k: "OverParenthesis", v: "\xE2\x8F\x9C" }, { k: "PartialD", v: "\xE2\x88\x82" }, { k: "Pcy", v: "\xD0\x9F" }, { k: "Pfr", v: "\xF0\x9D\x94\x93" }, { k: "Phi", v: "\xCE\xA6" }, { k: "Pi", v: "\xCE\xA0" }, { k: "PlusMinus", v: "\xC2\xB1" }, { k: "Poincareplane", v: "\xE2\x84\x8C" }, { k: "Popf", v: "\xE2\x84\x99" }, { k: "Pr", v: "\xE2\xAA\xBB" }, { k: "Precedes", v: "\xE2\x89\xBA" }, { k: "PrecedesEqual", v: "\xE2\xAA\xAF" }, { k: "PrecedesSlantEqual", v: "\xE2\x89\xBC" }, { k: "PrecedesTilde", v: "\xE2\x89\xBE" }, { k: "Prime", v: "\xE2\x80\xB3" }, { k: "Product", v: "\xE2\x88\x8F" }, { k: "Proportion", v: "\xE2\x88\xB7" }, { k: "Proportional", v: "\xE2\x88\x9D" }, { k: "Pscr", v: "\xF0\x9D\x92\xAB" }, { k: "Psi", v: "\xCE\xA8" }, { k: "QUOT", v: "\"" }, { k: "Qfr", v: "\xF0\x9D\x94\x94" }, { k: "Qopf", v: "\xE2\x84\x9A" }, { k: "Qscr", v: "\xF0\x9D\x92\xAC" }, { k: "RBarr", v: "\xE2\xA4\x90" }, { k: "REG", v: "\xC2\xAE" }, { k: "Racute", v: "\xC5\x94" }, { k: "Rang", v: "\xE2\x9F\xAB" }, { k: "Rarr", v: "\xE2\x86\xA0" }, { k: "Rarrtl", v: "\xE2\xA4\x96" }, { k: "Rcaron", v: "\xC5\x98" }, { k: "Rcedil", v: "\xC5\x96" }, { k: "Rcy", v: "\xD0\xA0" }, { k: "Re", v: "\xE2\x84\x9C" }, { k: "ReverseElement", v: "\xE2\x88\x8B" }, { k: "ReverseEquilibrium", v: "\xE2\x87\x8B" }, { k: "ReverseUpEquilibrium", v: "\xE2\xA5\xAF" }, { k: "Rfr", v: "\xE2\x84\x9C" }, { k: "Rho", v: "\xCE\xA1" }, { k: "RightAngleBracket", v: "\xE2\x9F\xA9" }, { k: "RightArrow", v: "\xE2\x86\x92" }, { k: "RightArrowBar", v: "\xE2\x87\xA5" }, { k: "RightArrowLeftArrow", v: "\xE2\x87\x84" }, { k: "RightCeiling", v: "\xE2\x8C\x89" }, { k: "RightDoubleBracket", v: "\xE2\x9F\xA7" }, { k: "RightDownTeeVector", v: "\xE2\xA5\x9D" }, { k: "RightDownVector", v: "\xE2\x87\x82" }, { k: "RightDownVectorBar", v: "\xE2\xA5\x95" }, { k: "RightFloor", v: "\xE2\x8C\x8B" }, { k: "RightTee", v: "\xE2\x8A\xA2" }, { k: "RightTeeArrow", v: "\xE2\x86\xA6" }, { k: "RightTeeVector", v: "\xE2\xA5\x9B" }, { k: "RightTriangle", v: "\xE2\x8A\xB3" }, { k: "RightTriangleBar", v: "\xE2\xA7\x90" }, { k: "RightTriangleEqual", v: "\xE2\x8A\xB5" }, { k: "RightUpDownVector", v: "\xE2\xA5\x8F" }, { k: "RightUpTeeVector", v: "\xE2\xA5\x9C" }, { k: "RightUpVector", v: "\xE2\x86\xBE" }, { k: "RightUpVectorBar", v: "\xE2\xA5\x94" }, { k: "RightVector", v: "\xE2\x87\x80" }, { k: "RightVectorBar", v: "\xE2\xA5\x93" }, { k: "Rightarrow", v: "\xE2\x87\x92" }, { k: "Ropf", v: "\xE2\x84\x9D" }, { k: "RoundImplies", v: "\xE2\xA5\xB0" }, { k: "Rrightarrow", v: "\xE2\x87\x9B" }, { k: "Rscr", v: "\xE2\x84\x9B" }, { k: "Rsh", v: "\xE2\x86\xB1" }, { k: "RuleDelayed", v: "\xE2\xA7\xB4" }, { k: "SHCHcy", v: "\xD0\xA9" }, { k: "SHcy", v: "\xD0\xA8" }, { k: "SOFTcy", v: "\xD0\xAC" }, { k: "Sacute", v: "\xC5\x9A" }, { k: "Sc", v: "\xE2\xAA\xBC" }, { k: "Scaron", v: "\xC5\xA0" }, { k: "Scedil", v: "\xC5\x9E" }, { k: "Scirc", v: "\xC5\x9C" }, { k: "Scy", v: "\xD0\xA1" }, { k: "Sfr", v: "\xF0\x9D\x94\x96" }, { k: "ShortDownArrow", v: "\xE2\x86\x93" }, { k: "ShortLeftArrow", v: "\xE2\x86\x90" }, { k: "ShortRightArrow", v: "\xE2\x86\x92" }, { k: "ShortUpArrow", v: "\xE2\x86\x91" }, { k: "Sigma", v: "\xCE\xA3" }, { k: "SmallCircle", v: "\xE2\x88\x98" }, { k: "Sopf", v: "\xF0\x9D\x95\x8A" }, { k: "Sqrt", v: "\xE2\x88\x9A" }, { k: "Square", v: "\xE2\x96\xA1" }, { k: "SquareIntersection", v: "\xE2\x8A\x93" }, { k: "SquareSubset", v: "\xE2\x8A\x8F" }, { k: "SquareSubsetEqual", v: "\xE2\x8A\x91" }, { k: "SquareSuperset", v: "\xE2\x8A\x90" }, { k: "SquareSupersetEqual", v: "\xE2\x8A\x92" }, { k: "SquareUnion", v: "\xE2\x8A\x94" }, { k: "Sscr", v: "\xF0\x9D\x92\xAE" }, { k: "Star", v: "\xE2\x8B\x86" }, { k: "Sub", v: "\xE2\x8B\x90" }, { k: "Subset", v: "\xE2\x8B\x90" }, { k: "SubsetEqual", v: "\xE2\x8A\x86" }, { k: "Succeeds", v: "\xE2\x89\xBB" }, { k: "SucceedsEqual", v: "\xE2\xAA\xB0" }, { k: "SucceedsSlantEqual", v: "\xE2\x89\xBD" }, { k: "SucceedsTilde", v: "\xE2\x89\xBF" }, { k: "SuchThat", v: "\xE2\x88\x8B" }, { k: "Sum", v: "\xE2\x88\x91" }, { k: "Sup", v: "\xE2\x8B\x91" }, { k: "Superset", v: "\xE2\x8A\x83" }, { k: "SupersetEqual", v: "\xE2\x8A\x87" }, { k: "Supset", v: "\xE2\x8B\x91" }, { k: "THORN", v: "\xC3\x9E" }, { k: "TRADE", v: "\xE2\x84\xA2" }, { k: "TSHcy", v: "\xD0\x8B" }, { k: "TScy", v: "\xD0\xA6" }, { k: "Tab", v: "\t" }, { k: "Tau", v: "\xCE\xA4" }, { k: "Tcaron", v: "\xC5\xA4" }, { k: "Tcedil", v: "\xC5\xA2" }, { k: "Tcy", v: "\xD0\xA2" }, { k: "Tfr", v: "\xF0\x9D\x94\x97" }, { k: "Therefore", v: "\xE2\x88\xB4" }, { k: "Theta", v: "\xCE\x98" }, { k: "ThickSpace", v: "\xE2\x81\x9F\xE2\x80\x8A" }, { k: "ThinSpace", v: "\xE2\x80\x89" }, { k: "Tilde", v: "\xE2\x88\xBC" }, { k: "TildeEqual", v: "\xE2\x89\x83" }, { k: "TildeFullEqual", v: "\xE2\x89\x85" }, { k: "TildeTilde", v: "\xE2\x89\x88" }, { k: "Topf", v: "\xF0\x9D\x95\x8B" }, { k: "TripleDot", v: "\xE2\x83\x9B" }, { k: "Tscr", v: "\xF0\x9D\x92\xAF" }, { k: "Tstrok", v: "\xC5\xA6" }, { k: "Uacute", v: "\xC3\x9A" }, { k: "Uarr", v: "\xE2\x86\x9F" }, { k: "Uarrocir", v: "\xE2\xA5\x89" }, { k: "Ubrcy", v: "\xD0\x8E" }, { k: "Ubreve", v: "\xC5\xAC" }, { k: "Ucirc", v: "\xC3\x9B" }, { k: "Ucy", v: "\xD0\xA3" }, { k: "Udblac", v: "\xC5\xB0" }, { k: "Ufr", v: "\xF0\x9D\x94\x98" }, { k: "Ugrave", v: "\xC3\x99" }, { k: "Umacr", v: "\xC5\xAA" }, { k: "UnderBar", v: "_" }, { k: "UnderBrace", v: "\xE2\x8F\x9F" }, { k: "UnderBracket", v: "\xE2\x8E\xB5" }, { k: "UnderParenthesis", v: "\xE2\x8F\x9D" }, { k: "Union", v: "\xE2\x8B\x83" }, { k: "UnionPlus", v: "\xE2\x8A\x8E" }, { k: "Uogon", v: "\xC5\xB2" }, { k: "Uopf", v: "\xF0\x9D\x95\x8C" }, { k: "UpArrow", v: "\xE2\x86\x91" }, { k: "UpArrowBar", v: "\xE2\xA4\x92" }, { k: "UpArrowDownArrow", v: "\xE2\x87\x85" }, { k: "UpDownArrow", v: "\xE2\x86\x95" }, { k: "UpEquilibrium", v: "\xE2\xA5\xAE" }, { k: "UpTee", v: "\xE2\x8A\xA5" }, { k: "UpTeeArrow", v: "\xE2\x86\xA5" }, { k: "Uparrow", v: "\xE2\x87\x91" }, { k: "Updownarrow", v: "\xE2\x87\x95" }, { k: "UpperLeftArrow", v: "\xE2\x86\x96" }, { k: "UpperRightArrow", v: "\xE2\x86\x97" }, { k: "Upsi", v: "\xCF\x92" }, { k: "Upsilon", v: "\xCE\xA5" }, { k: "Uring", v: "\xC5\xAE" }, { k: "Uscr", v: "\xF0\x9D\x92\xB0" }, { k: "Utilde", v: "\xC5\xA8" }, { k: "Uuml", v: "\xC3\x9C" }, { k: "VDash", v: "\xE2\x8A\xAB" }, { k: "Vbar", v: "\xE2\xAB\xAB" }, { k: "Vcy", v: "\xD0\x92" }, { k: "Vdash", v: "\xE2\x8A\xA9" }, { k: "Vdashl", v: "\xE2\xAB\xA6" }, { k: "Vee", v: "\xE2\x8B\x81" }, { k: "Verbar", v: "\xE2\x80\x96" }, { k: "Vert", v: "\xE2\x80\x96" }, { k: "VerticalBar", v: "\xE2\x88\xA3" }, { k: "VerticalLine", v: "|" }, { k: "VerticalSeparator", v: "\xE2\x9D\x98" }, { k: "VerticalTilde", v: "\xE2\x89\x80" }, { k: "VeryThinSpace", v: "\xE2\x80\x8A" }, { k: "Vfr", v: "\xF0\x9D\x94\x99" }, { k: "Vopf", v: "\xF0\x9D\x95\x8D" }, { k: "Vscr", v: "\xF0\x9D\x92\xB1" }, { k: "Vvdash", v: "\xE2\x8A\xAA" }, { k: "Wcirc", v: "\xC5\xB4" }, { k: "Wedge", v: "\xE2\x8B\x80" }, { k: "Wfr", v: "\xF0\x9D\x94\x9A" }, { k: "Wopf", v: "\xF0\x9D\x95\x8E" }, { k: "Wscr", v: "\xF0\x9D\x92\xB2" }, { k: "Xfr", v: "\xF0\x9D\x94\x9B" }, { k: "Xi", v: "\xCE\x9E" }, { k: "Xopf", v: "\xF0\x9D\x95\x8F" }, { k: "Xscr", v: "\xF0\x9D\x92\xB3" }, { k: "YAcy", v: "\xD0\xAF" }, { k: "YIcy", v: "\xD0\x87" }, { k: "YUcy", v: "\xD0\xAE" }, { k: "Yacute", v: "\xC3\x9D" }, { k: "Ycirc", v: "\xC5\xB6" }, { k: "Ycy", v: "\xD0\xAB" }, { k: "Yfr", v: "\xF0\x9D\x94\x9C" }, { k: "Yopf", v: "\xF0\x9D\x95\x90" }, { k: "Yscr", v: "\xF0\x9D\x92\xB4" }, { k: "Yuml", v: "\xC5\xB8" }, { k: "ZHcy", v: "\xD0\x96" }, { k: "Zacute", v: "\xC5\xB9" }, { k: "Zcaron", v: "\xC5\xBD" }, { k: "Zcy", v: "\xD0\x97" }, { k: "Zdot", v: "\xC5\xBB" }, { k: "ZeroWidthSpace", v: "\xE2\x80\x8B" }, { k: "Zeta", v: "\xCE\x96" }, { k: "Zfr", v: "\xE2\x84\xA8" }, { k: "Zopf", v: "\xE2\x84\xA4" }, { k: "Zscr", v: "\xF0\x9D\x92\xB5" }, { k: "aacute", v: "\xC3\xA1" }, { k: "abreve", v: "\xC4\x83" }, { k: "ac", v: "\xE2\x88\xBE" }, { k: "acE", v: "\xE2\x88\xBE\xCC\xB3" }, { k: "acd", v: "\xE2\x88\xBF" }, { k: "acirc", v: "\xC3\xA2" }, { k: "acute", v: "\xC2\xB4" }, { k: "acy", v: "\xD0\xB0" }, { k: "aelig", v: "\xC3\xA6" }, { k: "af", v: "\xE2\x81\xA1" }, { k: "afr", v: "\xF0\x9D\x94\x9E" }, { k: "agrave", v: "\xC3\xA0" }, { k: "alefsym", v: "\xE2\x84\xB5" }, { k: "aleph", v: "\xE2\x84\xB5" }, { k: "alpha", v: "\xCE\xB1" }, { k: "amacr", v: "\xC4\x81" }, { k: "amalg", v: "\xE2\xA8\xBF" }, { k: "amp", v: "&" }, { k: "and", v: "\xE2\x88\xA7" }, { k: "andand", v: "\xE2\xA9\x95" }, { k: "andd", v: "\xE2\xA9\x9C" }, { k: "andslope", v: "\xE2\xA9\x98" }, { k: "andv", v: "\xE2\xA9\x9A" }, { k: "ang", v: "\xE2\x88\xA0" }, { k: "ange", v: "\xE2\xA6\xA4" }, { k: "angle", v: "\xE2\x88\xA0" }, { k: "angmsd", v: "\xE2\x88\xA1" }, { k: "angmsdaa", v: "\xE2\xA6\xA8" }, { k: "angmsdab", v: "\xE2\xA6\xA9" }, { k: "angmsdac", v: "\xE2\xA6\xAA" }, { k: "angmsdad", v: "\xE2\xA6\xAB" }, { k: "angmsdae", v: "\xE2\xA6\xAC" }, { k: "angmsdaf", v: "\xE2\xA6\xAD" }, { k: "angmsdag", v: "\xE2\xA6\xAE" }, { k: "angmsdah", v: "\xE2\xA6\xAF" }, { k: "angrt", v: "\xE2\x88\x9F" }, { k: "angrtvb", v: "\xE2\x8A\xBE" }, { k: "angrtvbd", v: "\xE2\xA6\x9D" }, { k: "angsph", v: "\xE2\x88\xA2" }, { k: "angst", v: "\xC3\x85" }, { k: "angzarr", v: "\xE2\x8D\xBC" }, { k: "aogon", v: "\xC4\x85" }, { k: "aopf", v: "\xF0\x9D\x95\x92" }, { k: "ap", v: "\xE2\x89\x88" }, { k: "apE", v: "\xE2\xA9\xB0" }, { k: "apacir", v: "\xE2\xA9\xAF" }, { k: "ape", v: "\xE2\x89\x8A" }, { k: "apid", v: "\xE2\x89\x8B" }, { k: "apos", v: "'" }, { k: "approx", v: "\xE2\x89\x88" }, { k: "approxeq", v: "\xE2\x89\x8A" }, { k: "aring", v: "\xC3\xA5" }, { k: "ascr", v: "\xF0\x9D\x92\xB6" }, { k: "ast", v: "*" }, { k: "asymp", v: "\xE2\x89\x88" }, { k: "asympeq", v: "\xE2\x89\x8D" }, { k: "atilde", v: "\xC3\xA3" }, { k: "auml", v: "\xC3\xA4" }, { k: "awconint", v: "\xE2\x88\xB3" }, { k: "awint", v: "\xE2\xA8\x91" }, { k: "bNot", v: "\xE2\xAB\xAD" }, { k: "backcong", v: "\xE2\x89\x8C" }, { k: "backepsilon", v: "\xCF\xB6" }, { k: "backprime", v: "\xE2\x80\xB5" }, { k: "backsim", v: "\xE2\x88\xBD" }, { k: "backsimeq", v: "\xE2\x8B\x8D" }, { k: "barvee", v: "\xE2\x8A\xBD" }, { k: "barwed", v: "\xE2\x8C\x85" }, { k: "barwedge", v: "\xE2\x8C\x85" }, { k: "bbrk", v: "\xE2\x8E\xB5" }, { k: "bbrktbrk", v: "\xE2\x8E\xB6" }, { k: "bcong", v: "\xE2\x89\x8C" }, { k: "bcy", v: "\xD0\xB1" }, { k: "bdquo", v: "\xE2\x80\x9E" }, { k: "becaus", v: "\xE2\x88\xB5" }, { k: "because", v: "\xE2\x88\xB5" }, { k: "bemptyv", v: "\xE2\xA6\xB0" }, { k: "bepsi", v: "\xCF\xB6" }, { k: "bernou", v: "\xE2\x84\xAC" }, { k: "beta", v: "\xCE\xB2" }, { k: "beth", v: "\xE2\x84\xB6" }, { k: "between", v: "\xE2\x89\xAC" }, { k: "bfr", v: "\xF0\x9D\x94\x9F" }, { k: "bigcap", v: "\xE2\x8B\x82" }, { k: "bigcirc", v: "\xE2\x97\xAF" }, { k: "bigcup", v: "\xE2\x8B\x83" }, { k: "bigodot", v: "\xE2\xA8\x80" }, { k: "bigoplus", v: "\xE2\xA8\x81" }, { k: "bigotimes", v: "\xE2\xA8\x82" }, { k: "bigsqcup", v: "\xE2\xA8\x86" }, { k: "bigstar", v: "\xE2\x98\x85" }, { k: "bigtriangledown", v: "\xE2\x96\xBD" }, { k: "bigtriangleup", v: "\xE2\x96\xB3" }, { k: "biguplus", v: "\xE2\xA8\x84" }, { k: "bigvee", v: "\xE2\x8B\x81" }, { k: "bigwedge", v: "\xE2\x8B\x80" }, { k: "bkarow", v: "\xE2\xA4\x8D" }, { k: "blacklozenge", v: "\xE2\xA7\xAB" }, { k: "blacksquare", v: "\xE2\x96\xAA" }, { k: "blacktriangle", v: "\xE2\x96\xB4" }, { k: "blacktriangledown", v: "\xE2\x96\xBE" }, { k: "blacktriangleleft", v: "\xE2\x97\x82" }, { k: "blacktriangleright", v: "\xE2\x96\xB8" }, { k: "blank", v: "\xE2\x90\xA3" }, { k: "blk12", v: "\xE2\x96\x92" }, { k: "blk14", v: "\xE2\x96\x91" }, { k: "blk34", v: "\xE2\x96\x93" }, { k: "block", v: "\xE2\x96\x88" }, { k: "bne", v: "=\xE2\x83\xA5" }, { k: "bnequiv", v: "\xE2\x89\xA1\xE2\x83\xA5" }, { k: "bnot", v: "\xE2\x8C\x90" }, { k: "bopf", v: "\xF0\x9D\x95\x93" }, { k: "bot", v: "\xE2\x8A\xA5" }, { k: "bottom", v: "\xE2\x8A\xA5" }, { k: "bowtie", v: "\xE2\x8B\x88" }, { k: "boxDL", v: "\xE2\x95\x97" }, { k: "boxDR", v: "\xE2\x95\x94" }, { k: "boxDl", v: "\xE2\x95\x96" }, { k: "boxDr", v: "\xE2\x95\x93" }, { k: "boxH", v: "\xE2\x95\x90" }, { k: "boxHD", v: "\xE2\x95\xA6" }, { k: "boxHU", v: "\xE2\x95\xA9" }, { k: "boxHd", v: "\xE2\x95\xA4" }, { k: "boxHu", v: "\xE2\x95\xA7" }, { k: "boxUL", v: "\xE2\x95\x9D" }, { k: "boxUR", v: "\xE2\x95\x9A" }, { k: "boxUl", v: "\xE2\x95\x9C" }, { k: "boxUr", v: "\xE2\x95\x99" }, { k: "boxV", v: "\xE2\x95\x91" }, { k: "boxVH", v: "\xE2\x95\xAC" }, { k: "boxVL", v: "\xE2\x95\xA3" }, { k: "boxVR", v: "\xE2\x95\xA0" }, { k: "boxVh", v: "\xE2\x95\xAB" }, { k: "boxVl", v: "\xE2\x95\xA2" }, { k: "boxVr", v: "\xE2\x95\x9F" }, { k: "boxbox", v: "\xE2\xA7\x89" }, { k: "boxdL", v: "\xE2\x95\x95" }, { k: "boxdR", v: "\xE2\x95\x92" }, { k: "boxdl", v: "\xE2\x94\x90" }, { k: "boxdr", v: "\xE2\x94\x8C" }, { k: "boxh", v: "\xE2\x94\x80" }, { k: "boxhD", v: "\xE2\x95\xA5" }, { k: "boxhU", v: "\xE2\x95\xA8" }, { k: "boxhd", v: "\xE2\x94\xAC" }, { k: "boxhu", v: "\xE2\x94\xB4" }, { k: "boxminus", v: "\xE2\x8A\x9F" }, { k: "boxplus", v: "\xE2\x8A\x9E" }, { k: "boxtimes", v: "\xE2\x8A\xA0" }, { k: "boxuL", v: "\xE2\x95\x9B" }, { k: "boxuR", v: "\xE2\x95\x98" }, { k: "boxul", v: "\xE2\x94\x98" }, { k: "boxur", v: "\xE2\x94\x94" }, { k: "boxv", v: "\xE2\x94\x82" }, { k: "boxvH", v: "\xE2\x95\xAA" }, { k: "boxvL", v: "\xE2\x95\xA1" }, { k: "boxvR", v: "\xE2\x95\x9E" }, { k: "boxvh", v: "\xE2\x94\xBC" }, { k: "boxvl", v: "\xE2\x94\xA4" }, { k: "boxvr", v: "\xE2\x94\x9C" }, { k: "bprime", v: "\xE2\x80\xB5" }, { k: "breve", v: "\xCB\x98" }, { k: "brvbar", v: "\xC2\xA6" }, { k: "bscr", v: "\xF0\x9D\x92\xB7" }, { k: "bsemi", v: "\xE2\x81\x8F" }, { k: "bsim", v: "\xE2\x88\xBD" }, { k: "bsime", v: "\xE2\x8B\x8D" }, { k: "bsol", v: "\\" }, { k: "bsolb", v: "\xE2\xA7\x85" }, { k: "bsolhsub", v: "\xE2\x9F\x88" }, { k: "bull", v: "\xE2\x80\xA2" }, { k: "bullet", v: "\xE2\x80\xA2" }, { k: "bump", v: "\xE2\x89\x8E" }, { k: "bumpE", v: "\xE2\xAA\xAE" }, { k: "bumpe", v: "\xE2\x89\x8F" }, { k: "bumpeq", v: "\xE2\x89\x8F" }, { k: "cacute", v: "\xC4\x87" }, { k: "cap", v: "\xE2\x88\xA9" }, { k: "capand", v: "\xE2\xA9\x84" }, { k: "capbrcup", v: "\xE2\xA9\x89" }, { k: "capcap", v: "\xE2\xA9\x8B" }, { k: "capcup", v: "\xE2\xA9\x87" }, { k: "capdot", v: "\xE2\xA9\x80" }, { k: "caps", v: "\xE2\x88\xA9\xEF\xB8\x80" }, { k: "caret", v: "\xE2\x81\x81" }, { k: "caron", v: "\xCB\x87" }, { k: "ccaps", v: "\xE2\xA9\x8D" }, { k: "ccaron", v: "\xC4\x8D" }, { k: "ccedil", v: "\xC3\xA7" }, { k: "ccirc", v: "\xC4\x89" }, { k: "ccups", v: "\xE2\xA9\x8C" }, { k: "ccupssm", v: "\xE2\xA9\x90" }, { k: "cdot", v: "\xC4\x8B" }, { k: "cedil", v: "\xC2\xB8" }, { k: "cemptyv", v: "\xE2\xA6\xB2" }, { k: "cent", v: "\xC2\xA2" }, { k: "centerdot", v: "\xC2\xB7" }, { k: "cfr", v: "\xF0\x9D\x94\xA0" }, { k: "chcy", v: "\xD1\x87" }, { k: "check", v: "\xE2\x9C\x93" }, { k: "checkmark", v: "\xE2\x9C\x93" }, { k: "chi", v: "\xCF\x87" }, { k: "cir", v: "\xE2\x97\x8B" }, { k: "cirE", v: "\xE2\xA7\x83" }, { k: "circ", v: "\xCB\x86" }, { k: "circeq", v: "\xE2\x89\x97" }, { k: "circlearrowleft", v: "\xE2\x86\xBA" }, { k: "circlearrowright", v: "\xE2\x86\xBB" }, { k: "circledR", v: "\xC2\xAE" }, { k: "circledS", v: "\xE2\x93\x88" }, { k: "circledast", v: "\xE2\x8A\x9B" }, { k: "circledcirc", v: "\xE2\x8A\x9A" }, { k: "circleddash", v: "\xE2\x8A\x9D" }, { k: "cire", v: "\xE2\x89\x97" }, { k: "cirfnint", v: "\xE2\xA8\x90" }, { k: "cirmid", v: "\xE2\xAB\xAF" }, { k: "cirscir", v: "\xE2\xA7\x82" }, { k: "clubs", v: "\xE2\x99\xA3" }, { k: "clubsuit", v: "\xE2\x99\xA3" }, { k: "colon", v: ":" }, { k: "colone", v: "\xE2\x89\x94" }, { k: "coloneq", v: "\xE2\x89\x94" }, { k: "comma", v: "," }, { k: "commat", v: "@" }, { k: "comp", v: "\xE2\x88\x81" }, { k: "compfn", v: "\xE2\x88\x98" }, { k: "complement", v: "\xE2\x88\x81" }, { k: "complexes", v: "\xE2\x84\x82" }, { k: "cong", v: "\xE2\x89\x85" }, { k: "congdot", v: "\xE2\xA9\xAD" }, { k: "conint", v: "\xE2\x88\xAE" }, { k: "copf", v: "\xF0\x9D\x95\x94" }, { k: "coprod", v: "\xE2\x88\x90" }, { k: "copy", v: "\xC2\xA9" }, { k: "copysr", v: "\xE2\x84\x97" }, { k: "crarr", v: "\xE2\x86\xB5" }, { k: "cross", v: "\xE2\x9C\x97" }, { k: "cscr", v: "\xF0\x9D\x92\xB8" }, { k: "csub", v: "\xE2\xAB\x8F" }, { k: "csube", v: "\xE2\xAB\x91" }, { k: "csup", v: "\xE2\xAB\x90" }, { k: "csupe", v: "\xE2\xAB\x92" }, { k: "ctdot", v: "\xE2\x8B\xAF" }, { k: "cudarrl", v: "\xE2\xA4\xB8" }, { k: "cudarrr", v: "\xE2\xA4\xB5" }, { k: "cuepr", v: "\xE2\x8B\x9E" }, { k: "cuesc", v: "\xE2\x8B\x9F" }, { k: "cularr", v: "\xE2\x86\xB6" }, { k: "cularrp", v: "\xE2\xA4\xBD" }, { k: "cup", v: "\xE2\x88\xAA" }, { k: "cupbrcap", v: "\xE2\xA9\x88" }, { k: "cupcap", v: "\xE2\xA9\x86" }, { k: "cupcup", v: "\xE2\xA9\x8A" }, { k: "cupdot", v: "\xE2\x8A\x8D" }, { k: "cupor", v: "\xE2\xA9\x85" }, { k: "cups", v: "\xE2\x88\xAA\xEF\xB8\x80" }, { k: "curarr", v: "\xE2\x86\xB7" }, { k: "curarrm", v: "\xE2\xA4\xBC" }, { k: "curlyeqprec", v: "\xE2\x8B\x9E" }, { k: "curlyeqsucc", v: "\xE2\x8B\x9F" }, { k: "curlyvee", v: "\xE2\x8B\x8E" }, { k: "curlywedge", v: "\xE2\x8B\x8F" }, { k: "curren", v: "\xC2\xA4" }, { k: "curvearrowleft", v: "\xE2\x86\xB6" }, { k: "curvearrowright", v: "\xE2\x86\xB7" }, { k: "cuvee", v: "\xE2\x8B\x8E" }, { k: "cuwed", v: "\xE2\x8B\x8F" }, { k: "cwconint", v: "\xE2\x88\xB2" }, { k: "cwint", v: "\xE2\x88\xB1" }, { k: "cylcty", v: "\xE2\x8C\xAD" }, { k: "dArr", v: "\xE2\x87\x93" }, { k: "dHar", v: "\xE2\xA5\xA5" }, { k: "dagger", v: "\xE2\x80\xA0" }, { k: "daleth", v: "\xE2\x84\xB8" }, { k: "darr", v: "\xE2\x86\x93" }, { k: "dash", v: "\xE2\x80\x90" }, { k: "dashv", v: "\xE2\x8A\xA3" }, { k: "dbkarow", v: "\xE2\xA4\x8F" }, { k: "dblac", v: "\xCB\x9D" }, { k: "dcaron", v: "\xC4\x8F" }, { k: "dcy", v: "\xD0\xB4" }, { k: "dd", v: "\xE2\x85\x86" }, { k: "ddagger", v: "\xE2\x80\xA1" }, { k: "ddarr", v: "\xE2\x87\x8A" }, { k: "ddotseq", v: "\xE2\xA9\xB7" }, { k: "deg", v: "\xC2\xB0" }, { k: "delta", v: "\xCE\xB4" }, { k: "demptyv", v: "\xE2\xA6\xB1" }, { k: "dfisht", v: "\xE2\xA5\xBF" }, { k: "dfr", v: "\xF0\x9D\x94\xA1" }, { k: "dharl", v: "\xE2\x87\x83" }, { k: "dharr", v: "\xE2\x87\x82" }, { k: "diam", v: "\xE2\x8B\x84" }, { k: "diamond", v: "\xE2\x8B\x84" }, { k: "diamondsuit", v: "\xE2\x99\xA6" }, { k: "diams", v: "\xE2\x99\xA6" }, { k: "die", v: "\xC2\xA8" }, { k: "digamma", v: "\xCF\x9D" }, { k: "disin", v: "\xE2\x8B\xB2" }, { k: "div", v: "\xC3\xB7" }, { k: "divide", v: "\xC3\xB7" }, { k: "divideontimes", v: "\xE2\x8B\x87" }, { k: "divonx", v: "\xE2\x8B\x87" }, { k: "djcy", v: "\xD1\x92" }, { k: "dlcorn", v: "\xE2\x8C\x9E" }, { k: "dlcrop", v: "\xE2\x8C\x8D" }, { k: "dollar", v: "$" }, { k: "dopf", v: "\xF0\x9D\x95\x95" }, { k: "dot", v: "\xCB\x99" }, { k: "doteq", v: "\xE2\x89\x90" }, { k: "doteqdot", v: "\xE2\x89\x91" }, { k: "dotminus", v: "\xE2\x88\xB8" }, { k: "dotplus", v: "\xE2\x88\x94" }, { k: "dotsquare", v: "\xE2\x8A\xA1" }, { k: "doublebarwedge", v: "\xE2\x8C\x86" }, { k: "downarrow", v: "\xE2\x86\x93" }, { k: "downdownarrows", v: "\xE2\x87\x8A" }, { k: "downharpoonleft", v: "\xE2\x87\x83" }, { k: "downharpoonright", v: "\xE2\x87\x82" }, { k: "drbkarow", v: "\xE2\xA4\x90" }, { k: "drcorn", v: "\xE2\x8C\x9F" }, { k: "drcrop", v: "\xE2\x8C\x8C" }, { k: "dscr", v: "\xF0\x9D\x92\xB9" }, { k: "dscy", v: "\xD1\x95" }, { k: "dsol", v: "\xE2\xA7\xB6" }, { k: "dstrok", v: "\xC4\x91" }, { k: "dtdot", v: "\xE2\x8B\xB1" }, { k: "dtri", v: "\xE2\x96\xBF" }, { k: "dtrif", v: "\xE2\x96\xBE" }, { k: "duarr", v: "\xE2\x87\xB5" }, { k: "duhar", v: "\xE2\xA5\xAF" }, { k: "dwangle", v: "\xE2\xA6\xA6" }, { k: "dzcy", v: "\xD1\x9F" }, { k: "dzigrarr", v: "\xE2\x9F\xBF" }, { k: "eDDot", v: "\xE2\xA9\xB7" }, { k: "eDot", v: "\xE2\x89\x91" }, { k: "eacute", v: "\xC3\xA9" }, { k: "easter", v: "\xE2\xA9\xAE" }, { k: "ecaron", v: "\xC4\x9B" }, { k: "ecir", v: "\xE2\x89\x96" }, { k: "ecirc", v: "\xC3\xAA" }, { k: "ecolon", v: "\xE2\x89\x95" }, { k: "ecy", v: "\xD1\x8D" }, { k: "edot", v: "\xC4\x97" }, { k: "ee", v: "\xE2\x85\x87" }, { k: "efDot", v: "\xE2\x89\x92" }, { k: "efr", v: "\xF0\x9D\x94\xA2" }, { k: "eg", v: "\xE2\xAA\x9A" }, { k: "egrave", v: "\xC3\xA8" }, { k: "egs", v: "\xE2\xAA\x96" }, { k: "egsdot", v: "\xE2\xAA\x98" }, { k: "el", v: "\xE2\xAA\x99" }, { k: "elinters", v: "\xE2\x8F\xA7" }, { k: "ell", v: "\xE2\x84\x93" }, { k: "els", v: "\xE2\xAA\x95" }, { k: "elsdot", v: "\xE2\xAA\x97" }, { k: "emacr", v: "\xC4\x93" }, { k: "empty", v: "\xE2\x88\x85" }, { k: "emptyset", v: "\xE2\x88\x85" }, { k: "emptyv", v: "\xE2\x88\x85" }, { k: "emsp", v: "\xE2\x80\x83" }, { k: "emsp13", v: "\xE2\x80\x84" }, { k: "emsp14", v: "\xE2\x80\x85" }, { k: "eng", v: "\xC5\x8B" }, { k: "ensp", v: "\xE2\x80\x82" }, { k: "eogon", v: "\xC4\x99" }, { k: "eopf", v: "\xF0\x9D\x95\x96" }, { k: "epar", v: "\xE2\x8B\x95" }, { k: "eparsl", v: "\xE2\xA7\xA3" }, { k: "eplus", v: "\xE2\xA9\xB1" }, { k: "epsi", v: "\xCE\xB5" }, { k: "epsilon", v: "\xCE\xB5" }, { k: "epsiv", v: "\xCF\xB5" }, { k: "eqcirc", v: "\xE2\x89\x96" }, { k: "eqcolon", v: "\xE2\x89\x95" }, { k: "eqsim", v: "\xE2\x89\x82" }, { k: "eqslantgtr", v: "\xE2\xAA\x96" }, { k: "eqslantless", v: "\xE2\xAA\x95" }, { k: "equals", v: "=" }, { k: "equest", v: "\xE2\x89\x9F" }, { k: "equiv", v: "\xE2\x89\xA1" }, { k: "equivDD", v: "\xE2\xA9\xB8" }, { k: "eqvparsl", v: "\xE2\xA7\xA5" }, { k: "erDot", v: "\xE2\x89\x93" }, { k: "erarr", v: "\xE2\xA5\xB1" }, { k: "escr", v: "\xE2\x84\xAF" }, { k: "esdot", v: "\xE2\x89\x90" }, { k: "esim", v: "\xE2\x89\x82" }, { k: "eta", v: "\xCE\xB7" }, { k: "eth", v: "\xC3\xB0" }, { k: "euml", v: "\xC3\xAB" }, { k: "euro", v: "\xE2\x82\xAC" }, { k: "excl", v: "!" }, { k: "exist", v: "\xE2\x88\x83" }, { k: "expectation", v: "\xE2\x84\xB0" }, { k: "exponentiale", v: "\xE2\x85\x87" }, { k: "fallingdotseq", v: "\xE2\x89\x92" }, { k: "fcy", v: "\xD1\x84" }, { k: "female", v: "\xE2\x99\x80" }, { k: "ffilig", v: "\xEF\xAC\x83" }, { k: "fflig", v: "\xEF\xAC\x80" }, { k: "ffllig", v: "\xEF\xAC\x84" }, { k: "ffr", v: "\xF0\x9D\x94\xA3" }, { k: "filig", v: "\xEF\xAC\x81" }, { k: "fjlig", v: "fj fj" }, { k: "flat", v: "\xE2\x99\xAD" }, { k: "fllig", v: "\xEF\xAC\x82" }, { k: "fltns", v: "\xE2\x96\xB1" }, { k: "fnof", v: "\xC6\x92" }, { k: "fopf", v: "\xF0\x9D\x95\x97" }, { k: "forall", v: "\xE2\x88\x80" }, { k: "fork", v: "\xE2\x8B\x94" }, { k: "forkv", v: "\xE2\xAB\x99" }, { k: "fpartint", v: "\xE2\xA8\x8D" }, { k: "frac12", v: "\xC2\xBD" }, { k: "frac13", v: "\xE2\x85\x93" }, { k: "frac14", v: "\xC2\xBC" }, { k: "frac15", v: "\xE2\x85\x95" }, { k: "frac16", v: "\xE2\x85\x99" }, { k: "frac18", v: "\xE2\x85\x9B" }, { k: "frac23", v: "\xE2\x85\x94" }, { k: "frac25", v: "\xE2\x85\x96" }, { k: "frac34", v: "\xC2\xBE" }, { k: "frac35", v: "\xE2\x85\x97" }, { k: "frac38", v: "\xE2\x85\x9C" }, { k: "frac45", v: "\xE2\x85\x98" }, { k: "frac56", v: "\xE2\x85\x9A" }, { k: "frac58", v: "\xE2\x85\x9D" }, { k: "frac78", v: "\xE2\x85\x9E" }, { k: "frasl", v: "\xE2\x81\x84" }, { k: "frown", v: "\xE2\x8C\xA2" }, { k: "fscr", v: "\xF0\x9D\x92\xBB" }, { k: "gE", v: "\xE2\x89\xA7" }, { k: "gEl", v: "\xE2\xAA\x8C" }, { k: "gacute", v: "\xC7\xB5" }, { k: "gamma", v: "\xCE\xB3" }, { k: "gammad", v: "\xCF\x9D" }, { k: "gap", v: "\xE2\xAA\x86" }, { k: "gbreve", v: "\xC4\x9F" }, { k: "gcirc", v: "\xC4\x9D" }, { k: "gcy", v: "\xD0\xB3" }, { k: "gdot", v: "\xC4\xA1" }, { k: "ge", v: "\xE2\x89\xA5" }, { k: "gel", v: "\xE2\x8B\x9B" }, { k: "geq", v: "\xE2\x89\xA5" }, { k: "geqq", v: "\xE2\x89\xA7" }, { k: "geqslant", v: "\xE2\xA9\xBE" }, { k: "ges", v: "\xE2\xA9\xBE" }, { k: "gescc", v: "\xE2\xAA\xA9" }, { k: "gesdot", v: "\xE2\xAA\x80" }, { k: "gesdoto", v: "\xE2\xAA\x82" }, { k: "gesdotol", v: "\xE2\xAA\x84" }, { k: "gesl", v: "\xE2\x8B\x9B\xEF\xB8\x80" }, { k: "gesles", v: "\xE2\xAA\x94" }, { k: "gfr", v: "\xF0\x9D\x94\xA4" }, { k: "gg", v: "\xE2\x89\xAB" }, { k: "ggg", v: "\xE2\x8B\x99" }, { k: "gimel", v: "\xE2\x84\xB7" }, { k: "gjcy", v: "\xD1\x93" }, { k: "gl", v: "\xE2\x89\xB7" }, { k: "glE", v: "\xE2\xAA\x92" }, { k: "gla", v: "\xE2\xAA\xA5" }, { k: "glj", v: "\xE2\xAA\xA4" }, { k: "gnE", v: "\xE2\x89\xA9" }, { k: "gnap", v: "\xE2\xAA\x8A" }, { k: "gnapprox", v: "\xE2\xAA\x8A" }, { k: "gne", v: "\xE2\xAA\x88" }, { k: "gneq", v: "\xE2\xAA\x88" }, { k: "gneqq", v: "\xE2\x89\xA9" }, { k: "gnsim", v: "\xE2\x8B\xA7" }, { k: "gopf", v: "\xF0\x9D\x95\x98" }, { k: "grave", v: "`" }, { k: "gscr", v: "\xE2\x84\x8A" }, { k: "gsim", v: "\xE2\x89\xB3" }, { k: "gsime", v: "\xE2\xAA\x8E" }, { k: "gsiml", v: "\xE2\xAA\x90" }, { k: "gt", v: ">" }, { k: "gtcc", v: "\xE2\xAA\xA7" }, { k: "gtcir", v: "\xE2\xA9\xBA" }, { k: "gtdot", v: "\xE2\x8B\x97" }, { k: "gtlPar", v: "\xE2\xA6\x95" }, { k: "gtquest", v: "\xE2\xA9\xBC" }, { k: "gtrapprox", v: "\xE2\xAA\x86" }, { k: "gtrarr", v: "\xE2\xA5\xB8" }, { k: "gtrdot", v: "\xE2\x8B\x97" }, { k: "gtreqless", v: "\xE2\x8B\x9B" }, { k: "gtreqqless", v: "\xE2\xAA\x8C" }, { k: "gtrless", v: "\xE2\x89\xB7" }, { k: "gtrsim", v: "\xE2\x89\xB3" }, { k: "gvertneqq", v: "\xE2\x89\xA9\xEF\xB8\x80" }, { k: "gvnE", v: "\xE2\x89\xA9\xEF\xB8\x80" }, { k: "hArr", v: "\xE2\x87\x94" }, { k: "hairsp", v: "\xE2\x80\x8A" }, { k: "half", v: "\xC2\xBD" }, { k: "hamilt", v: "\xE2\x84\x8B" }, { k: "hardcy", v: "\xD1\x8A" }, { k: "harr", v: "\xE2\x86\x94" }, { k: "harrcir", v: "\xE2\xA5\x88" }, { k: "harrw", v: "\xE2\x86\xAD" }, { k: "hbar", v: "\xE2\x84\x8F" }, { k: "hcirc", v: "\xC4\xA5" }, { k: "hearts", v: "\xE2\x99\xA5" }, { k: "heartsuit", v: "\xE2\x99\xA5" }, { k: "hellip", v: "\xE2\x80\xA6" }, { k: "hercon", v: "\xE2\x8A\xB9" }, { k: "hfr", v: "\xF0\x9D\x94\xA5" }, { k: "hksearow", v: "\xE2\xA4\xA5" }, { k: "hkswarow", v: "\xE2\xA4\xA6" }, { k: "hoarr", v: "\xE2\x87\xBF" }, { k: "homtht", v: "\xE2\x88\xBB" }, { k: "hookleftarrow", v: "\xE2\x86\xA9" }, { k: "hookrightarrow", v: "\xE2\x86\xAA" }, { k: "hopf", v: "\xF0\x9D\x95\x99" }, { k: "horbar", v: "\xE2\x80\x95" }, { k: "hscr", v: "\xF0\x9D\x92\xBD" }, { k: "hslash", v: "\xE2\x84\x8F" }, { k: "hstrok", v: "\xC4\xA7" }, { k: "hybull", v: "\xE2\x81\x83" }, { k: "hyphen", v: "\xE2\x80\x90" }, { k: "iacute", v: "\xC3\xAD" }, { k: "ic", v: "\xE2\x81\xA3" }, { k: "icirc", v: "\xC3\xAE" }, { k: "icy", v: "\xD0\xB8" }, { k: "iecy", v: "\xD0\xB5" }, { k: "iexcl", v: "\xC2\xA1" }, { k: "iff", v: "\xE2\x87\x94" }, { k: "ifr", v: "\xF0\x9D\x94\xA6" }, { k: "igrave", v: "\xC3\xAC" }, { k: "ii", v: "\xE2\x85\x88" }, { k: "iiiint", v: "\xE2\xA8\x8C" }, { k: "iiint", v: "\xE2\x88\xAD" }, { k: "iinfin", v: "\xE2\xA7\x9C" }, { k: "iiota", v: "\xE2\x84\xA9" }, { k: "ijlig", v: "\xC4\xB3" }, { k: "imacr", v: "\xC4\xAB" }, { k: "image", v: "\xE2\x84\x91" }, { k: "imagline", v: "\xE2\x84\x90" }, { k: "imagpart", v: "\xE2\x84\x91" }, { k: "imath", v: "\xC4\xB1" }, { k: "imof", v: "\xE2\x8A\xB7" }, { k: "imped", v: "\xC6\xB5" }, { k: "in", v: "\xE2\x88\x88" }, { k: "incare", v: "\xE2\x84\x85" }, { k: "infin", v: "\xE2\x88\x9E" }, { k: "infintie", v: "\xE2\xA7\x9D" }, { k: "inodot", v: "\xC4\xB1" }, { k: "int", v: "\xE2\x88\xAB" }, { k: "intcal", v: "\xE2\x8A\xBA" }, { k: "integers", v: "\xE2\x84\xA4" }, { k: "intercal", v: "\xE2\x8A\xBA" }, { k: "intlarhk", v: "\xE2\xA8\x97" }, { k: "intprod", v: "\xE2\xA8\xBC" }, { k: "iocy", v: "\xD1\x91" }, { k: "iogon", v: "\xC4\xAF" }, { k: "iopf", v: "\xF0\x9D\x95\x9A" }, { k: "iota", v: "\xCE\xB9" }, { k: "iprod", v: "\xE2\xA8\xBC" }, { k: "iquest", v: "\xC2\xBF" }, { k: "iscr", v: "\xF0\x9D\x92\xBE" }, { k: "isin", v: "\xE2\x88\x88" }, { k: "isinE", v: "\xE2\x8B\xB9" }, { k: "isindot", v: "\xE2\x8B\xB5" }, { k: "isins", v: "\xE2\x8B\xB4" }, { k: "isinsv", v: "\xE2\x8B\xB3" }, { k: "isinv", v: "\xE2\x88\x88" }, { k: "it", v: "\xE2\x81\xA2" }, { k: "itilde", v: "\xC4\xA9" }, { k: "iukcy", v: "\xD1\x96" }, { k: "iuml", v: "\xC3\xAF" }, { k: "jcirc", v: "\xC4\xB5" }, { k: "jcy", v: "\xD0\xB9" }, { k: "jfr", v: "\xF0\x9D\x94\xA7" }, { k: "jmath", v: "\xC8\xB7" }, { k: "jopf", v: "\xF0\x9D\x95\x9B" }, { k: "jscr", v: "\xF0\x9D\x92\xBF" }, { k: "jsercy", v: "\xD1\x98" }, { k: "jukcy", v: "\xD1\x94" }, { k: "kappa", v: "\xCE\xBA" }, { k: "kappav", v: "\xCF\xB0" }, { k: "kcedil", v: "\xC4\xB7" }, { k: "kcy", v: "\xD0\xBA" }, { k: "kfr", v: "\xF0\x9D\x94\xA8" }, { k: "kgreen", v: "\xC4\xB8" }, { k: "khcy", v: "\xD1\x85" }, { k: "kjcy", v: "\xD1\x9C" }, { k: "kopf", v: "\xF0\x9D\x95\x9C" }, { k: "kscr", v: "\xF0\x9D\x93\x80" }, { k: "lAarr", v: "\xE2\x87\x9A" }, { k: "lArr", v: "\xE2\x87\x90" }, { k: "lAtail", v: "\xE2\xA4\x9B" }, { k: "lBarr", v: "\xE2\xA4\x8E" }, { k: "lE", v: "\xE2\x89\xA6" }, { k: "lEg", v: "\xE2\xAA\x8B" }, { k: "lHar", v: "\xE2\xA5\xA2" }, { k: "lacute", v: "\xC4\xBA" }, { k: "laemptyv", v: "\xE2\xA6\xB4" }, { k: "lagran", v: "\xE2\x84\x92" }, { k: "lambda", v: "\xCE\xBB" }, { k: "lang", v: "\xE2\x9F\xA8" }, { k: "langd", v: "\xE2\xA6\x91" }, { k: "langle", v: "\xE2\x9F\xA8" }, { k: "lap", v: "\xE2\xAA\x85" }, { k: "laquo", v: "\xC2\xAB" }, { k: "larr", v: "\xE2\x86\x90" }, { k: "larrb", v: "\xE2\x87\xA4" }, { k: "larrbfs", v: "\xE2\xA4\x9F" }, { k: "larrfs", v: "\xE2\xA4\x9D" }, { k: "larrhk", v: "\xE2\x86\xA9" }, { k: "larrlp", v: "\xE2\x86\xAB" }, { k: "larrpl", v: "\xE2\xA4\xB9" }, { k: "larrsim", v: "\xE2\xA5\xB3" }, { k: "larrtl", v: "\xE2\x86\xA2" }, { k: "lat", v: "\xE2\xAA\xAB" }, { k: "latail", v: "\xE2\xA4\x99" }, { k: "late", v: "\xE2\xAA\xAD" }, { k: "lates", v: "\xE2\xAA\xAD\xEF\xB8\x80" }, { k: "lbarr", v: "\xE2\xA4\x8C" }, { k: "lbbrk", v: "\xE2\x9D\xB2" }, { k: "lbrace", v: "{" }, { k: "lbrack", v: "[" }, { k: "lbrke", v: "\xE2\xA6\x8B" }, { k: "lbrksld", v: "\xE2\xA6\x8F" }, { k: "lbrkslu", v: "\xE2\xA6\x8D" }, { k: "lcaron", v: "\xC4\xBE" }, { k: "lcedil", v: "\xC4\xBC" }, { k: "lceil", v: "\xE2\x8C\x88" }, { k: "lcub", v: "{" }, { k: "lcy", v: "\xD0\xBB" }, { k: "ldca", v: "\xE2\xA4\xB6" }, { k: "ldquo", v: "\xE2\x80\x9C" }, { k: "ldquor", v: "\xE2\x80\x9E" }, { k: "ldrdhar", v: "\xE2\xA5\xA7" }, { k: "ldrushar", v: "\xE2\xA5\x8B" }, { k: "ldsh", v: "\xE2\x86\xB2" }, { k: "le", v: "\xE2\x89\xA4" }, { k: "leftarrow", v: "\xE2\x86\x90" }, { k: "leftarrowtail", v: "\xE2\x86\xA2" }, { k: "leftharpoondown", v: "\xE2\x86\xBD" }, { k: "leftharpoonup", v: "\xE2\x86\xBC" }, { k: "leftleftarrows", v: "\xE2\x87\x87" }, { k: "leftrightarrow", v: "\xE2\x86\x94" }, { k: "leftrightarrows", v: "\xE2\x87\x86" }, { k: "leftrightharpoons", v: "\xE2\x87\x8B" }, { k: "leftrightsquigarrow", v: "\xE2\x86\xAD" }, { k: "leftthreetimes", v: "\xE2\x8B\x8B" }, { k: "leg", v: "\xE2\x8B\x9A" }, { k: "leq", v: "\xE2\x89\xA4" }, { k: "leqq", v: "\xE2\x89\xA6" }, { k: "leqslant", v: "\xE2\xA9\xBD" }, { k: "les", v: "\xE2\xA9\xBD" }, { k: "lescc", v: "\xE2\xAA\xA8" }, { k: "lesdot", v: "\xE2\xA9\xBF" }, { k: "lesdoto", v: "\xE2\xAA\x81" }, { k: "lesdotor", v: "\xE2\xAA\x83" }, { k: "lesg", v: "\xE2\x8B\x9A\xEF\xB8\x80" }, { k: "lesges", v: "\xE2\xAA\x93" }, { k: "lessapprox", v: "\xE2\xAA\x85" }, { k: "lessdot", v: "\xE2\x8B\x96" }, { k: "lesseqgtr", v: "\xE2\x8B\x9A" }, { k: "lesseqqgtr", v: "\xE2\xAA\x8B" }, { k: "lessgtr", v: "\xE2\x89\xB6" }, { k: "lesssim", v: "\xE2\x89\xB2" }, { k: "lfisht", v: "\xE2\xA5\xBC" }, { k: "lfloor", v: "\xE2\x8C\x8A" }, { k: "lfr", v: "\xF0\x9D\x94\xA9" }, { k: "lg", v: "\xE2\x89\xB6" }, { k: "lgE", v: "\xE2\xAA\x91" }, { k: "lhard", v: "\xE2\x86\xBD" }, { k: "lharu", v: "\xE2\x86\xBC" }, { k: "lharul", v: "\xE2\xA5\xAA" }, { k: "lhblk", v: "\xE2\x96\x84" }, { k: "ljcy", v: "\xD1\x99" }, { k: "ll", v: "\xE2\x89\xAA" }, { k: "llarr", v: "\xE2\x87\x87" }, { k: "llcorner", v: "\xE2\x8C\x9E" }, { k: "llhard", v: "\xE2\xA5\xAB" }, { k: "lltri", v: "\xE2\x97\xBA" }, { k: "lmidot", v: "\xC5\x80" }, { k: "lmoust", v: "\xE2\x8E\xB0" }, { k: "lmoustache", v: "\xE2\x8E\xB0" }, { k: "lnE", v: "\xE2\x89\xA8" }, { k: "lnap", v: "\xE2\xAA\x89" }, { k: "lnapprox", v: "\xE2\xAA\x89" }, { k: "lne", v: "\xE2\xAA\x87" }, { k: "lneq", v: "\xE2\xAA\x87" }, { k: "lneqq", v: "\xE2\x89\xA8" }, { k: "lnsim", v: "\xE2\x8B\xA6" }, { k: "loang", v: "\xE2\x9F\xAC" }, { k: "loarr", v: "\xE2\x87\xBD" }, { k: "lobrk", v: "\xE2\x9F\xA6" }, { k: "longleftarrow", v: "\xE2\x9F\xB5" }, { k: "longleftrightarrow", v: "\xE2\x9F\xB7" }, { k: "longmapsto", v: "\xE2\x9F\xBC" }, { k: "longrightarrow", v: "\xE2\x9F\xB6" }, { k: "looparrowleft", v: "\xE2\x86\xAB" }, { k: "looparrowright", v: "\xE2\x86\xAC" }, { k: "lopar", v: "\xE2\xA6\x85" }, { k: "lopf", v: "\xF0\x9D\x95\x9D" }, { k: "loplus", v: "\xE2\xA8\xAD" }, { k: "lotimes", v: "\xE2\xA8\xB4" }, { k: "lowast", v: "\xE2\x88\x97" }, { k: "lowbar", v: "_" }, { k: "loz", v: "\xE2\x97\x8A" }, { k: "lozenge", v: "\xE2\x97\x8A" }, { k: "lozf", v: "\xE2\xA7\xAB" }, { k: "lpar", v: "(" }, { k: "lparlt", v: "\xE2\xA6\x93" }, { k: "lrarr", v: "\xE2\x87\x86" }, { k: "lrcorner", v: "\xE2\x8C\x9F" }, { k: "lrhar", v: "\xE2\x87\x8B" }, { k: "lrhard", v: "\xE2\xA5\xAD" }, { k: "lrm", v: "\xE2\x80\x8E" }, { k: "lrtri", v: "\xE2\x8A\xBF" }, { k: "lsaquo", v: "\xE2\x80\xB9" }, { k: "lscr", v: "\xF0\x9D\x93\x81" }, { k: "lsh", v: "\xE2\x86\xB0" }, { k: "lsim", v: "\xE2\x89\xB2" }, { k: "lsime", v: "\xE2\xAA\x8D" }, { k: "lsimg", v: "\xE2\xAA\x8F" }, { k: "lsqb", v: "[" }, { k: "lsquo", v: "\xE2\x80\x98" }, { k: "lsquor", v: "\xE2\x80\x9A" }, { k: "lstrok", v: "\xC5\x82" }, { k: "lt", v: "<" }, { k: "ltcc", v: "\xE2\xAA\xA6" }, { k: "ltcir", v: "\xE2\xA9\xB9" }, { k: "ltdot", v: "\xE2\x8B\x96" }, { k: "lthree", v: "\xE2\x8B\x8B" }, { k: "ltimes", v: "\xE2\x8B\x89" }, { k: "ltlarr", v: "\xE2\xA5\xB6" }, { k: "ltquest", v: "\xE2\xA9\xBB" }, { k: "ltrPar", v: "\xE2\xA6\x96" }, { k: "ltri", v: "\xE2\x97\x83" }, { k: "ltrie", v: "\xE2\x8A\xB4" }, { k: "ltrif", v: "\xE2\x97\x82" }, { k: "lurdshar", v: "\xE2\xA5\x8A" }, { k: "luruhar", v: "\xE2\xA5\xA6" }, { k: "lvertneqq", v: "\xE2\x89\xA8\xEF\xB8\x80" }, { k: "lvnE", v: "\xE2\x89\xA8\xEF\xB8\x80" }, { k: "mDDot", v: "\xE2\x88\xBA" }, { k: "macr", v: "\xC2\xAF" }, { k: "male", v: "\xE2\x99\x82" }, { k: "malt", v: "\xE2\x9C\xA0" }, { k: "maltese", v: "\xE2\x9C\xA0" }, { k: "map", v: "\xE2\x86\xA6" }, { k: "mapsto", v: "\xE2\x86\xA6" }, { k: "mapstodown", v: "\xE2\x86\xA7" }, { k: "mapstoleft", v: "\xE2\x86\xA4" }, { k: "mapstoup", v: "\xE2\x86\xA5" }, { k: "marker", v: "\xE2\x96\xAE" }, { k: "mcomma", v: "\xE2\xA8\xA9" }, { k: "mcy", v: "\xD0\xBC" }, { k: "mdash", v: "\xE2\x80\x94" }, { k: "measuredangle", v: "\xE2\x88\xA1" }, { k: "mfr", v: "\xF0\x9D\x94\xAA" }, { k: "mho", v: "\xE2\x84\xA7" }, { k: "micro", v: "\xC2\xB5" }, { k: "mid", v: "\xE2\x88\xA3" }, { k: "midast", v: "*" }, { k: "midcir", v: "\xE2\xAB\xB0" }, { k: "middot", v: "\xC2\xB7" }, { k: "minus", v: "\xE2\x88\x92" }, { k: "minusb", v: "\xE2\x8A\x9F" }, { k: "minusd", v: "\xE2\x88\xB8" }, { k: "minusdu", v: "\xE2\xA8\xAA" }, { k: "mlcp", v: "\xE2\xAB\x9B" }, { k: "mldr", v: "\xE2\x80\xA6" }, { k: "mnplus", v: "\xE2\x88\x93" }, { k: "models", v: "\xE2\x8A\xA7" }, { k: "mopf", v: "\xF0\x9D\x95\x9E" }, { k: "mp", v: "\xE2\x88\x93" }, { k: "mscr", v: "\xF0\x9D\x93\x82" }, { k: "mstpos", v: "\xE2\x88\xBE" }, { k: "mu", v: "\xCE\xBC" }, { k: "multimap", v: "\xE2\x8A\xB8" }, { k: "mumap", v: "\xE2\x8A\xB8" }, { k: "nGg", v: "\xE2\x8B\x99\xCC\xB8" }, { k: "nGt", v: "\xE2\x89\xAB\xE2\x83\x92" }, { k: "nGtv", v: "\xE2\x89\xAB\xCC\xB8" }, { k: "nLeftarrow", v: "\xE2\x87\x8D" }, { k: "nLeftrightarrow", v: "\xE2\x87\x8E" }, { k: "nLl", v: "\xE2\x8B\x98\xCC\xB8" }, { k: "nLt", v: "\xE2\x89\xAA\xE2\x83\x92" }, { k: "nLtv", v: "\xE2\x89\xAA\xCC\xB8" }, { k: "nRightarrow", v: "\xE2\x87\x8F" }, { k: "nVDash", v: "\xE2\x8A\xAF" }, { k: "nVdash", v: "\xE2\x8A\xAE" }, { k: "nabla", v: "\xE2\x88\x87" }, { k: "nacute", v: "\xC5\x84" }, { k: "nang", v: "\xE2\x88\xA0\xE2\x83\x92" }, { k: "nap", v: "\xE2\x89\x89" }, { k: "napE", v: "\xE2\xA9\xB0\xCC\xB8" }, { k: "napid", v: "\xE2\x89\x8B\xCC\xB8" }, { k: "napos", v: "\xC5\x89" }, { k: "napprox", v: "\xE2\x89\x89" }, { k: "natur", v: "\xE2\x99\xAE" }, { k: "natural", v: "\xE2\x99\xAE" }, { k: "naturals", v: "\xE2\x84\x95" }, { k: "nbsp", v: "\xC2\xA0" }, { k: "nbump", v: "\xE2\x89\x8E\xCC\xB8" }, { k: "nbumpe", v: "\xE2\x89\x8F\xCC\xB8" }, { k: "ncap", v: "\xE2\xA9\x83" }, { k: "ncaron", v: "\xC5\x88" }, { k: "ncedil", v: "\xC5\x86" }, { k: "ncong", v: "\xE2\x89\x87" }, { k: "ncongdot", v: "\xE2\xA9\xAD\xCC\xB8" }, { k: "ncup", v: "\xE2\xA9\x82" }, { k: "ncy", v: "\xD0\xBD" }, { k: "ndash", v: "\xE2\x80\x93" }, { k: "ne", v: "\xE2\x89\xA0" }, { k: "neArr", v: "\xE2\x87\x97" }, { k: "nearhk", v: "\xE2\xA4\xA4" }, { k: "nearr", v: "\xE2\x86\x97" }, { k: "nearrow", v: "\xE2\x86\x97" }, { k: "nedot", v: "\xE2\x89\x90\xCC\xB8" }, { k: "nequiv", v: "\xE2\x89\xA2" }, { k: "nesear", v: "\xE2\xA4\xA8" }, { k: "nesim", v: "\xE2\x89\x82\xCC\xB8" }, { k: "nexist", v: "\xE2\x88\x84" }, { k: "nexists", v: "\xE2\x88\x84" }, { k: "nfr", v: "\xF0\x9D\x94\xAB" }, { k: "ngE", v: "\xE2\x89\xA7\xCC\xB8" }, { k: "nge", v: "\xE2\x89\xB1" }, { k: "ngeq", v: "\xE2\x89\xB1" }, { k: "ngeqq", v: "\xE2\x89\xA7\xCC\xB8" }, { k: "ngeqslant", v: "\xE2\xA9\xBE\xCC\xB8" }, { k: "nges", v: "\xE2\xA9\xBE\xCC\xB8" }, { k: "ngsim", v: "\xE2\x89\xB5" }, { k: "ngt", v: "\xE2\x89\xAF" }, { k: "ngtr", v: "\xE2\x89\xAF" }, { k: "nhArr", v: "\xE2\x87\x8E" }, { k: "nharr", v: "\xE2\x86\xAE" }, { k: "nhpar", v: "\xE2\xAB\xB2" }, { k: "ni", v: "\xE2\x88\x8B" }, { k: "nis", v: "\xE2\x8B\xBC" }, { k: "nisd", v: "\xE2\x8B\xBA" }, { k: "niv", v: "\xE2\x88\x8B" }, { k: "njcy", v: "\xD1\x9A" }, { k: "nlArr", v: "\xE2\x87\x8D" }, { k: "nlE", v: "\xE2\x89\xA6\xCC\xB8" }, { k: "nlarr", v: "\xE2\x86\x9A" }, { k: "nldr", v: "\xE2\x80\xA5" }, { k: "nle", v: "\xE2\x89\xB0" }, { k: "nleftarrow", v: "\xE2\x86\x9A" }, { k: "nleftrightarrow", v: "\xE2\x86\xAE" }, { k: "nleq", v: "\xE2\x89\xB0" }, { k: "nleqq", v: "\xE2\x89\xA6\xCC\xB8" }, { k: "nleqslant", v: "\xE2\xA9\xBD\xCC\xB8" }, { k: "nles", v: "\xE2\xA9\xBD\xCC\xB8" }, { k: "nless", v: "\xE2\x89\xAE" }, { k: "nlsim", v: "\xE2\x89\xB4" }, { k: "nlt", v: "\xE2\x89\xAE" }, { k: "nltri", v: "\xE2\x8B\xAA" }, { k: "nltrie", v: "\xE2\x8B\xAC" }, { k: "nmid", v: "\xE2\x88\xA4" }, { k: "nopf", v: "\xF0\x9D\x95\x9F" }, { k: "not", v: "\xC2\xAC" }, { k: "notin", v: "\xE2\x88\x89" }, { k: "notinE", v: "\xE2\x8B\xB9\xCC\xB8" }, { k: "notindot", v: "\xE2\x8B\xB5\xCC\xB8" }, { k: "notinva", v: "\xE2\x88\x89" }, { k: "notinvb", v: "\xE2\x8B\xB7" }, { k: "notinvc", v: "\xE2\x8B\xB6" }, { k: "notni", v: "\xE2\x88\x8C" }, { k: "notniva", v: "\xE2\x88\x8C" }, { k: "notnivb", v: "\xE2\x8B\xBE" }, { k: "notnivc", v: "\xE2\x8B\xBD" }, { k: "npar", v: "\xE2\x88\xA6" }, { k: "nparallel", v: "\xE2\x88\xA6" }, { k: "nparsl", v: "\xE2\xAB\xBD\xE2\x83\xA5" }, { k: "npart", v: "\xE2\x88\x82\xCC\xB8" }, { k: "npolint", v: "\xE2\xA8\x94" }, { k: "npr", v: "\xE2\x8A\x80" }, { k: "nprcue", v: "\xE2\x8B\xA0" }, { k: "npre", v: "\xE2\xAA\xAF\xCC\xB8" }, { k: "nprec", v: "\xE2\x8A\x80" }, { k: "npreceq", v: "\xE2\xAA\xAF\xCC\xB8" }, { k: "nrArr", v: "\xE2\x87\x8F" }, { k: "nrarr", v: "\xE2\x86\x9B" }, { k: "nrarrc", v: "\xE2\xA4\xB3\xCC\xB8" }, { k: "nrarrw", v: "\xE2\x86\x9D\xCC\xB8" }, { k: "nrightarrow", v: "\xE2\x86\x9B" }, { k: "nrtri", v: "\xE2\x8B\xAB" }, { k: "nrtrie", v: "\xE2\x8B\xAD" }, { k: "nsc", v: "\xE2\x8A\x81" }, { k: "nsccue", v: "\xE2\x8B\xA1" }, { k: "nsce", v: "\xE2\xAA\xB0\xCC\xB8" }, { k: "nscr", v: "\xF0\x9D\x93\x83" }, { k: "nshortmid", v: "\xE2\x88\xA4" }, { k: "nshortparallel", v: "\xE2\x88\xA6" }, { k: "nsim", v: "\xE2\x89\x81" }, { k: "nsime", v: "\xE2\x89\x84" }, { k: "nsimeq", v: "\xE2\x89\x84" }, { k: "nsmid", v: "\xE2\x88\xA4" }, { k: "nspar", v: "\xE2\x88\xA6" }, { k: "nsqsube", v: "\xE2\x8B\xA2" }, { k: "nsqsupe", v: "\xE2\x8B\xA3" }, { k: "nsub", v: "\xE2\x8A\x84" }, { k: "nsubE", v: "\xE2\xAB\x85\xCC\xB8" }, { k: "nsube", v: "\xE2\x8A\x88" }, { k: "nsubset", v: "\xE2\x8A\x82\xE2\x83\x92" }, { k: "nsubseteq", v: "\xE2\x8A\x88" }, { k: "nsubseteqq", v: "\xE2\xAB\x85\xCC\xB8" }, { k: "nsucc", v: "\xE2\x8A\x81" }, { k: "nsucceq", v: "\xE2\xAA\xB0\xCC\xB8" }, { k: "nsup", v: "\xE2\x8A\x85" }, { k: "nsupE", v: "\xE2\xAB\x86\xCC\xB8" }, { k: "nsupe", v: "\xE2\x8A\x89" }, { k: "nsupset", v: "\xE2\x8A\x83\xE2\x83\x92" }, { k: "nsupseteq", v: "\xE2\x8A\x89" }, { k: "nsupseteqq", v: "\xE2\xAB\x86\xCC\xB8" }, { k: "ntgl", v: "\xE2\x89\xB9" }, { k: "ntilde", v: "\xC3\xB1" }, { k: "ntlg", v: "\xE2\x89\xB8" }, { k: "ntriangleleft", v: "\xE2\x8B\xAA" }, { k: "ntrianglelefteq", v: "\xE2\x8B\xAC" }, { k: "ntriangleright", v: "\xE2\x8B\xAB" }, { k: "ntrianglerighteq", v: "\xE2\x8B\xAD" }, { k: "nu", v: "\xCE\xBD" }, { k: "num", v: "#" }, { k: "numero", v: "\xE2\x84\x96" }, { k: "numsp", v: "\xE2\x80\x87" }, { k: "nvDash", v: "\xE2\x8A\xAD" }, { k: "nvHarr", v: "\xE2\xA4\x84" }, { k: "nvap", v: "\xE2\x89\x8D\xE2\x83\x92" }, { k: "nvdash", v: "\xE2\x8A\xAC" }, { k: "nvge", v: "\xE2\x89\xA5\xE2\x83\x92" }, { k: "nvgt", v: ">\xE2\x83\x92" }, { k: "nvinfin", v: "\xE2\xA7\x9E" }, { k: "nvlArr", v: "\xE2\xA4\x82" }, { k: "nvle", v: "\xE2\x89\xA4\xE2\x83\x92" }, { k: "nvlt", v: "<\xE2\x83\x92" }, { k: "nvltrie", v: "\xE2\x8A\xB4\xE2\x83\x92" }, { k: "nvrArr", v: "\xE2\xA4\x83" }, { k: "nvrtrie", v: "\xE2\x8A\xB5\xE2\x83\x92" }, { k: "nvsim", v: "\xE2\x88\xBC\xE2\x83\x92" }, { k: "nwArr", v: "\xE2\x87\x96" }, { k: "nwarhk", v: "\xE2\xA4\xA3" }, { k: "nwarr", v: "\xE2\x86\x96" }, { k: "nwarrow", v: "\xE2\x86\x96" }, { k: "nwnear", v: "\xE2\xA4\xA7" }, { k: "oS", v: "\xE2\x93\x88" }, { k: "oacute", v: "\xC3\xB3" }, { k: "oast", v: "\xE2\x8A\x9B" }, { k: "ocir", v: "\xE2\x8A\x9A" }, { k: "ocirc", v: "\xC3\xB4" }, { k: "ocy", v: "\xD0\xBE" }, { k: "odash", v: "\xE2\x8A\x9D" }, { k: "odblac", v: "\xC5\x91" }, { k: "odiv", v: "\xE2\xA8\xB8" }, { k: "odot", v: "\xE2\x8A\x99" }, { k: "odsold", v: "\xE2\xA6\xBC" }, { k: "oelig", v: "\xC5\x93" }, { k: "ofcir", v: "\xE2\xA6\xBF" }, { k: "ofr", v: "\xF0\x9D\x94\xAC" }, { k: "ogon", v: "\xCB\x9B" }, { k: "ograve", v: "\xC3\xB2" }, { k: "ogt", v: "\xE2\xA7\x81" }, { k: "ohbar", v: "\xE2\xA6\xB5" }, { k: "ohm", v: "\xCE\xA9" }, { k: "oint", v: "\xE2\x88\xAE" }, { k: "olarr", v: "\xE2\x86\xBA" }, { k: "olcir", v: "\xE2\xA6\xBE" }, { k: "olcross", v: "\xE2\xA6\xBB" }, { k: "oline", v: "\xE2\x80\xBE" }, { k: "olt", v: "\xE2\xA7\x80" }, { k: "omacr", v: "\xC5\x8D" }, { k: "omega", v: "\xCF\x89" }, { k: "omicron", v: "\xCE\xBF" }, { k: "omid", v: "\xE2\xA6\xB6" }, { k: "ominus", v: "\xE2\x8A\x96" }, { k: "oopf", v: "\xF0\x9D\x95\xA0" }, { k: "opar", v: "\xE2\xA6\xB7" }, { k: "operp", v: "\xE2\xA6\xB9" }, { k: "oplus", v: "\xE2\x8A\x95" }, { k: "or", v: "\xE2\x88\xA8" }, { k: "orarr", v: "\xE2\x86\xBB" }, { k: "ord", v: "\xE2\xA9\x9D" }, { k: "order", v: "\xE2\x84\xB4" }, { k: "orderof", v: "\xE2\x84\xB4" }, { k: "ordf", v: "\xC2\xAA" }, { k: "ordm", v: "\xC2\xBA" }, { k: "origof", v: "\xE2\x8A\xB6" }, { k: "oror", v: "\xE2\xA9\x96" }, { k: "orslope", v: "\xE2\xA9\x97" }, { k: "orv", v: "\xE2\xA9\x9B" }, { k: "oscr", v: "\xE2\x84\xB4" }, { k: "oslash", v: "\xC3\xB8" }, { k: "osol", v: "\xE2\x8A\x98" }, { k: "otilde", v: "\xC3\xB5" }, { k: "otimes", v: "\xE2\x8A\x97" }, { k: "otimesas", v: "\xE2\xA8\xB6" }, { k: "ouml", v: "\xC3\xB6" }, { k: "ovbar", v: "\xE2\x8C\xBD" }, { k: "par", v: "\xE2\x88\xA5" }, { k: "para", v: "\xC2\xB6" }, { k: "parallel", v: "\xE2\x88\xA5" }, { k: "parsim", v: "\xE2\xAB\xB3" }, { k: "parsl", v: "\xE2\xAB\xBD" }, { k: "part", v: "\xE2\x88\x82" }, { k: "pcy", v: "\xD0\xBF" }, { k: "percnt", v: "%" }, { k: "period", v: "." }, { k: "permil", v: "\xE2\x80\xB0" }, { k: "perp", v: "\xE2\x8A\xA5" }, { k: "pertenk", v: "\xE2\x80\xB1" }, { k: "pfr", v: "\xF0\x9D\x94\xAD" }, { k: "phi", v: "\xCF\x86" }, { k: "phiv", v: "\xCF\x95" }, { k: "phmmat", v: "\xE2\x84\xB3" }, { k: "phone", v: "\xE2\x98\x8E" }, { k: "pi", v: "\xCF\x80" }, { k: "pitchfork", v: "\xE2\x8B\x94" }, { k: "piv", v: "\xCF\x96" }, { k: "planck", v: "\xE2\x84\x8F" }, { k: "planckh", v: "\xE2\x84\x8E" }, { k: "plankv", v: "\xE2\x84\x8F" }, { k: "plus", v: "+" }, { k: "plusacir", v: "\xE2\xA8\xA3" }, { k: "plusb", v: "\xE2\x8A\x9E" }, { k: "pluscir", v: "\xE2\xA8\xA2" }, { k: "plusdo", v: "\xE2\x88\x94" }, { k: "plusdu", v: "\xE2\xA8\xA5" }, { k: "pluse", v: "\xE2\xA9\xB2" }, { k: "plusmn", v: "\xC2\xB1" }, { k: "plussim", v: "\xE2\xA8\xA6" }, { k: "plustwo", v: "\xE2\xA8\xA7" }, { k: "pm", v: "\xC2\xB1" }, { k: "pointint", v: "\xE2\xA8\x95" }, { k: "popf", v: "\xF0\x9D\x95\xA1" }, { k: "pound", v: "\xC2\xA3" }, { k: "pr", v: "\xE2\x89\xBA" }, { k: "prE", v: "\xE2\xAA\xB3" }, { k: "prap", v: "\xE2\xAA\xB7" }, { k: "prcue", v: "\xE2\x89\xBC" }, { k: "pre", v: "\xE2\xAA\xAF" }, { k: "prec", v: "\xE2\x89\xBA" }, { k: "precapprox", v: "\xE2\xAA\xB7" }, { k: "preccurlyeq", v: "\xE2\x89\xBC" }, { k: "preceq", v: "\xE2\xAA\xAF" }, { k: "precnapprox", v: "\xE2\xAA\xB9" }, { k: "precneqq", v: "\xE2\xAA\xB5" }, { k: "precnsim", v: "\xE2\x8B\xA8" }, { k: "precsim", v: "\xE2\x89\xBE" }, { k: "prime", v: "\xE2\x80\xB2" }, { k: "primes", v: "\xE2\x84\x99" }, { k: "prnE", v: "\xE2\xAA\xB5" }, { k: "prnap", v: "\xE2\xAA\xB9" }, { k: "prnsim", v: "\xE2\x8B\xA8" }, { k: "prod", v: "\xE2\x88\x8F" }, { k: "profalar", v: "\xE2\x8C\xAE" }, { k: "profline", v: "\xE2\x8C\x92" }, { k: "profsurf", v: "\xE2\x8C\x93" }, { k: "prop", v: "\xE2\x88\x9D" }, { k: "propto", v: "\xE2\x88\x9D" }, { k: "prsim", v: "\xE2\x89\xBE" }, { k: "prurel", v: "\xE2\x8A\xB0" }, { k: "pscr", v: "\xF0\x9D\x93\x85" }, { k: "psi", v: "\xCF\x88" }, { k: "puncsp", v: "\xE2\x80\x88" }, { k: "qfr", v: "\xF0\x9D\x94\xAE" }, { k: "qint", v: "\xE2\xA8\x8C" }, { k: "qopf", v: "\xF0\x9D\x95\xA2" }, { k: "qprime", v: "\xE2\x81\x97" }, { k: "qscr", v: "\xF0\x9D\x93\x86" }, { k: "quaternions", v: "\xE2\x84\x8D" }, { k: "quatint", v: "\xE2\xA8\x96" }, { k: "quest", v: "?" }, { k: "questeq", v: "\xE2\x89\x9F" }, { k: "quot", v: "\"" }, { k: "rAarr", v: "\xE2\x87\x9B" }, { k: "rArr", v: "\xE2\x87\x92" }, { k: "rAtail", v: "\xE2\xA4\x9C" }, { k: "rBarr", v: "\xE2\xA4\x8F" }, { k: "rHar", v: "\xE2\xA5\xA4" }, { k: "race", v: "\xE2\x88\xBD\xCC\xB1" }, { k: "racute", v: "\xC5\x95" }, { k: "radic", v: "\xE2\x88\x9A" }, { k: "raemptyv", v: "\xE2\xA6\xB3" }, { k: "rang", v: "\xE2\x9F\xA9" }, { k: "rangd", v: "\xE2\xA6\x92" }, { k: "range", v: "\xE2\xA6\xA5" }, { k: "rangle", v: "\xE2\x9F\xA9" }, { k: "raquo", v: "\xC2\xBB" }, { k: "rarr", v: "\xE2\x86\x92" }, { k: "rarrap", v: "\xE2\xA5\xB5" }, { k: "rarrb", v: "\xE2\x87\xA5" }, { k: "rarrbfs", v: "\xE2\xA4\xA0" }, { k: "rarrc", v: "\xE2\xA4\xB3" }, { k: "rarrfs", v: "\xE2\xA4\x9E" }, { k: "rarrhk", v: "\xE2\x86\xAA" }, { k: "rarrlp", v: "\xE2\x86\xAC" }, { k: "rarrpl", v: "\xE2\xA5\x85" }, { k: "rarrsim", v: "\xE2\xA5\xB4" }, { k: "rarrtl", v: "\xE2\x86\xA3" }, { k: "rarrw", v: "\xE2\x86\x9D" }, { k: "ratail", v: "\xE2\xA4\x9A" }, { k: "ratio", v: "\xE2\x88\xB6" }, { k: "rationals", v: "\xE2\x84\x9A" }, { k: "rbarr", v: "\xE2\xA4\x8D" }, { k: "rbbrk", v: "\xE2\x9D\xB3" }, { k: "rbrace", v: "}" }, { k: "rbrack", v: "]" }, { k: "rbrke", v: "\xE2\xA6\x8C" }, { k: "rbrksld", v: "\xE2\xA6\x8E" }, { k: "rbrkslu", v: "\xE2\xA6\x90" }, { k: "rcaron", v: "\xC5\x99" }, { k: "rcedil", v: "\xC5\x97" }, { k: "rceil", v: "\xE2\x8C\x89" }, { k: "rcub", v: "}" }, { k: "rcy", v: "\xD1\x80" }, { k: "rdca", v: "\xE2\xA4\xB7" }, { k: "rdldhar", v: "\xE2\xA5\xA9" }, { k: "rdquo", v: "\xE2\x80\x9D" }, { k: "rdquor", v: "\xE2\x80\x9D" }, { k: "rdsh", v: "\xE2\x86\xB3" }, { k: "real", v: "\xE2\x84\x9C" }, { k: "realine", v: "\xE2\x84\x9B" }, { k: "realpart", v: "\xE2\x84\x9C" }, { k: "reals", v: "\xE2\x84\x9D" }, { k: "rect", v: "\xE2\x96\xAD" }, { k: "reg", v: "\xC2\xAE" }, { k: "rfisht", v: "\xE2\xA5\xBD" }, { k: "rfloor", v: "\xE2\x8C\x8B" }, { k: "rfr", v: "\xF0\x9D\x94\xAF" }, { k: "rhard", v: "\xE2\x87\x81" }, { k: "rharu", v: "\xE2\x87\x80" }, { k: "rharul", v: "\xE2\xA5\xAC" }, { k: "rho", v: "\xCF\x81" }, { k: "rhov", v: "\xCF\xB1" }, { k: "rightarrow", v: "\xE2\x86\x92" }, { k: "rightarrowtail", v: "\xE2\x86\xA3" }, { k: "rightharpoondown", v: "\xE2\x87\x81" }, { k: "rightharpoonup", v: "\xE2\x87\x80" }, { k: "rightleftarrows", v: "\xE2\x87\x84" }, { k: "rightleftharpoons", v: "\xE2\x87\x8C" }, { k: "rightrightarrows", v: "\xE2\x87\x89" }, { k: "rightsquigarrow", v: "\xE2\x86\x9D" }, { k: "rightthreetimes", v: "\xE2\x8B\x8C" }, { k: "ring", v: "\xCB\x9A" }, { k: "risingdotseq", v: "\xE2\x89\x93" }, { k: "rlarr", v: "\xE2\x87\x84" }, { k: "rlhar", v: "\xE2\x87\x8C" }, { k: "rlm", v: "\xE2\x80\x8F" }, { k: "rmoust", v: "\xE2\x8E\xB1" }, { k: "rmoustache", v: "\xE2\x8E\xB1" }, { k: "rnmid", v: "\xE2\xAB\xAE" }, { k: "roang", v: "\xE2\x9F\xAD" }, { k: "roarr", v: "\xE2\x87\xBE" }, { k: "robrk", v: "\xE2\x9F\xA7" }, { k: "ropar", v: "\xE2\xA6\x86" }, { k: "ropf", v: "\xF0\x9D\x95\xA3" }, { k: "roplus", v: "\xE2\xA8\xAE" }, { k: "rotimes", v: "\xE2\xA8\xB5" }, { k: "rpar", v: ")" }, { k: "rpargt", v: "\xE2\xA6\x94" }, { k: "rppolint", v: "\xE2\xA8\x92" }, { k: "rrarr", v: "\xE2\x87\x89" }, { k: "rsaquo", v: "\xE2\x80\xBA" }, { k: "rscr", v: "\xF0\x9D\x93\x87" }, { k: "rsh", v: "\xE2\x86\xB1" }, { k: "rsqb", v: "]" }, { k: "rsquo", v: "\xE2\x80\x99" }, { k: "rsquor", v: "\xE2\x80\x99" }, { k: "rthree", v: "\xE2\x8B\x8C" }, { k: "rtimes", v: "\xE2\x8B\x8A" }, { k: "rtri", v: "\xE2\x96\xB9" }, { k: "rtrie", v: "\xE2\x8A\xB5" }, { k: "rtrif", v: "\xE2\x96\xB8" }, { k: "rtriltri", v: "\xE2\xA7\x8E" }, { k: "ruluhar", v: "\xE2\xA5\xA8" }, { k: "rx", v: "\xE2\x84\x9E" }, { k: "sacute", v: "\xC5\x9B" }, { k: "sbquo", v: "\xE2\x80\x9A" }, { k: "sc", v: "\xE2\x89\xBB" }, { k: "scE", v: "\xE2\xAA\xB4" }, { k: "scap", v: "\xE2\xAA\xB8" }, { k: "scaron", v: "\xC5\xA1" }, { k: "sccue", v: "\xE2\x89\xBD" }, { k: "sce", v: "\xE2\xAA\xB0" }, { k: "scedil", v: "\xC5\x9F" }, { k: "scirc", v: "\xC5\x9D" }, { k: "scnE", v: "\xE2\xAA\xB6" }, { k: "scnap", v: "\xE2\xAA\xBA" }, { k: "scnsim", v: "\xE2\x8B\xA9" }, { k: "scpolint", v: "\xE2\xA8\x93" }, { k: "scsim", v: "\xE2\x89\xBF" }, { k: "scy", v: "\xD1\x81" }, { k: "sdot", v: "\xE2\x8B\x85" }, { k: "sdotb", v: "\xE2\x8A\xA1" }, { k: "sdote", v: "\xE2\xA9\xA6" }, { k: "seArr", v: "\xE2\x87\x98" }, { k: "searhk", v: "\xE2\xA4\xA5" }, { k: "searr", v: "\xE2\x86\x98" }, { k: "searrow", v: "\xE2\x86\x98" }, { k: "sect", v: "\xC2\xA7" }, { k: "semi", v: ";" }, { k: "seswar", v: "\xE2\xA4\xA9" }, { k: "setminus", v: "\xE2\x88\x96" }, { k: "setmn", v: "\xE2\x88\x96" }, { k: "sext", v: "\xE2\x9C\xB6" }, { k: "sfr", v: "\xF0\x9D\x94\xB0" }, { k: "sfrown", v: "\xE2\x8C\xA2" }, { k: "sharp", v: "\xE2\x99\xAF" }, { k: "shchcy", v: "\xD1\x89" }, { k: "shcy", v: "\xD1\x88" }, { k: "shortmid", v: "\xE2\x88\xA3" }, { k: "shortparallel", v: "\xE2\x88\xA5" }, { k: "shy", v: "\xC2\xAD" }, { k: "sigma", v: "\xCF\x83" }, { k: "sigmaf", v: "\xCF\x82" }, { k: "sigmav", v: "\xCF\x82" }, { k: "sim", v: "\xE2\x88\xBC" }, { k: "simdot", v: "\xE2\xA9\xAA" }, { k: "sime", v: "\xE2\x89\x83" }, { k: "simeq", v: "\xE2\x89\x83" }, { k: "simg", v: "\xE2\xAA\x9E" }, { k: "simgE", v: "\xE2\xAA\xA0" }, { k: "siml", v: "\xE2\xAA\x9D" }, { k: "simlE", v: "\xE2\xAA\x9F" }, { k: "simne", v: "\xE2\x89\x86" }, { k: "simplus", v: "\xE2\xA8\xA4" }, { k: "simrarr", v: "\xE2\xA5\xB2" }, { k: "slarr", v: "\xE2\x86\x90" }, { k: "smallsetminus", v: "\xE2\x88\x96" }, { k: "smashp", v: "\xE2\xA8\xB3" }, { k: "smeparsl", v: "\xE2\xA7\xA4" }, { k: "smid", v: "\xE2\x88\xA3" }, { k: "smile", v: "\xE2\x8C\xA3" }, { k: "smt", v: "\xE2\xAA\xAA" }, { k: "smte", v: "\xE2\xAA\xAC" }, { k: "smtes", v: "\xE2\xAA\xAC\xEF\xB8\x80" }, { k: "softcy", v: "\xD1\x8C" }, { k: "sol", v: "/" }, { k: "solb", v: "\xE2\xA7\x84" }, { k: "solbar", v: "\xE2\x8C\xBF" }, { k: "sopf", v: "\xF0\x9D\x95\xA4" }, { k: "spades", v: "\xE2\x99\xA0" }, { k: "spadesuit", v: "\xE2\x99\xA0" }, { k: "spar", v: "\xE2\x88\xA5" }, { k: "sqcap", v: "\xE2\x8A\x93" }, { k: "sqcaps", v: "\xE2\x8A\x93\xEF\xB8\x80" }, { k: "sqcup", v: "\xE2\x8A\x94" }, { k: "sqcups", v: "\xE2\x8A\x94\xEF\xB8\x80" }, { k: "sqsub", v: "\xE2\x8A\x8F" }, { k: "sqsube", v: "\xE2\x8A\x91" }, { k: "sqsubset", v: "\xE2\x8A\x8F" }, { k: "sqsubseteq", v: "\xE2\x8A\x91" }, { k: "sqsup", v: "\xE2\x8A\x90" }, { k: "sqsupe", v: "\xE2\x8A\x92" }, { k: "sqsupset", v: "\xE2\x8A\x90" }, { k: "sqsupseteq", v: "\xE2\x8A\x92" }, { k: "squ", v: "\xE2\x96\xA1" }, { k: "square", v: "\xE2\x96\xA1" }, { k: "squarf", v: "\xE2\x96\xAA" }, { k: "squf", v: "\xE2\x96\xAA" }, { k: "srarr", v: "\xE2\x86\x92" }, { k: "sscr", v: "\xF0\x9D\x93\x88" }, { k: "ssetmn", v: "\xE2\x88\x96" }, { k: "ssmile", v: "\xE2\x8C\xA3" }, { k: "sstarf", v: "\xE2\x8B\x86" }, { k: "star", v: "\xE2\x98\x86" }, { k: "starf", v: "\xE2\x98\x85" }, { k: "straightepsilon", v: "\xCF\xB5" }, { k: "straightphi", v: "\xCF\x95" }, { k: "strns", v: "\xC2\xAF" }, { k: "sub", v: "\xE2\x8A\x82" }, { k: "subE", v: "\xE2\xAB\x85" }, { k: "subdot", v: "\xE2\xAA\xBD" }, { k: "sube", v: "\xE2\x8A\x86" }, { k: "subedot", v: "\xE2\xAB\x83" }, { k: "submult", v: "\xE2\xAB\x81" }, { k: "subnE", v: "\xE2\xAB\x8B" }, { k: "subne", v: "\xE2\x8A\x8A" }, { k: "subplus", v: "\xE2\xAA\xBF" }, { k: "subrarr", v: "\xE2\xA5\xB9" }, { k: "subset", v: "\xE2\x8A\x82" }, { k: "subseteq", v: "\xE2\x8A\x86" }, { k: "subseteqq", v: "\xE2\xAB\x85" }, { k: "subsetneq", v: "\xE2\x8A\x8A" }, { k: "subsetneqq", v: "\xE2\xAB\x8B" }, { k: "subsim", v: "\xE2\xAB\x87" }, { k: "subsub", v: "\xE2\xAB\x95" }, { k: "subsup", v: "\xE2\xAB\x93" }, { k: "succ", v: "\xE2\x89\xBB" }, { k: "succapprox", v: "\xE2\xAA\xB8" }, { k: "succcurlyeq", v: "\xE2\x89\xBD" }, { k: "succeq", v: "\xE2\xAA\xB0" }, { k: "succnapprox", v: "\xE2\xAA\xBA" }, { k: "succneqq", v: "\xE2\xAA\xB6" }, { k: "succnsim", v: "\xE2\x8B\xA9" }, { k: "succsim", v: "\xE2\x89\xBF" }, { k: "sum", v: "\xE2\x88\x91" }, { k: "sung", v: "\xE2\x99\xAA" }, { k: "sup", v: "\xE2\x8A\x83" }, { k: "sup1", v: "\xC2\xB9" }, { k: "sup2", v: "\xC2\xB2" }, { k: "sup3", v: "\xC2\xB3" }, { k: "supE", v: "\xE2\xAB\x86" }, { k: "supdot", v: "\xE2\xAA\xBE" }, { k: "supdsub", v: "\xE2\xAB\x98" }, { k: "supe", v: "\xE2\x8A\x87" }, { k: "supedot", v: "\xE2\xAB\x84" }, { k: "suphsol", v: "\xE2\x9F\x89" }, { k: "suphsub", v: "\xE2\xAB\x97" }, { k: "suplarr", v: "\xE2\xA5\xBB" }, { k: "supmult", v: "\xE2\xAB\x82" }, { k: "supnE", v: "\xE2\xAB\x8C" }, { k: "supne", v: "\xE2\x8A\x8B" }, { k: "supplus", v: "\xE2\xAB\x80" }, { k: "supset", v: "\xE2\x8A\x83" }, { k: "supseteq", v: "\xE2\x8A\x87" }, { k: "supseteqq", v: "\xE2\xAB\x86" }, { k: "supsetneq", v: "\xE2\x8A\x8B" }, { k: "supsetneqq", v: "\xE2\xAB\x8C" }, { k: "supsim", v: "\xE2\xAB\x88" }, { k: "supsub", v: "\xE2\xAB\x94" }, { k: "supsup", v: "\xE2\xAB\x96" }, { k: "swArr", v: "\xE2\x87\x99" }, { k: "swarhk", v: "\xE2\xA4\xA6" }, { k: "swarr", v: "\xE2\x86\x99" }, { k: "swarrow", v: "\xE2\x86\x99" }, { k: "swnwar", v: "\xE2\xA4\xAA" }, { k: "szlig", v: "\xC3\x9F" }, { k: "target", v: "\xE2\x8C\x96" }, { k: "tau", v: "\xCF\x84" }, { k: "tbrk", v: "\xE2\x8E\xB4" }, { k: "tcaron", v: "\xC5\xA5" }, { k: "tcedil", v: "\xC5\xA3" }, { k: "tcy", v: "\xD1\x82" }, { k: "tdot", v: "\xE2\x83\x9B" }, { k: "telrec", v: "\xE2\x8C\x95" }, { k: "tfr", v: "\xF0\x9D\x94\xB1" }, { k: "there4", v: "\xE2\x88\xB4" }, { k: "therefore", v: "\xE2\x88\xB4" }, { k: "theta", v: "\xCE\xB8" }, { k: "thetasym", v: "\xCF\x91" }, { k: "thetav", v: "\xCF\x91" }, { k: "thickapprox", v: "\xE2\x89\x88" }, { k: "thicksim", v: "\xE2\x88\xBC" }, { k: "thinsp", v: "\xE2\x80\x89" }, { k: "thkap", v: "\xE2\x89\x88" }, { k: "thksim", v: "\xE2\x88\xBC" }, { k: "thorn", v: "\xC3\xBE" }, { k: "tilde", v: "\xCB\x9C" }, { k: "times", v: "\xC3\x97" }, { k: "timesb", v: "\xE2\x8A\xA0" }, { k: "timesbar", v: "\xE2\xA8\xB1" }, { k: "timesd", v: "\xE2\xA8\xB0" }, { k: "tint", v: "\xE2\x88\xAD" }, { k: "toea", v: "\xE2\xA4\xA8" }, { k: "top", v: "\xE2\x8A\xA4" }, { k: "topbot", v: "\xE2\x8C\xB6" }, { k: "topcir", v: "\xE2\xAB\xB1" }, { k: "topf", v: "\xF0\x9D\x95\xA5" }, { k: "topfork", v: "\xE2\xAB\x9A" }, { k: "tosa", v: "\xE2\xA4\xA9" }, { k: "tprime", v: "\xE2\x80\xB4" }, { k: "trade", v: "\xE2\x84\xA2" }, { k: "triangle", v: "\xE2\x96\xB5" }, { k: "triangledown", v: "\xE2\x96\xBF" }, { k: "triangleleft", v: "\xE2\x97\x83" }, { k: "trianglelefteq", v: "\xE2\x8A\xB4" }, { k: "triangleq", v: "\xE2\x89\x9C" }, { k: "triangleright", v: "\xE2\x96\xB9" }, { k: "trianglerighteq", v: "\xE2\x8A\xB5" }, { k: "tridot", v: "\xE2\x97\xAC" }, { k: "trie", v: "\xE2\x89\x9C" }, { k: "triminus", v: "\xE2\xA8\xBA" }, { k: "triplus", v: "\xE2\xA8\xB9" }, { k: "trisb", v: "\xE2\xA7\x8D" }, { k: "tritime", v: "\xE2\xA8\xBB" }, { k: "trpezium", v: "\xE2\x8F\xA2" }, { k: "tscr", v: "\xF0\x9D\x93\x89" }, { k: "tscy", v: "\xD1\x86" }, { k: "tshcy", v: "\xD1\x9B" }, { k: "tstrok", v: "\xC5\xA7" }, { k: "twixt", v: "\xE2\x89\xAC" }, { k: "twoheadleftarrow", v: "\xE2\x86\x9E" }, { k: "twoheadrightarrow", v: "\xE2\x86\xA0" }, { k: "uArr", v: "\xE2\x87\x91" }, { k: "uHar", v: "\xE2\xA5\xA3" }, { k: "uacute", v: "\xC3\xBA" }, { k: "uarr", v: "\xE2\x86\x91" }, { k: "ubrcy", v: "\xD1\x9E" }, { k: "ubreve", v: "\xC5\xAD" }, { k: "ucirc", v: "\xC3\xBB" }, { k: "ucy", v: "\xD1\x83" }, { k: "udarr", v: "\xE2\x87\x85" }, { k: "udblac", v: "\xC5\xB1" }, { k: "udhar", v: "\xE2\xA5\xAE" }, { k: "ufisht", v: "\xE2\xA5\xBE" }, { k: "ufr", v: "\xF0\x9D\x94\xB2" }, { k: "ugrave", v: "\xC3\xB9" }, { k: "uharl", v: "\xE2\x86\xBF" }, { k: "uharr", v: "\xE2\x86\xBE" }, { k: "uhblk", v: "\xE2\x96\x80" }, { k: "ulcorn", v: "\xE2\x8C\x9C" }, { k: "ulcorner", v: "\xE2\x8C\x9C" }, { k: "ulcrop", v: "\xE2\x8C\x8F" }, { k: "ultri", v: "\xE2\x97\xB8" }, { k: "umacr", v: "\xC5\xAB" }, { k: "uml", v: "\xC2\xA8" }, { k: "uogon", v: "\xC5\xB3" }, { k: "uopf", v: "\xF0\x9D\x95\xA6" }, { k: "uparrow", v: "\xE2\x86\x91" }, { k: "updownarrow", v: "\xE2\x86\x95" }, { k: "upharpoonleft", v: "\xE2\x86\xBF" }, { k: "upharpoonright", v: "\xE2\x86\xBE" }, { k: "uplus", v: "\xE2\x8A\x8E" }, { k: "upsi", v: "\xCF\x85" }, { k: "upsih", v: "\xCF\x92" }, { k: "upsilon", v: "\xCF\x85" }, { k: "upuparrows", v: "\xE2\x87\x88" }, { k: "urcorn", v: "\xE2\x8C\x9D" }, { k: "urcorner", v: "\xE2\x8C\x9D" }, { k: "urcrop", v: "\xE2\x8C\x8E" }, { k: "uring", v: "\xC5\xAF" }, { k: "urtri", v: "\xE2\x97\xB9" }, { k: "uscr", v: "\xF0\x9D\x93\x8A" }, { k: "utdot", v: "\xE2\x8B\xB0" }, { k: "utilde", v: "\xC5\xA9" }, { k: "utri", v: "\xE2\x96\xB5" }, { k: "utrif", v: "\xE2\x96\xB4" }, { k: "uuarr", v: "\xE2\x87\x88" }, { k: "uuml", v: "\xC3\xBC" }, { k: "uwangle", v: "\xE2\xA6\xA7" }, { k: "vArr", v: "\xE2\x87\x95" }, { k: "vBar", v: "\xE2\xAB\xA8" }, { k: "vBarv", v: "\xE2\xAB\xA9" }, { k: "vDash", v: "\xE2\x8A\xA8" }, { k: "vangrt", v: "\xE2\xA6\x9C" }, { k: "varepsilon", v: "\xCF\xB5" }, { k: "varkappa", v: "\xCF\xB0" }, { k: "varnothing", v: "\xE2\x88\x85" }, { k: "varphi", v: "\xCF\x95" }, { k: "varpi", v: "\xCF\x96" }, { k: "varpropto", v: "\xE2\x88\x9D" }, { k: "varr", v: "\xE2\x86\x95" }, { k: "varrho", v: "\xCF\xB1" }, { k: "varsigma", v: "\xCF\x82" }, { k: "varsubsetneq", v: "\xE2\x8A\x8A\xEF\xB8\x80" }, { k: "varsubsetneqq", v: "\xE2\xAB\x8B\xEF\xB8\x80" }, { k: "varsupsetneq", v: "\xE2\x8A\x8B\xEF\xB8\x80" }, { k: "varsupsetneqq", v: "\xE2\xAB\x8C\xEF\xB8\x80" }, { k: "vartheta", v: "\xCF\x91" }, { k: "vartriangleleft", v: "\xE2\x8A\xB2" }, { k: "vartriangleright", v: "\xE2\x8A\xB3" }, { k: "vcy", v: "\xD0\xB2" }, { k: "vdash", v: "\xE2\x8A\xA2" }, { k: "vee", v: "\xE2\x88\xA8" }, { k: "veebar", v: "\xE2\x8A\xBB" }, { k: "veeeq", v: "\xE2\x89\x9A" }, { k: "vellip", v: "\xE2\x8B\xAE" }, { k: "verbar", v: "|" }, { k: "vert", v: "|" }, { k: "vfr", v: "\xF0\x9D\x94\xB3" }, { k: "vltri", v: "\xE2\x8A\xB2" }, { k: "vnsub", v: "\xE2\x8A\x82\xE2\x83\x92" }, { k: "vnsup", v: "\xE2\x8A\x83\xE2\x83\x92" }, { k: "vopf", v: "\xF0\x9D\x95\xA7" }, { k: "vprop", v: "\xE2\x88\x9D" }, { k: "vrtri", v: "\xE2\x8A\xB3" }, { k: "vscr", v: "\xF0\x9D\x93\x8B" }, { k: "vsubnE", v: "\xE2\xAB\x8B\xEF\xB8\x80" }, { k: "vsubne", v: "\xE2\x8A\x8A\xEF\xB8\x80" }, { k: "vsupnE", v: "\xE2\xAB\x8C\xEF\xB8\x80" }, { k: "vsupne", v: "\xE2\x8A\x8B\xEF\xB8\x80" }, { k: "vzigzag", v: "\xE2\xA6\x9A" }, { k: "wcirc", v: "\xC5\xB5" }, { k: "wedbar", v: "\xE2\xA9\x9F" }, { k: "wedge", v: "\xE2\x88\xA7" }, { k: "wedgeq", v: "\xE2\x89\x99" }, { k: "weierp", v: "\xE2\x84\x98" }, { k: "wfr", v: "\xF0\x9D\x94\xB4" }, { k: "wopf", v: "\xF0\x9D\x95\xA8" }, { k: "wp", v: "\xE2\x84\x98" }, { k: "wr", v: "\xE2\x89\x80" }, { k: "wreath", v: "\xE2\x89\x80" }, { k: "wscr", v: "\xF0\x9D\x93\x8C" }, { k: "xcap", v: "\xE2\x8B\x82" }, { k: "xcirc", v: "\xE2\x97\xAF" }, { k: "xcup", v: "\xE2\x8B\x83" }, { k: "xdtri", v: "\xE2\x96\xBD" }, { k: "xfr", v: "\xF0\x9D\x94\xB5" }, { k: "xhArr", v: "\xE2\x9F\xBA" }, { k: "xharr", v: "\xE2\x9F\xB7" }, { k: "xi", v: "\xCE\xBE" }, { k: "xlArr", v: "\xE2\x9F\xB8" }, { k: "xlarr", v: "\xE2\x9F\xB5" }, { k: "xmap", v: "\xE2\x9F\xBC" }, { k: "xnis", v: "\xE2\x8B\xBB" }, { k: "xodot", v: "\xE2\xA8\x80" }, { k: "xopf", v: "\xF0\x9D\x95\xA9" }, { k: "xoplus", v: "\xE2\xA8\x81" }, { k: "xotime", v: "\xE2\xA8\x82" }, { k: "xrArr", v: "\xE2\x9F\xB9" }, { k: "xrarr", v: "\xE2\x9F\xB6" }, { k: "xscr", v: "\xF0\x9D\x93\x8D" }, { k: "xsqcup", v: "\xE2\xA8\x86" }, { k: "xuplus", v: "\xE2\xA8\x84" }, { k: "xutri", v: "\xE2\x96\xB3" }, { k: "xvee", v: "\xE2\x8B\x81" }, { k: "xwedge", v: "\xE2\x8B\x80" }, { k: "yacute", v: "\xC3\xBD" }, { k: "yacy", v: "\xD1\x8F" }, { k: "ycirc", v: "\xC5\xB7" }, { k: "ycy", v: "\xD1\x8B" }, { k: "yen", v: "\xC2\xA5" }, { k: "yfr", v: "\xF0\x9D\x94\xB6" }, { k: "yicy", v: "\xD1\x97" }, { k: "yopf", v: "\xF0\x9D\x95\xAA" }, { k: "yscr", v: "\xF0\x9D\x93\x8E" }, { k: "yucy", v: "\xD1\x8E" }, { k: "yuml", v: "\xC3\xBF" }, { k: "zacute", v: "\xC5\xBA" }, { k: "zcaron", v: "\xC5\xBE" }, { k: "zcy", v: "\xD0\xB7" }, { k: "zdot", v: "\xC5\xBC" }, { k: "zeetrf", v: "\xE2\x84\xA8" }, { k: "zeta", v: "\xCE\xB6" }, { k: "zfr", v: "\xF0\x9D\x94\xB7" }, { k: "zhcy", v: "\xD0\xB6" }, { k: "zigrarr", v: "\xE2\x87\x9D" }, { k: "zopf", v: "\xF0\x9D\x95\xAB" }, { k: "zscr", v: "\xF0\x9D\x93\x8F" }, { k: "zwj", v: "\xE2\x80\x8D" }, { k: "zwnj", v: "\xE2\x80\x8C" }]);
		replacementTable = $toNativeArray($kindInt32, [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376]);
		breakout = $makeMap($String.keyFor, [{ k: "b", v: true }, { k: "big", v: true }, { k: "blockquote", v: true }, { k: "body", v: true }, { k: "br", v: true }, { k: "center", v: true }, { k: "code", v: true }, { k: "dd", v: true }, { k: "div", v: true }, { k: "dl", v: true }, { k: "dt", v: true }, { k: "em", v: true }, { k: "embed", v: true }, { k: "h1", v: true }, { k: "h2", v: true }, { k: "h3", v: true }, { k: "h4", v: true }, { k: "h5", v: true }, { k: "h6", v: true }, { k: "head", v: true }, { k: "hr", v: true }, { k: "i", v: true }, { k: "img", v: true }, { k: "li", v: true }, { k: "listing", v: true }, { k: "menu", v: true }, { k: "meta", v: true }, { k: "nobr", v: true }, { k: "ol", v: true }, { k: "p", v: true }, { k: "pre", v: true }, { k: "ruby", v: true }, { k: "s", v: true }, { k: "small", v: true }, { k: "span", v: true }, { k: "strong", v: true }, { k: "strike", v: true }, { k: "sub", v: true }, { k: "sup", v: true }, { k: "table", v: true }, { k: "tt", v: true }, { k: "u", v: true }, { k: "ul", v: true }, { k: "var", v: true }]);
		svgTagNameAdjustments = $makeMap($String.keyFor, [{ k: "altglyph", v: "altGlyph" }, { k: "altglyphdef", v: "altGlyphDef" }, { k: "altglyphitem", v: "altGlyphItem" }, { k: "animatecolor", v: "animateColor" }, { k: "animatemotion", v: "animateMotion" }, { k: "animatetransform", v: "animateTransform" }, { k: "clippath", v: "clipPath" }, { k: "feblend", v: "feBlend" }, { k: "fecolormatrix", v: "feColorMatrix" }, { k: "fecomponenttransfer", v: "feComponentTransfer" }, { k: "fecomposite", v: "feComposite" }, { k: "feconvolvematrix", v: "feConvolveMatrix" }, { k: "fediffuselighting", v: "feDiffuseLighting" }, { k: "fedisplacementmap", v: "feDisplacementMap" }, { k: "fedistantlight", v: "feDistantLight" }, { k: "feflood", v: "feFlood" }, { k: "fefunca", v: "feFuncA" }, { k: "fefuncb", v: "feFuncB" }, { k: "fefuncg", v: "feFuncG" }, { k: "fefuncr", v: "feFuncR" }, { k: "fegaussianblur", v: "feGaussianBlur" }, { k: "feimage", v: "feImage" }, { k: "femerge", v: "feMerge" }, { k: "femergenode", v: "feMergeNode" }, { k: "femorphology", v: "feMorphology" }, { k: "feoffset", v: "feOffset" }, { k: "fepointlight", v: "fePointLight" }, { k: "fespecularlighting", v: "feSpecularLighting" }, { k: "fespotlight", v: "feSpotLight" }, { k: "fetile", v: "feTile" }, { k: "feturbulence", v: "feTurbulence" }, { k: "foreignobject", v: "foreignObject" }, { k: "glyphref", v: "glyphRef" }, { k: "lineargradient", v: "linearGradient" }, { k: "radialgradient", v: "radialGradient" }, { k: "textpath", v: "textPath" }]);
		mathMLAttributeAdjustments = $makeMap($String.keyFor, [{ k: "definitionurl", v: "definitionURL" }]);
		svgAttributeAdjustments = $makeMap($String.keyFor, [{ k: "attributename", v: "attributeName" }, { k: "attributetype", v: "attributeType" }, { k: "basefrequency", v: "baseFrequency" }, { k: "baseprofile", v: "baseProfile" }, { k: "calcmode", v: "calcMode" }, { k: "clippathunits", v: "clipPathUnits" }, { k: "contentscripttype", v: "contentScriptType" }, { k: "contentstyletype", v: "contentStyleType" }, { k: "diffuseconstant", v: "diffuseConstant" }, { k: "edgemode", v: "edgeMode" }, { k: "externalresourcesrequired", v: "externalResourcesRequired" }, { k: "filterres", v: "filterRes" }, { k: "filterunits", v: "filterUnits" }, { k: "glyphref", v: "glyphRef" }, { k: "gradienttransform", v: "gradientTransform" }, { k: "gradientunits", v: "gradientUnits" }, { k: "kernelmatrix", v: "kernelMatrix" }, { k: "kernelunitlength", v: "kernelUnitLength" }, { k: "keypoints", v: "keyPoints" }, { k: "keysplines", v: "keySplines" }, { k: "keytimes", v: "keyTimes" }, { k: "lengthadjust", v: "lengthAdjust" }, { k: "limitingconeangle", v: "limitingConeAngle" }, { k: "markerheight", v: "markerHeight" }, { k: "markerunits", v: "markerUnits" }, { k: "markerwidth", v: "markerWidth" }, { k: "maskcontentunits", v: "maskContentUnits" }, { k: "maskunits", v: "maskUnits" }, { k: "numoctaves", v: "numOctaves" }, { k: "pathlength", v: "pathLength" }, { k: "patterncontentunits", v: "patternContentUnits" }, { k: "patterntransform", v: "patternTransform" }, { k: "patternunits", v: "patternUnits" }, { k: "pointsatx", v: "pointsAtX" }, { k: "pointsaty", v: "pointsAtY" }, { k: "pointsatz", v: "pointsAtZ" }, { k: "preservealpha", v: "preserveAlpha" }, { k: "preserveaspectratio", v: "preserveAspectRatio" }, { k: "primitiveunits", v: "primitiveUnits" }, { k: "refx", v: "refX" }, { k: "refy", v: "refY" }, { k: "repeatcount", v: "repeatCount" }, { k: "repeatdur", v: "repeatDur" }, { k: "requiredextensions", v: "requiredExtensions" }, { k: "requiredfeatures", v: "requiredFeatures" }, { k: "specularconstant", v: "specularConstant" }, { k: "specularexponent", v: "specularExponent" }, { k: "spreadmethod", v: "spreadMethod" }, { k: "startoffset", v: "startOffset" }, { k: "stddeviation", v: "stdDeviation" }, { k: "stitchtiles", v: "stitchTiles" }, { k: "surfacescale", v: "surfaceScale" }, { k: "systemlanguage", v: "systemLanguage" }, { k: "tablevalues", v: "tableValues" }, { k: "targetx", v: "targetX" }, { k: "targety", v: "targetY" }, { k: "textlength", v: "textLength" }, { k: "viewbox", v: "viewBox" }, { k: "viewtarget", v: "viewTarget" }, { k: "xchannelselector", v: "xChannelSelector" }, { k: "ychannelselector", v: "yChannelSelector" }, { k: "zoomandpan", v: "zoomAndPan" }]);
		scopeMarker = new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 6, 0, "", "", sliceType$1.nil);
		defaultScopeStopTags = $makeMap($String.keyFor, [{ k: "", v: new sliceType$2([203014, 143623, 22020, 365829, 37378, 87554, 206599, 157702, 463880]) }, { k: "math", v: new sliceType$2([117006, 214786, 176386, 41986, 422914, 217349]) }, { k: "svg", v: new sliceType$2([352516, 152589, 69637]) }]);
		plaintextAbort = errors.New("html: internal error (plaintext abort)");
		$pkg.ErrBufferExceeded = errors.New("max buffer exceeded");
		nul = (new sliceType$3($stringToBytes("\x00")));
		replacement = (new sliceType$3($stringToBytes("\xEF\xBF\xBD")));
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/b3log/lute"] = (function() {
	var $pkg = {}, $init, bytes, errors, html, atom, strconv, strings, sync, unicode, utf8, blockStartFunc, delimiter, EChartsJSONRenderer, FormatRenderer, HTMLRenderer, lexer, listData, Lute, options, option, Node, nodeType, Context, InlineContext, Tree, RendererFunc, Renderer, BaseRenderer, VditorRenderer, WalkStatus, sliceType, sliceType$1, sliceType$2, ptrType, ptrType$1, sliceType$3, ptrType$2, ptrType$3, ptrType$4, sliceType$4, sliceType$5, sliceType$6, ptrType$5, ptrType$6, arrayType, ptrType$7, ptrType$8, ptrType$9, ptrType$10, ptrType$11, ptrType$12, sliceType$7, ptrType$13, ptrType$14, sliceType$8, ptrType$15, ptrType$16, ptrType$17, mapType, mapType$1, mapType$2, ptrType$18, mailto, httpProto, validAutoLinkDomainSuffix, markers, blockStarts, codeBlockBacktick, emojiSitePlaceholder, emojiDot, unicodeAliasEmojiMap, aliasUnicodeEmojiMap, amp, lt, gt, quot, htmlBlockTags1, htmlBlockCloseTags1, htmlBlockTags6, htmlBlockSinglequote, htmlBlockDoublequote, htmlBlockGreater, backslash, dollar, items1, mathBlockMarker, mathBlockDollar, terms, newEmojis, init, escapeHTML, encodeDestination, bytesToStr, strToBytes, newLexer, New, recoverPanic, space0, addSpaceAtBoundary, isAllowSpace, isNotTerm, newTerms, isWhitespace, isUnicodeWhitespace, isDigit, isHexDigit, tokenToUpper, isASCIIPunct, isASCIILetter, isASCIILetterNum, isASCIILetterNumHyphen, isControl, isBlank, split, splitWithoutBackslashEscape, replaceNewlineSpace, trimWhitespace, trim, trimRight, trimLeft, accept, acceptTokenss, acceptTokens, isBlankLine, splitWhitespace, isBackslashEscapePunct, statWhitespace, spnl, peek, unescapeString, htmlUnescapeString, parseEntity, isValidEntityCode, Walk;
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	html = $packages["github.com/b3log/lute/html"];
	atom = $packages["github.com/b3log/lute/html/atom"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	sync = $packages["sync"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	blockStartFunc = $pkg.blockStartFunc = $newType(4, $kindFunc, "lute.blockStartFunc", true, "github.com/b3log/lute", false, null);
	delimiter = $pkg.delimiter = $newType(0, $kindStruct, "lute.delimiter", true, "github.com/b3log/lute", false, function(node_, typ_, num_, originalNum_, canOpen_, canClose_, previous_, next_, active_, image_, bracketAfter_, index_, previousDelimiter_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.node = ptrType.nil;
			this.typ = 0;
			this.num = 0;
			this.originalNum = 0;
			this.canOpen = false;
			this.canClose = false;
			this.previous = ptrType$2.nil;
			this.next = ptrType$2.nil;
			this.active = false;
			this.image = false;
			this.bracketAfter = false;
			this.index = 0;
			this.previousDelimiter = ptrType$2.nil;
			return;
		}
		this.node = node_;
		this.typ = typ_;
		this.num = num_;
		this.originalNum = originalNum_;
		this.canOpen = canOpen_;
		this.canClose = canClose_;
		this.previous = previous_;
		this.next = next_;
		this.active = active_;
		this.image = image_;
		this.bracketAfter = bracketAfter_;
		this.index = index_;
		this.previousDelimiter = previousDelimiter_;
	});
	EChartsJSONRenderer = $pkg.EChartsJSONRenderer = $newType(0, $kindStruct, "lute.EChartsJSONRenderer", true, "github.com/b3log/lute", true, function(BaseRenderer_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$3.nil;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
	});
	FormatRenderer = $pkg.FormatRenderer = $newType(0, $kindStruct, "lute.FormatRenderer", true, "github.com/b3log/lute", true, function(BaseRenderer_, nodeWriterStack_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$3.nil;
			this.nodeWriterStack = sliceType$4.nil;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
		this.nodeWriterStack = nodeWriterStack_;
	});
	HTMLRenderer = $pkg.HTMLRenderer = $newType(0, $kindStruct, "lute.HTMLRenderer", true, "github.com/b3log/lute", true, function(BaseRenderer_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$3.nil;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
	});
	lexer = $pkg.lexer = $newType(0, $kindStruct, "lute.lexer", true, "github.com/b3log/lute", false, function(input_, length_, offset_, ln_, col_, width_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.input = sliceType.nil;
			this.length = 0;
			this.offset = 0;
			this.ln = 0;
			this.col = 0;
			this.width = 0;
			return;
		}
		this.input = input_;
		this.length = length_;
		this.offset = offset_;
		this.ln = ln_;
		this.col = col_;
		this.width = width_;
	});
	listData = $pkg.listData = $newType(0, $kindStruct, "lute.listData", true, "github.com/b3log/lute", false, function(typ_, tight_, bulletChar_, start_, delimiter_, padding_, markerOffset_, checked_, marker_, num_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.typ = 0;
			this.tight = false;
			this.bulletChar = sliceType.nil;
			this.start = 0;
			this.delimiter = 0;
			this.padding = 0;
			this.markerOffset = 0;
			this.checked = false;
			this.marker = sliceType.nil;
			this.num = 0;
			return;
		}
		this.typ = typ_;
		this.tight = tight_;
		this.bulletChar = bulletChar_;
		this.start = start_;
		this.delimiter = delimiter_;
		this.padding = padding_;
		this.markerOffset = markerOffset_;
		this.checked = checked_;
		this.marker = marker_;
		this.num = num_;
	});
	Lute = $pkg.Lute = $newType(0, $kindStruct, "lute.Lute", true, "github.com/b3log/lute", true, function(options_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.options = ptrType$10.nil;
			return;
		}
		this.options = options_;
	});
	options = $pkg.options = $newType(0, $kindStruct, "lute.options", true, "github.com/b3log/lute", false, function(GFMTable_, GFMTaskListItem_, GFMTaskListItemClass_, GFMStrikethrough_, GFMAutoLink_, SoftBreak2HardBreak_, CodeSyntaxHighlight_, CodeSyntaxHighlightInlineStyle_, CodeSyntaxHighlightLineNum_, CodeSyntaxHighlightStyleName_, AutoSpace_, FixTermTypo_, Emoji_, AliasEmoji_, EmojiAlias_, EmojiSite_, HeadingAnchor_, Terms_, VditorWYSIWYG_, ParallelParsing_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.GFMTable = false;
			this.GFMTaskListItem = false;
			this.GFMTaskListItemClass = "";
			this.GFMStrikethrough = false;
			this.GFMAutoLink = false;
			this.SoftBreak2HardBreak = false;
			this.CodeSyntaxHighlight = false;
			this.CodeSyntaxHighlightInlineStyle = false;
			this.CodeSyntaxHighlightLineNum = false;
			this.CodeSyntaxHighlightStyleName = "";
			this.AutoSpace = false;
			this.FixTermTypo = false;
			this.Emoji = false;
			this.AliasEmoji = false;
			this.EmojiAlias = false;
			this.EmojiSite = "";
			this.HeadingAnchor = false;
			this.Terms = false;
			this.VditorWYSIWYG = false;
			this.ParallelParsing = false;
			return;
		}
		this.GFMTable = GFMTable_;
		this.GFMTaskListItem = GFMTaskListItem_;
		this.GFMTaskListItemClass = GFMTaskListItemClass_;
		this.GFMStrikethrough = GFMStrikethrough_;
		this.GFMAutoLink = GFMAutoLink_;
		this.SoftBreak2HardBreak = SoftBreak2HardBreak_;
		this.CodeSyntaxHighlight = CodeSyntaxHighlight_;
		this.CodeSyntaxHighlightInlineStyle = CodeSyntaxHighlightInlineStyle_;
		this.CodeSyntaxHighlightLineNum = CodeSyntaxHighlightLineNum_;
		this.CodeSyntaxHighlightStyleName = CodeSyntaxHighlightStyleName_;
		this.AutoSpace = AutoSpace_;
		this.FixTermTypo = FixTermTypo_;
		this.Emoji = Emoji_;
		this.AliasEmoji = AliasEmoji_;
		this.EmojiAlias = EmojiAlias_;
		this.EmojiSite = EmojiSite_;
		this.HeadingAnchor = HeadingAnchor_;
		this.Terms = Terms_;
		this.VditorWYSIWYG = VditorWYSIWYG_;
		this.ParallelParsing = ParallelParsing_;
	});
	option = $pkg.option = $newType(4, $kindFunc, "lute.option", true, "github.com/b3log/lute", false, null);
	Node = $pkg.Node = $newType(0, $kindStruct, "lute.Node", true, "github.com/b3log/lute", true, function(typ_, parent_, previous_, next_, firstChild_, lastChild_, rawText_, tokens_, close_, lastLineBlank_, lastLineChecked_, codeMarkerLen_, isFencedCodeBlock_, codeBlockFenceChar_, codeBlockFenceLen_, codeBlockFenceOffset_, codeBlockOpenFence_, codeBlockInfo_, codeBlockCloseFence_, htmlBlockType_, listData_, taskListItemChecked_, tableAligns_, tableCellAlign_, linkType_, headingLevel_, mathBlockDollarOffset_, expand_, caretStartOffset_, caretEndOffset_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.typ = 0;
			this.parent = ptrType.nil;
			this.previous = ptrType.nil;
			this.next = ptrType.nil;
			this.firstChild = ptrType.nil;
			this.lastChild = ptrType.nil;
			this.rawText = "";
			this.tokens = sliceType.nil;
			this.close = false;
			this.lastLineBlank = false;
			this.lastLineChecked = false;
			this.codeMarkerLen = 0;
			this.isFencedCodeBlock = false;
			this.codeBlockFenceChar = 0;
			this.codeBlockFenceLen = 0;
			this.codeBlockFenceOffset = 0;
			this.codeBlockOpenFence = sliceType.nil;
			this.codeBlockInfo = sliceType.nil;
			this.codeBlockCloseFence = sliceType.nil;
			this.htmlBlockType = 0;
			this.listData = ptrType$1.nil;
			this.taskListItemChecked = false;
			this.tableAligns = sliceType$3.nil;
			this.tableCellAlign = 0;
			this.linkType = 0;
			this.headingLevel = 0;
			this.mathBlockDollarOffset = 0;
			this.expand = false;
			this.caretStartOffset = "";
			this.caretEndOffset = "";
			return;
		}
		this.typ = typ_;
		this.parent = parent_;
		this.previous = previous_;
		this.next = next_;
		this.firstChild = firstChild_;
		this.lastChild = lastChild_;
		this.rawText = rawText_;
		this.tokens = tokens_;
		this.close = close_;
		this.lastLineBlank = lastLineBlank_;
		this.lastLineChecked = lastLineChecked_;
		this.codeMarkerLen = codeMarkerLen_;
		this.isFencedCodeBlock = isFencedCodeBlock_;
		this.codeBlockFenceChar = codeBlockFenceChar_;
		this.codeBlockFenceLen = codeBlockFenceLen_;
		this.codeBlockFenceOffset = codeBlockFenceOffset_;
		this.codeBlockOpenFence = codeBlockOpenFence_;
		this.codeBlockInfo = codeBlockInfo_;
		this.codeBlockCloseFence = codeBlockCloseFence_;
		this.htmlBlockType = htmlBlockType_;
		this.listData = listData_;
		this.taskListItemChecked = taskListItemChecked_;
		this.tableAligns = tableAligns_;
		this.tableCellAlign = tableCellAlign_;
		this.linkType = linkType_;
		this.headingLevel = headingLevel_;
		this.mathBlockDollarOffset = mathBlockDollarOffset_;
		this.expand = expand_;
		this.caretStartOffset = caretStartOffset_;
		this.caretEndOffset = caretEndOffset_;
	});
	nodeType = $pkg.nodeType = $newType(4, $kindInt, "lute.nodeType", true, "github.com/b3log/lute", false, null);
	Context = $pkg.Context = $newType(0, $kindStruct, "lute.Context", true, "github.com/b3log/lute", true, function(tree_, option_, linkRefDef_, tip_, oldtip_, currentLine_, currentLineLen_, lineNum_, offset_, column_, nextNonspace_, nextNonspaceColumn_, indent_, indented_, blank_, partiallyConsumedTab_, allClosed_, lastMatchedContainer_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.tree = ptrType$11.nil;
			this.option = ptrType$10.nil;
			this.linkRefDef = false;
			this.tip = ptrType.nil;
			this.oldtip = ptrType.nil;
			this.currentLine = sliceType.nil;
			this.currentLineLen = 0;
			this.lineNum = 0;
			this.offset = 0;
			this.column = 0;
			this.nextNonspace = 0;
			this.nextNonspaceColumn = 0;
			this.indent = 0;
			this.indented = false;
			this.blank = false;
			this.partiallyConsumedTab = false;
			this.allClosed = false;
			this.lastMatchedContainer = ptrType.nil;
			return;
		}
		this.tree = tree_;
		this.option = option_;
		this.linkRefDef = linkRefDef_;
		this.tip = tip_;
		this.oldtip = oldtip_;
		this.currentLine = currentLine_;
		this.currentLineLen = currentLineLen_;
		this.lineNum = lineNum_;
		this.offset = offset_;
		this.column = column_;
		this.nextNonspace = nextNonspace_;
		this.nextNonspaceColumn = nextNonspaceColumn_;
		this.indent = indent_;
		this.indented = indented_;
		this.blank = blank_;
		this.partiallyConsumedTab = partiallyConsumedTab_;
		this.allClosed = allClosed_;
		this.lastMatchedContainer = lastMatchedContainer_;
	});
	InlineContext = $pkg.InlineContext = $newType(0, $kindStruct, "lute.InlineContext", true, "github.com/b3log/lute", true, function(tokens_, tokensLen_, pos_, lineNum_, columnNum_, delimiters_, brackets_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.tokens = sliceType.nil;
			this.tokensLen = 0;
			this.pos = 0;
			this.lineNum = 0;
			this.columnNum = 0;
			this.delimiters = ptrType$2.nil;
			this.brackets = ptrType$2.nil;
			return;
		}
		this.tokens = tokens_;
		this.tokensLen = tokensLen_;
		this.pos = pos_;
		this.lineNum = lineNum_;
		this.columnNum = columnNum_;
		this.delimiters = delimiters_;
		this.brackets = brackets_;
	});
	Tree = $pkg.Tree = $newType(0, $kindStruct, "lute.Tree", true, "github.com/b3log/lute", true, function(Name_, Root_, lexer_, context_, inlineContext_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.Root = ptrType.nil;
			this.lexer = ptrType$8.nil;
			this.context = ptrType$13.nil;
			this.inlineContext = ptrType$14.nil;
			return;
		}
		this.Name = Name_;
		this.Root = Root_;
		this.lexer = lexer_;
		this.context = context_;
		this.inlineContext = inlineContext_;
	});
	RendererFunc = $pkg.RendererFunc = $newType(4, $kindFunc, "lute.RendererFunc", true, "github.com/b3log/lute", true, null);
	Renderer = $pkg.Renderer = $newType(8, $kindInterface, "lute.Renderer", true, "github.com/b3log/lute", true, null);
	BaseRenderer = $pkg.BaseRenderer = $newType(0, $kindStruct, "lute.BaseRenderer", true, "github.com/b3log/lute", true, function(writer_, lastOut_, rendererFuncs_, defaultRendererFunc_, disableTags_, option_, tree_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.writer = ptrType$4.nil;
			this.lastOut = 0;
			this.rendererFuncs = false;
			this.defaultRendererFunc = $throwNilPointerError;
			this.disableTags = 0;
			this.option = ptrType$10.nil;
			this.tree = ptrType$11.nil;
			return;
		}
		this.writer = writer_;
		this.lastOut = lastOut_;
		this.rendererFuncs = rendererFuncs_;
		this.defaultRendererFunc = defaultRendererFunc_;
		this.disableTags = disableTags_;
		this.option = option_;
		this.tree = tree_;
	});
	VditorRenderer = $pkg.VditorRenderer = $newType(0, $kindStruct, "lute.VditorRenderer", true, "github.com/b3log/lute", true, function(BaseRenderer_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$3.nil;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
	});
	WalkStatus = $pkg.WalkStatus = $newType(4, $kindInt, "lute.WalkStatus", true, "github.com/b3log/lute", true, null);
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType(sliceType);
	sliceType$2 = $sliceType(blockStartFunc);
	ptrType = $ptrType(Node);
	ptrType$1 = $ptrType(listData);
	sliceType$3 = $sliceType($Int);
	ptrType$2 = $ptrType(delimiter);
	ptrType$3 = $ptrType(BaseRenderer);
	ptrType$4 = $ptrType(bytes.Buffer);
	sliceType$4 = $sliceType(ptrType$4);
	sliceType$5 = $sliceType($String);
	sliceType$6 = $sliceType(sliceType$5);
	ptrType$5 = $ptrType(sync.WaitGroup);
	ptrType$6 = $ptrType($error);
	arrayType = $arrayType($Uint32, 3);
	ptrType$7 = $ptrType($String);
	ptrType$8 = $ptrType(lexer);
	ptrType$9 = $ptrType(Lute);
	ptrType$10 = $ptrType(options);
	ptrType$11 = $ptrType(Tree);
	ptrType$12 = $ptrType(html.Node);
	sliceType$7 = $sliceType(html.Attribute);
	ptrType$13 = $ptrType(Context);
	ptrType$14 = $ptrType(InlineContext);
	sliceType$8 = $sliceType(ptrType);
	ptrType$15 = $ptrType(EChartsJSONRenderer);
	ptrType$16 = $ptrType(FormatRenderer);
	ptrType$17 = $ptrType(HTMLRenderer);
	mapType = $mapType($String, $String);
	mapType$1 = $mapType($String, ptrType);
	mapType$2 = $mapType(nodeType, RendererFunc);
	ptrType$18 = $ptrType(VditorRenderer);
	Tree.ptr.prototype.parseGFMAutoEmailLink = function(node) {
		var child, next, node, t;
		t = this;
		child = node.firstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.next;
			if ((16 === child.typ) && !(ptrType.nil === child.parent) && !((33 === child.parent.typ))) {
				t.parseGFMAutoEmailLink0(child);
			} else {
				t.parseGFMAutoEmailLink(child);
			}
			child = next;
		}
	};
	Tree.prototype.parseGFMAutoEmailLink = function(node) { return this.$val.parseGFMAutoEmailLink(node); };
	Tree.ptr.prototype.parseGFMAutoLink = function(node) {
		var child, next, node, t;
		t = this;
		child = node.firstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.next;
			if (16 === child.typ) {
				t.parseGFMAutoLink0(child);
			} else {
				t.parseGFMAutoLink(child);
			}
			child = next;
		}
	};
	Tree.prototype.parseGFMAutoLink = function(node) { return this.$val.parseGFMAutoLink(node); };
	Tree.ptr.prototype.parseGFMAutoEmailLink0 = function(node) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, atIndex, dest, group, i, item, j, k, lastIndex, length, link, link$1, node, t, text, text$1, text$2, text$3, text$4, text$5, token, tokens;
		t = this;
		tokens = node.tokens;
		if (0 >= bytes.IndexByte(tokens, 64)) {
			return;
		}
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		_tmp$3 = 0;
		i = _tmp;
		j = _tmp$1;
		k = _tmp$2;
		atIndex = _tmp$3;
		token = 0;
		length = tokens.$length;
		loopPart:
		while (true) {
			if (!(i < length)) { break; }
			group = sliceType.nil;
			atIndex = 0;
			j = i;
			while (true) {
				if (!(j < length)) { break; }
				token = ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]);
				if (!isWhitespace(token)) {
					group = $append(group, ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]));
					if (64 === token) {
						atIndex = j - i >> 0;
					}
					j = j + (1) >> 0;
					continue;
				}
				break;
			}
			if (i === j) {
				text = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", new sliceType([((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j])]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.InsertBefore(text);
				i = i + (1) >> 0;
				continue;
			}
			i = j;
			if (0 >= atIndex) {
				text$1 = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", group, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.InsertBefore(text$1);
				continue;
			}
			k = 0;
			while (true) {
				if (!(k < atIndex)) { break; }
				token = ((k < 0 || k >= group.$length) ? ($throwRuntimeError("index out of range"), undefined) : group.$array[group.$offset + k]);
				if (!t.isValidEmailSegment1(token)) {
					text$2 = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", group, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
					node.InsertBefore(text$2);
					continue loopPart;
				}
				k = k + (1) >> 0;
			}
			k = k + (1) >> 0;
			item = 0;
			while (true) {
				if (!(k < group.$length)) { break; }
				item = ((k < 0 || k >= group.$length) ? ($throwRuntimeError("index out of range"), undefined) : group.$array[group.$offset + k]);
				token = ((k < 0 || k >= group.$length) ? ($throwRuntimeError("index out of range"), undefined) : group.$array[group.$offset + k]);
				if (!t.isValidEmailSegment2(token)) {
					text$3 = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", group, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
					node.InsertBefore(text$3);
					continue loopPart;
				}
				k = k + (1) >> 0;
			}
			if (46 === token) {
				lastIndex = group.$length - 1 >> 0;
				group = $subslice(group, 0, lastIndex);
				link = t.newLink(33, group, $appendSlice(mailto, group), sliceType.nil, 2);
				node.InsertBefore(link);
				node.InsertBefore(new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", new sliceType([item]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			} else if ((45 === token) || (95 === token)) {
				text$4 = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", group, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.InsertBefore(text$4);
				continue loopPart;
			} else {
				link$1 = new Node.ptr(33, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 2, 0, 0, false, "", "");
				text$5 = new Node.ptr(40, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", group, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				link$1.AppendChild(text$5);
				dest = new Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $appendSlice(mailto, group), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				link$1.AppendChild(dest);
				node.InsertBefore(link$1);
			}
		}
		node.Unlink();
		return;
	};
	Tree.prototype.parseGFMAutoEmailLink0 = function(node) { return this.$val.parseGFMAutoEmailLink0(node); };
	Tree.ptr.prototype.isValidEmailSegment1 = function(token) {
		var t, token;
		t = this;
		return isASCIILetterNumHyphen(token) || (46 === token) || (43 === token) || (95 === token);
	};
	Tree.prototype.isValidEmailSegment1 = function(token) { return this.$val.isValidEmailSegment1(token); };
	Tree.ptr.prototype.isValidEmailSegment2 = function(token) {
		var t, token;
		t = this;
		return isASCIILetterNumHyphen(token) || (46 === token) || (95 === token);
	};
	Tree.prototype.isValidEmailSegment2 = function(token) { return this.$val.isValidEmailSegment2(token); };
	Lute.ptr.prototype.AddAutoLinkDomainSuffix = function(suffix) {
		var lute, suffix;
		lute = this;
		validAutoLinkDomainSuffix = $append(validAutoLinkDomainSuffix, strToBytes(suffix));
	};
	Lute.prototype.AddAutoLinkDomainSuffix = function(suffix) { return this.$val.AddAutoLinkDomainSuffix(suffix); };
	Tree.ptr.prototype.parseGFMAutoLink0 = function(node) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, addr, closeParens, consumed, dest, domain, entity, foundAmp, i, isEntity, j, k, l, lastToken, lastToken$1, length, length$1, link, minLinkLen, node, openParens, part, path, protocol, t, text, text$1, text$2, text$3, tmp, tmpLen, token, tokens, trimmed, unmatches, url, www, x, x$1;
		t = this;
		tokens = node.tokens;
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		i = _tmp;
		j = _tmp$1;
		k = _tmp$2;
		length = tokens.$length;
		minLinkLen = 10;
		if (minLinkLen > length) {
			return;
		}
		token = 0;
		consumed = $makeSlice(sliceType, 0, 256);
		tmp = $makeSlice(sliceType, 0, 16);
		www = false;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			protocol = sliceType.nil;
			tmp = $subslice(tokens, i);
			tmpLen = tmp.$length;
			if (10 <= tmpLen && (119 === (0 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 0])) && (119 === (1 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 1])) && (119 === (2 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 2])) && (46 === (3 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 3]))) {
				protocol = httpProto;
				www = true;
			} else if (13 <= tmpLen && (104 === (0 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 0])) && (116 === (1 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 1])) && (116 === (2 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 2])) && (112 === (3 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 3])) && (58 === (4 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 4])) && (47 === (5 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 5])) && (47 === (6 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 6]))) {
				protocol = $subslice(tmp, 0, 7);
				i = i + (7) >> 0;
			} else if (14 <= tmpLen && (104 === (0 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 0])) && (116 === (1 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 1])) && (116 === (2 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 2])) && (112 === (3 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 3])) && (115 === (4 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 4])) && (58 === (5 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 5])) && (47 === (6 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 6])) && (47 === (7 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 7]))) {
				protocol = $subslice(tmp, 0, 8);
				i = i + (8) >> 0;
			} else if (12 <= tmpLen && (102 === (0 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 0])) && (116 === (1 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 1])) && (112 === (2 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 2])) && (58 === (3 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 3])) && (47 === (4 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 4])) && (47 === (5 >= tmp.$length ? ($throwRuntimeError("index out of range"), undefined) : tmp.$array[tmp.$offset + 5]))) {
				protocol = $subslice(tmp, 0, 6);
				i = i + (6) >> 0;
			} else {
				consumed = $append(consumed, token);
				if ((length - i >> 0) < minLinkLen && 0 < (length - i >> 0)) {
					consumed = $appendSlice(consumed, $subslice(tokens, (i + 1 >> 0)));
					node.InsertBefore(new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", consumed, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					node.Unlink();
					return;
				}
				i = i + (1) >> 0;
				continue;
			}
			if (0 < consumed.$length) {
				text = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", consumed, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.InsertBefore(text);
				consumed = $makeSlice(sliceType, 0, 256);
			}
			url = sliceType.nil;
			j = i;
			while (true) {
				if (!(j < length)) { break; }
				token = ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]);
				if ((isWhitespace(token) || (60 === token)) || (!isASCIIPunct(token) && !isASCIILetterNum(token))) {
					break;
				}
				url = $append(url, token);
				j = j + (1) >> 0;
			}
			if (i === j) {
				if (128 <= token) {
					if (!www) {
						url = $appendSlice(url, protocol);
					}
					while (true) {
						if (!(i < length)) { break; }
						token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
						if (128 > token) {
							break;
						}
						url = $append(url, token);
						i = i + (1) >> 0;
					}
				} else {
					url = $append(url, token);
					i = i + (1) >> 0;
				}
				text$1 = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", url, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.InsertBefore(text$1);
				continue;
			}
			i = j;
			k = 0;
			while (true) {
				if (!(k < url.$length)) { break; }
				token = ((k < 0 || k >= url.$length) ? ($throwRuntimeError("index out of range"), undefined) : url.$array[url.$offset + k]);
				if (47 === token) {
					break;
				}
				k = k + (1) >> 0;
			}
			domain = $subslice(url, 0, k);
			if (!t.isValidDomain(domain)) {
				part = sliceType.nil;
				if (www) {
					part = url;
				} else {
					part = $appendSlice(protocol, url);
				}
				text$2 = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", part, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.InsertBefore(text$2);
				continue;
			}
			_tmp$3 = 0;
			_tmp$4 = 0;
			openParens = _tmp$3;
			closeParens = _tmp$4;
			path = $subslice(url, k);
			length$1 = path.$length;
			if (0 < length$1) {
				l = 0;
				l = 0;
				while (true) {
					if (!(l < length$1)) { break; }
					token = ((l < 0 || l >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + l]);
					if (40 === token) {
						openParens = openParens + (1) >> 0;
					} else if (41 === token) {
						closeParens = closeParens + (1) >> 0;
					}
					l = l + (1) >> 0;
				}
				trimmed = false;
				lastToken = (x = length$1 - 1 >> 0, ((x < 0 || x >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + x]));
				if (41 === lastToken) {
					unmatches = closeParens - openParens >> 0;
					if (0 < unmatches) {
						l = length$1 - 1 >> 0;
						while (true) {
							if (!(0 < unmatches)) { break; }
							token = ((l < 0 || l >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + l]);
							if (!((41 === token))) {
								break;
							}
							unmatches = unmatches - (1) >> 0;
							i = i - (1) >> 0;
							l = l - (1) >> 0;
						}
						path = $subslice(path, 0, (l + 1 >> 0));
						trimmed = true;
					} else {
						trimmed = true;
					}
				} else if (59 === lastToken) {
					foundAmp = false;
					l = length$1 - 1 >> 0;
					while (true) {
						if (!(0 <= l)) { break; }
						token = ((l < 0 || l >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + l]);
						if (38 === token) {
							foundAmp = true;
							break;
						}
						l = l - (1) >> 0;
					}
					if (foundAmp) {
						entity = $subslice(path, l, length$1);
						if (3 <= entity.$length) {
							isEntity = true;
							j = 1;
							while (true) {
								if (!(j < (entity.$length - 1 >> 0))) { break; }
								if (!isASCIILetterNum(((j < 0 || j >= entity.$length) ? ($throwRuntimeError("index out of range"), undefined) : entity.$array[entity.$offset + j]))) {
									isEntity = false;
									break;
								}
								j = j + (1) >> 0;
							}
							if (isEntity) {
								path = $subslice(path, 0, l);
								trimmed = true;
								i = i - ((length$1 - l >> 0)) >> 0;
							}
						}
					}
				}
				if (!trimmed && isASCIIPunct(lastToken) && !((47 === lastToken))) {
					path = $subslice(path, 0, (length$1 - 1 >> 0));
					i = i - (1) >> 0;
				}
			} else {
				length$1 = domain.$length;
				lastToken$1 = (x$1 = length$1 - 1 >> 0, ((x$1 < 0 || x$1 >= domain.$length) ? ($throwRuntimeError("index out of range"), undefined) : domain.$array[domain.$offset + x$1]));
				if (isASCIIPunct(lastToken$1)) {
					domain = $subslice(domain, 0, (length$1 - 1 >> 0));
					i = i - (1) >> 0;
				}
			}
			dest = protocol;
			dest = $appendSlice(dest, domain);
			dest = $appendSlice(dest, path);
			addr = sliceType.nil;
			if (!www) {
				addr = $appendSlice(addr, protocol);
			}
			addr = $appendSlice(addr, domain);
			addr = $appendSlice(addr, path);
			link = t.newLink(33, addr, encodeDestination(dest), sliceType.nil, 2);
			node.InsertBefore(link);
		}
		if (0 < consumed.$length) {
			text$3 = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", consumed, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			node.InsertBefore(text$3);
		}
		node.Unlink();
		return;
	};
	Tree.prototype.parseGFMAutoLink0 = function(node) { return this.$val.parseGFMAutoLink0(node); };
	Tree.ptr.prototype.isValidDomain = function(domain) {
		var domain, i, j, j$1, length, segLen, segment, segments, t, token, validSuffix;
		t = this;
		segments = split(domain, 46);
		length = segments.$length;
		if (2 > length) {
			return false;
		}
		token = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			segment = ((i < 0 || i >= segments.$length) ? ($throwRuntimeError("index out of range"), undefined) : segments.$array[segments.$offset + i]);
			segLen = segment.$length;
			if (1 > segLen) {
				i = i + (1) >> 0;
				continue;
			}
			j = 0;
			while (true) {
				if (!(j < segLen)) { break; }
				token = ((j < 0 || j >= segment.$length) ? ($throwRuntimeError("index out of range"), undefined) : segment.$array[segment.$offset + j]);
				if (!isASCIILetterNumHyphen(token)) {
					return false;
				}
				if (2 < i && ((i === (length - 2 >> 0)) || (i === (length - 1 >> 0)))) {
					if (95 === token) {
						return false;
					}
				}
				j = j + (1) >> 0;
			}
			if (i === (length - 1 >> 0)) {
				validSuffix = false;
				j$1 = 0;
				while (true) {
					if (!(j$1 < validAutoLinkDomainSuffix.$length)) { break; }
					if (bytes.Equal(segment, ((j$1 < 0 || j$1 >= validAutoLinkDomainSuffix.$length) ? ($throwRuntimeError("index out of range"), undefined) : validAutoLinkDomainSuffix.$array[validAutoLinkDomainSuffix.$offset + j$1]))) {
						validSuffix = true;
						break;
					}
					j$1 = j$1 + (1) >> 0;
				}
				if (!validSuffix) {
					return false;
				}
			}
			i = i + (1) >> 0;
		}
		return true;
	};
	Tree.prototype.isValidDomain = function(domain) { return this.$val.isValidDomain(domain); };
	Tree.ptr.prototype.parseAutoEmailLink = function(ctx) {
		var at, closed, ctx, dest, domainPart, i, length, passed, ret, t, token, tokens;
		ret = ptrType.nil;
		t = this;
		tokens = $subslice(ctx.tokens, 1);
		dest = sliceType.nil;
		token = 0;
		length = tokens.$length;
		passed = 0;
		i = 0;
		at = false;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			dest = $append(dest, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			passed = passed + (1) >> 0;
			if (64 === token) {
				at = true;
				break;
			}
			if (!isASCIILetterNumHyphen(token) && !bytes.Contains(markers, new sliceType([token]))) {
				ret = ptrType.nil;
				return ret;
			}
			i = i + (1) >> 0;
		}
		if (1 > i || !at) {
			ret = ptrType.nil;
			return ret;
		}
		domainPart = $subslice(tokens, (i + 1 >> 0));
		length = domainPart.$length;
		i = 0;
		closed = false;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= domainPart.$length) ? ($throwRuntimeError("index out of range"), undefined) : domainPart.$array[domainPart.$offset + i]);
			passed = passed + (1) >> 0;
			if (62 === token) {
				closed = true;
				break;
			}
			dest = $append(dest, ((i < 0 || i >= domainPart.$length) ? ($throwRuntimeError("index out of range"), undefined) : domainPart.$array[domainPart.$offset + i]));
			if (!isASCIILetterNumHyphen(token) && !((46 === token))) {
				ret = ptrType.nil;
				return ret;
			}
			if (63 < i) {
				ret = ptrType.nil;
				return ret;
			}
			i = i + (1) >> 0;
		}
		if (1 > i || !closed) {
			ret = ptrType.nil;
			return ret;
		}
		ctx.pos = ctx.pos + ((passed + 1 >> 0)) >> 0;
		ret = t.newLink(33, dest, $appendSlice(mailto, dest), sliceType.nil, 2);
		return ret;
	};
	Tree.prototype.parseAutoEmailLink = function(ctx) { return this.$val.parseAutoEmailLink(ctx); };
	Tree.ptr.prototype.newLink = function(typ, text, dest, title, linkType) {
		var dest, linkType, ret, t, text, title, typ;
		ret = ptrType.nil;
		t = this;
		ret = new Node.ptr(typ, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, linkType, 0, 0, false, "", "");
		if (34 === typ) {
			ret.AppendChild(new Node.ptr(35, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		}
		ret.AppendChild(new Node.ptr(36, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		ret.AppendChild(new Node.ptr(40, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", text, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		ret.AppendChild(new Node.ptr(37, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		ret.AppendChild(new Node.ptr(38, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		ret.AppendChild(new Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", dest, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		if (!(sliceType.nil === title)) {
			ret.AppendChild(new Node.ptr(42, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", title, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		}
		ret.AppendChild(new Node.ptr(39, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		return ret;
	};
	Tree.prototype.newLink = function(typ, text, dest, title, linkType) { return this.$val.newLink(typ, text, dest, title, linkType); };
	Tree.ptr.prototype.parseAutolink = function(ctx) {
		var ctx, dest, i, ret, scheme, schemed, t, token, x, x$1, x$2, x$3;
		ret = ptrType.nil;
		t = this;
		schemed = false;
		scheme = "";
		dest = sliceType.nil;
		token = 0;
		i = ctx.pos + 1 >> 0;
		while (true) {
			if (!(i < ctx.tokensLen && !((62 === (x = ctx.tokens, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])))))) { break; }
			token = (x$1 = ctx.tokens, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]));
			if (32 === token) {
				ret = ptrType.nil;
				return ret;
			}
			dest = $append(dest, (x$2 = ctx.tokens, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i])));
			if (!schemed) {
				if (!((58 === token))) {
					scheme = scheme + (($encodeRune(token)));
				} else {
					schemed = true;
				}
			}
			i = i + (1) >> 0;
		}
		if (!schemed || 3 > scheme.length || (i === ctx.tokensLen)) {
			ret = ptrType.nil;
			return ret;
		}
		if (!((62 === (x$3 = ctx.tokens, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i]))))) {
			ret = ptrType.nil;
			return ret;
		}
		ctx.pos = 1 + i >> 0;
		ret = t.newLink(33, dest, encodeDestination(dest), sliceType.nil, 2);
		return ret;
	};
	Tree.prototype.parseAutolink = function(ctx) { return this.$val.parseAutolink(ctx); };
	Node.ptr.prototype.blockquoteContinue = function(context) {
		var blockquote, context, ln, token;
		blockquote = this;
		ln = context.currentLine;
		if (!context.indented && (peek(ln, context.nextNonspace) === 62)) {
			context.advanceNextNonspace();
			context.advanceOffset(1, false);
			token = peek(ln, context.offset);
			if ((32 === token) || (9 === token)) {
				context.advanceOffset(1, true);
			}
			return 0;
		}
		return 1;
	};
	Node.prototype.blockquoteContinue = function(context) { return this.$val.blockquoteContinue(context); };
	Tree.ptr.prototype.parseBlocks = function() {
		var line, lines, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; line = $f.line; lines = $f.lines; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		t.context.tip = t.Root;
		t.context.linkRefDef = $makeMap($String.keyFor, []);
		lines = 0;
		line = t.lexer.nextLine();
		/* while (true) { */ case 1:
			/* if (!(!(sliceType.nil === line))) { break; } */ if(!(!(sliceType.nil === line))) { $s = 2; continue; }
			$r = t.incorporateLine(line); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			lines = lines + (1) >> 0;
			line = t.lexer.nextLine();
		/* } */ $s = 1; continue; case 2:
		/* while (true) { */ case 4:
			/* if (!(!(ptrType.nil === t.context.tip))) { break; } */ if(!(!(ptrType.nil === t.context.tip))) { $s = 5; continue; }
			$r = t.context.finalize(t.context.tip, lines); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 4; continue; case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseBlocks }; } $f.line = line; $f.lines = lines; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseBlocks = function() { return this.$val.parseBlocks(); };
	Tree.ptr.prototype.incorporateLine = function(line) {
		var _1, _r, _r$1, _r$2, allMatched, cont, container, html$1, i, isFenced, lastChild, lastLineBlank, line, matchedLeaf, maybeMarker, res, startsLen, t, tokens, typ, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; allMatched = $f.allMatched; cont = $f.cont; container = $f.container; html$1 = $f.html$1; i = $f.i; isFenced = $f.isFenced; lastChild = $f.lastChild; lastLineBlank = $f.lastLineBlank; line = $f.line; matchedLeaf = $f.matchedLeaf; maybeMarker = $f.maybeMarker; res = $f.res; startsLen = $f.startsLen; t = $f.t; tokens = $f.tokens; typ = $f.typ; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		t.context.oldtip = t.context.tip;
		t.context.offset = 0;
		t.context.column = 0;
		t.context.blank = false;
		t.context.partiallyConsumedTab = false;
		t.context.lineNum = t.context.lineNum + (1) >> 0;
		t.context.currentLine = line;
		t.context.currentLineLen = t.context.currentLine.$length;
		allMatched = true;
		container = ptrType.nil;
		container = t.Root;
		lastChild = container.lastChild;
		/* while (true) { */ case 1:
			/* if (!(!(ptrType.nil === lastChild) && !lastChild.close)) { break; } */ if(!(!(ptrType.nil === lastChild) && !lastChild.close)) { $s = 2; continue; }
			container = lastChild;
			t.context.findNextNonspace();
				_r = container.Continue(t.context); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_1 = _r;
				if (_1 === (0)) {
					/* break; */ $s = 3; continue;
				} else if (_1 === (1)) {
					allMatched = false;
					/* break; */ $s = 3; continue;
				} else if (_1 === (2)) {
					$s = -1; return;
				}
			case 3:
			if (!allMatched) {
				container = container.parent;
				/* break; */ $s = 2; continue;
			}
			lastChild = container.lastChild;
		/* } */ $s = 1; continue; case 2:
		t.context.allClosed = container === t.context.oldtip;
		t.context.lastMatchedContainer = container;
		matchedLeaf = !((container.typ === 1)) && container.AcceptLines();
		startsLen = blockStarts.$length;
		/* while (true) { */ case 5:
			/* if (!(!matchedLeaf)) { break; } */ if(!(!matchedLeaf)) { $s = 6; continue; }
			t.context.findNextNonspace();
			maybeMarker = (x = t.context.currentLine, x$1 = t.context.nextNonspace, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			if (!t.context.indented && !((45 === maybeMarker)) && !((42 === maybeMarker)) && !((43 === maybeMarker)) && !isDigit(maybeMarker) && !((96 === maybeMarker)) && !((126 === maybeMarker)) && !((35 === maybeMarker)) && !((62 === maybeMarker)) && !((60 === maybeMarker)) && !((95 === maybeMarker)) && !((61 === maybeMarker)) && !((36 === maybeMarker))) {
				t.context.advanceNextNonspace();
				/* break; */ $s = 6; continue;
			}
			i = 0;
			/* while (true) { */ case 7:
				/* if (!(i < startsLen)) { break; } */ if(!(i < startsLen)) { $s = 8; continue; }
				_r$1 = ((i < 0 || i >= blockStarts.$length) ? ($throwRuntimeError("index out of range"), undefined) : blockStarts.$array[blockStarts.$offset + i])(t, container); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				res = _r$1;
				if (res === 1) {
					container = t.context.tip;
					/* break; */ $s = 8; continue;
				} else if (res === 2) {
					container = t.context.tip;
					matchedLeaf = true;
					/* break; */ $s = 8; continue;
				} else {
					i = i + (1) >> 0;
				}
			/* } */ $s = 7; continue; case 8:
			if (i === startsLen) {
				t.context.advanceNextNonspace();
				/* break; */ $s = 6; continue;
			}
		/* } */ $s = 5; continue; case 6:
		/* */ if (!t.context.allClosed && !t.context.blank && (t.context.tip.typ === 1)) { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (!t.context.allClosed && !t.context.blank && (t.context.tip.typ === 1)) { */ case 10:
			t.addLine();
			$s = 12; continue;
		/* } else { */ case 11:
			$r = t.context.closeUnmatchedBlocks(); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if (t.context.blank && !(ptrType.nil === container.lastChild)) {
				container.lastChild.lastLineBlank = true;
			}
			typ = container.typ;
			isFenced = (11 === typ) && container.isFencedCodeBlock;
			lastLineBlank = t.context.blank && !((typ === 5) || ((typ === 11) && isFenced) || ((typ === 300)) || ((typ === 8) && ptrType.nil === container.firstChild));
			cont = container;
			while (true) {
				if (!(!(ptrType.nil === cont))) { break; }
				cont.lastLineBlank = lastLineBlank;
				cont = cont.parent;
			}
			/* */ if (container.AcceptLines()) { $s = 14; continue; }
			/* */ if (t.context.offset < t.context.currentLineLen && !t.context.blank) { $s = 15; continue; }
			/* */ $s = 16; continue;
			/* if (container.AcceptLines()) { */ case 14:
				t.addLine();
				/* */ if (typ === 9) { $s = 17; continue; }
				/* */ $s = 18; continue;
				/* if (typ === 9) { */ case 17:
					html$1 = container;
					/* */ if (html$1.htmlBlockType >= 1 && html$1.htmlBlockType <= 5) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if (html$1.htmlBlockType >= 1 && html$1.htmlBlockType <= 5) { */ case 19:
						tokens = $subslice(t.context.currentLine, t.context.offset);
						/* */ if (t.isHTMLBlockClose(tokens, html$1.htmlBlockType)) { $s = 21; continue; }
						/* */ $s = 22; continue;
						/* if (t.isHTMLBlockClose(tokens, html$1.htmlBlockType)) { */ case 21:
							$r = t.context.finalize(container, t.context.lineNum); /* */ $s = 23; case 23: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						/* } */ case 22:
					/* } */ case 20:
				/* } */ case 18:
				$s = 16; continue;
			/* } else if (t.context.offset < t.context.currentLineLen && !t.context.blank) { */ case 15:
				_r$2 = t.context.addChild(1, t.context.offset); /* */ $s = 24; case 24: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				t.context.advanceNextNonspace();
				t.addLine();
			/* } */ case 16:
		/* } */ case 12:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.incorporateLine }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.allMatched = allMatched; $f.cont = cont; $f.container = container; $f.html$1 = html$1; $f.i = i; $f.isFenced = isFenced; $f.lastChild = lastChild; $f.lastLineBlank = lastLineBlank; $f.line = line; $f.matchedLeaf = matchedLeaf; $f.maybeMarker = maybeMarker; $f.res = res; $f.startsLen = startsLen; $f.t = t; $f.tokens = tokens; $f.typ = typ; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.incorporateLine = function(line) { return this.$val.incorporateLine(line); };
	Tree.ptr.prototype.addLine = function() {
		var _r, charsToTab, i, t;
		t = this;
		if (t.context.partiallyConsumedTab) {
			t.context.offset = t.context.offset + (1) >> 0;
			charsToTab = 4 - ((_r = t.context.column % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))) >> 0;
			i = 0;
			while (true) {
				if (!(i < charsToTab)) { break; }
				t.context.tip.AppendTokens(strToBytes(" "));
				i = i + (1) >> 0;
			}
		}
		t.context.tip.AppendTokens($subslice(t.context.currentLine, t.context.offset));
	};
	Tree.prototype.addLine = function() { return this.$val.addLine(); };
	Node.ptr.prototype.codeBlockContinue = function(context) {
		var _tuple, closeFence, codeBlock, context, i, indent, ln, ok, token, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; closeFence = $f.closeFence; codeBlock = $f.codeBlock; context = $f.context; i = $f.i; indent = $f.indent; ln = $f.ln; ok = $f.ok; token = $f.token; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		codeBlock = this;
		ln = context.currentLine;
		indent = context.indent;
		/* */ if (codeBlock.isFencedCodeBlock) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (codeBlock.isFencedCodeBlock) { */ case 1:
			_tuple = codeBlock.isFencedCodeClose($subslice(ln, context.nextNonspace), codeBlock.codeBlockFenceChar, codeBlock.codeBlockFenceLen);
			ok = _tuple[0];
			closeFence = _tuple[1];
			/* */ if (indent <= 3 && ok) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (indent <= 3 && ok) { */ case 4:
				codeBlock.codeBlockCloseFence = closeFence;
				$r = context.finalize(codeBlock, context.lineNum); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return 2;
			/* } else { */ case 5:
				i = codeBlock.codeBlockFenceOffset;
				token = 0;
				while (true) {
					if (!(i > 0)) { break; }
					token = peek(ln, context.offset);
					if (!((32 === token)) && !((9 === token))) {
						break;
					}
					context.advanceOffset(1, true);
					i = i - (1) >> 0;
				}
			/* } */ case 6:
			$s = 3; continue;
		/* } else { */ case 2:
			if (indent >= 4) {
				context.advanceOffset(4, true);
			} else if (context.blank) {
				context.advanceNextNonspace();
			} else {
				$s = -1; return 1;
			}
		/* } */ case 3:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.codeBlockContinue }; } $f._tuple = _tuple; $f.closeFence = closeFence; $f.codeBlock = codeBlock; $f.context = context; $f.i = i; $f.indent = indent; $f.ln = ln; $f.ok = ok; $f.token = token; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.codeBlockContinue = function(context) { return this.$val.codeBlockContinue(context); };
	Node.ptr.prototype.codeBlockFinalize = function(context) {
		var codeBlock, content, context, firstLine, i, length, rest;
		codeBlock = this;
		if (codeBlock.isFencedCodeBlock) {
			content = codeBlock.tokens;
			length = content.$length;
			if (1 > length) {
				return;
			}
			i = 0;
			while (true) {
				if (!(i < length)) { break; }
				if (10 === ((i < 0 || i >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + i])) {
					break;
				}
				i = i + (1) >> 0;
			}
			firstLine = $subslice(content, 0, i);
			rest = $subslice(content, (i + 1 >> 0));
			if (!context.option.VditorWYSIWYG) {
				codeBlock.codeBlockInfo = unescapeString(trimWhitespace(firstLine));
			} else {
				codeBlock.codeBlockInfo = firstLine;
			}
			codeBlock.tokens = rest;
		} else {
			codeBlock.tokens = replaceNewlineSpace(codeBlock.tokens);
		}
	};
	Node.prototype.codeBlockFinalize = function(context) { return this.$val.codeBlockFinalize(context); };
	Tree.ptr.prototype.parseFencedCode = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, codeBlockInfo, fenceChar, fenceLen, fenceOffset, i, info, infoTokens, marker, ok, openFence, t, x, x$1, x$2;
		ok = false;
		fenceChar = 0;
		fenceLen = 0;
		fenceOffset = 0;
		openFence = sliceType.nil;
		codeBlockInfo = sliceType.nil;
		t = this;
		marker = (x = t.context.currentLine, x$1 = t.context.nextNonspace, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (!((96 === marker)) && !((126 === marker))) {
			return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
		}
		fenceChar = marker;
		i = t.context.nextNonspace;
		while (true) {
			if (!(i < t.context.currentLineLen && (fenceChar === (x$2 = t.context.currentLine, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]))))) { break; }
			fenceLen = fenceLen + (1) >> 0;
			i = i + (1) >> 0;
		}
		if (3 > fenceLen) {
			return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
		}
		openFence = $subslice(t.context.currentLine, t.context.nextNonspace, (t.context.nextNonspace + fenceLen >> 0));
		info = sliceType.nil;
		infoTokens = $subslice(t.context.currentLine, (t.context.nextNonspace + fenceLen >> 0));
		if ((96 === marker) && bytes.Contains(infoTokens, codeBlockBacktick)) {
			return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
		}
		if (t.context.option.VditorWYSIWYG && bytes.Contains(infoTokens, strToBytes("\xE2\x80\xB8"))) {
			return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
		}
		info = trimWhitespace(infoTokens);
		info = unescapeString(info);
		_tmp = true;
		_tmp$1 = fenceChar;
		_tmp$2 = fenceLen;
		_tmp$3 = t.context.indent;
		_tmp$4 = openFence;
		_tmp$5 = info;
		ok = _tmp;
		fenceChar = _tmp$1;
		fenceLen = _tmp$2;
		fenceOffset = _tmp$3;
		openFence = _tmp$4;
		codeBlockInfo = _tmp$5;
		return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
	};
	Tree.prototype.parseFencedCode = function() { return this.$val.parseFencedCode(); };
	Node.ptr.prototype.isFencedCodeClose = function(tokens, openMarker, num) {
		var _i, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, closeFence, closeMarker, codeBlock, num, ok, openMarker, token, tokens;
		ok = false;
		closeFence = sliceType.nil;
		codeBlock = this;
		closeMarker = (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]);
		if (!((closeMarker === openMarker))) {
			_tmp = false;
			_tmp$1 = sliceType.nil;
			ok = _tmp;
			closeFence = _tmp$1;
			return [ok, closeFence];
		}
		if (num > accept(tokens, closeMarker)) {
			_tmp$2 = false;
			_tmp$3 = sliceType.nil;
			ok = _tmp$2;
			closeFence = _tmp$3;
			return [ok, closeFence];
		}
		tokens = trimWhitespace(tokens);
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((token === openMarker))) {
				_tmp$4 = false;
				_tmp$5 = sliceType.nil;
				ok = _tmp$4;
				closeFence = _tmp$5;
				return [ok, closeFence];
			}
			_i++;
		}
		closeFence = tokens;
		_tmp$6 = true;
		_tmp$7 = closeFence;
		ok = _tmp$6;
		closeFence = _tmp$7;
		return [ok, closeFence];
	};
	Node.prototype.isFencedCodeClose = function(tokens, openMarker, num) { return this.$val.isFencedCodeClose(tokens, openMarker, num); };
	HTMLRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, infoWords, language, node, r, tokens;
		r = this;
		if (entering) {
			r.BaseRenderer.newline();
			tokens = node.tokens;
			if (0 < node.codeBlockInfo.$length) {
				infoWords = split(node.codeBlockInfo, 32);
				language = (0 >= infoWords.$length ? ($throwRuntimeError("index out of range"), undefined) : infoWords.$array[infoWords.$offset + 0]);
				r.BaseRenderer.writeString("<pre><code class=\"language-");
				r.BaseRenderer.write(language);
				r.BaseRenderer.writeString("\">");
				tokens = escapeHTML(tokens);
				r.BaseRenderer.write(tokens);
			} else {
				r.BaseRenderer.writeString("<pre><code>");
				tokens = escapeHTML(tokens);
				r.BaseRenderer.write(tokens);
			}
			return [1, $ifaceNil];
		}
		r.BaseRenderer.writeString("</code></pre>");
		r.BaseRenderer.newline();
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	HTMLRenderer.ptr.prototype.renderCodeBlockCode = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeBlockCode = function(node, entering) { return this.$val.renderCodeBlockCode(node, entering); };
	Tree.ptr.prototype.parseCodeSpan = function(ctx) {
		var backticks, closeMarker, ctx, endPos, n, openMarker, ret, startPos, t, textTokens, x, x$1, x$2;
		ret = ptrType.nil;
		t = this;
		startPos = ctx.pos;
		n = 0;
		while (true) {
			if (!((startPos + n >> 0) < ctx.tokensLen)) { break; }
			if (!((96 === (x = ctx.tokens, x$1 = startPos + n >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))))) {
				break;
			}
			n = n + (1) >> 0;
		}
		backticks = $subslice(ctx.tokens, startPos, (startPos + n >> 0));
		if (ctx.tokensLen <= (startPos + n >> 0)) {
			ctx.pos = ctx.pos + (n) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", backticks, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		openMarker = new Node.ptr(28, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", backticks, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		endPos = t.matchCodeSpanEnd($subslice(ctx.tokens, (startPos + n >> 0)), n);
		if (1 > endPos) {
			ctx.pos = ctx.pos + (n) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", backticks, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		endPos = (startPos + endPos >> 0) + n >> 0;
		closeMarker = new Node.ptr(30, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(ctx.tokens, endPos, (endPos + n >> 0)), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		textTokens = $subslice(ctx.tokens, (startPos + n >> 0), endPos);
		if (!t.context.option.VditorWYSIWYG) {
			textTokens = bytes.ReplaceAll(textTokens, new sliceType([10]), new sliceType([32]));
			if (2 < textTokens.$length && (32 === (0 >= textTokens.$length ? ($throwRuntimeError("index out of range"), undefined) : textTokens.$array[textTokens.$offset + 0])) && (32 === (x$2 = textTokens.$length - 1 >> 0, ((x$2 < 0 || x$2 >= textTokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : textTokens.$array[textTokens.$offset + x$2]))) && !isBlankLine(textTokens)) {
				openMarker.tokens = $append(openMarker.tokens, (0 >= textTokens.$length ? ($throwRuntimeError("index out of range"), undefined) : textTokens.$array[textTokens.$offset + 0]));
				closeMarker.tokens = $subslice(ctx.tokens, (endPos - 1 >> 0), (endPos + n >> 0));
				textTokens = $subslice(textTokens, 1);
				textTokens = $subslice(textTokens, 0, (textTokens.$length - 1 >> 0));
			}
		}
		ret = new Node.ptr(27, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, n, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		ret.AppendChild(openMarker);
		ret.AppendChild(new Node.ptr(29, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", textTokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		ret.AppendChild(closeMarker);
		ctx.pos = endPos + n >> 0;
		return ret;
	};
	Tree.prototype.parseCodeSpan = function(ctx) { return this.$val.parseCodeSpan(ctx); };
	Tree.ptr.prototype.matchCodeSpanEnd = function(tokens, num) {
		var l, length, next, num, pos, t, tokens;
		pos = 0;
		t = this;
		length = tokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			l = accept($subslice(tokens, pos), 96);
			if (num === l) {
				next = pos + l >> 0;
				if ((length - 1 >> 0) > next && (96 === ((next < 0 || next >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + next]))) {
					continue;
				}
				pos = pos;
				return pos;
			}
			if (0 < l) {
				pos = pos + (l) >> 0;
			} else {
				pos = pos + (1) >> 0;
			}
		}
		pos = -1;
		return pos;
	};
	Tree.prototype.matchCodeSpanEnd = function(tokens, num) { return this.$val.matchCodeSpanEnd(tokens, num); };
	Tree.ptr.prototype.handleDelim = function(block, ctx) {
		var block, ctx, delim, node, startPos, t, text;
		t = this;
		startPos = ctx.pos;
		delim = t.scanDelims(ctx);
		text = $subslice(ctx.tokens, startPos, ctx.pos);
		node = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", text, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		block.AppendChild(node);
		if (delim.canOpen || delim.canClose) {
			ctx.delimiters = new delimiter.ptr(node, delim.typ, delim.num, delim.num, delim.canOpen, delim.canClose, ctx.delimiters, ptrType$2.nil, false, false, false, 0, ptrType$2.nil);
			if (!(ptrType$2.nil === ctx.delimiters.previous)) {
				ctx.delimiters.previous.next = ctx.delimiters;
			}
		}
	};
	Tree.prototype.handleDelim = function(block, ctx) { return this.$val.handleDelim(block, ctx); };
	Tree.ptr.prototype.processEmphasis = function(stackBottom, ctx) {
		var _entry, _key, _key$1, _key$2, _key$3, _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, closeMarker, closer, closerInl, closerTokens, closercc, ctx, emStrongDel, next, oddMatch, oldCloser, openMarker, opener, openerFound, openerInl, openerTokens, openersBottom, stackBottom, t, tempStack, text, tmp, useDelims;
		t = this;
		_tmp = ptrType$2.nil;
		_tmp$1 = ptrType$2.nil;
		_tmp$2 = ptrType$2.nil;
		opener = _tmp;
		closer = _tmp$1;
		oldCloser = _tmp$2;
		_tmp$3 = ptrType.nil;
		_tmp$4 = ptrType.nil;
		openerInl = _tmp$3;
		closerInl = _tmp$4;
		tempStack = ptrType$2.nil;
		useDelims = 0;
		openerFound = false;
		openersBottom = $makeMap($Uint8.keyFor, []);
		oddMatch = false;
		_key = 95; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key)] = { k: _key, v: stackBottom };
		_key$1 = 42; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key$1)] = { k: _key$1, v: stackBottom };
		_key$2 = 126; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key$2)] = { k: _key$2, v: stackBottom };
		closer = ctx.delimiters;
		while (true) {
			if (!(!(ptrType$2.nil === closer) && !(closer.previous === stackBottom))) { break; }
			closer = closer.previous;
		}
		while (true) {
			if (!(!(ptrType$2.nil === closer))) { break; }
			closercc = closer.typ;
			if (!closer.canClose) {
				closer = closer.next;
				continue;
			}
			opener = closer.previous;
			openerFound = false;
			while (true) {
				if (!(!(ptrType$2.nil === opener) && !(opener === stackBottom) && !(opener === (_entry = openersBottom[$Uint8.keyFor(closercc)], _entry !== undefined ? _entry.v : ptrType$2.nil)))) { break; }
				oddMatch = (closer.canOpen || opener.canClose) && !(((_r = closer.originalNum % 3, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0)) && ((_r$1 = ((opener.originalNum + closer.originalNum >> 0)) % 3, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
				if ((opener.typ === closer.typ) && opener.canOpen && !oddMatch) {
					openerFound = true;
					break;
				}
				opener = opener.previous;
			}
			oldCloser = closer;
			if (!openerFound) {
				closer = closer.next;
			} else {
				if (closer.num >= 2 && opener.num >= 2) {
					useDelims = 2;
				} else {
					useDelims = 1;
				}
				openerInl = opener.node;
				closerInl = closer.node;
				opener.num = opener.num - (useDelims) >> 0;
				closer.num = closer.num - (useDelims) >> 0;
				openerTokens = $subslice(openerInl.tokens, (openerInl.tokens.$length - useDelims >> 0));
				text = $subslice(openerInl.tokens, 0, (openerInl.tokens.$length - useDelims >> 0));
				openerInl.tokens = text;
				closerTokens = $subslice(closerInl.tokens, (closerInl.tokens.$length - useDelims >> 0));
				text = $subslice(closerInl.tokens, 0, (closerInl.tokens.$length - useDelims >> 0));
				closerInl.tokens = text;
				openMarker = new Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", openerTokens, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				emStrongDel = new Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				closeMarker = new Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", closerTokens, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				if (1 === useDelims) {
					if (42 === closercc) {
						emStrongDel.typ = 17;
						openMarker.typ = 18;
						closeMarker.typ = 19;
					} else if (95 === closercc) {
						emStrongDel.typ = 17;
						openMarker.typ = 20;
						closeMarker.typ = 21;
					} else if (126 === closercc) {
						if (t.context.option.GFMStrikethrough) {
							emStrongDel.typ = 101;
							openMarker.typ = 102;
							closeMarker.typ = 103;
						}
					}
				} else {
					if (42 === closercc) {
						emStrongDel.typ = 22;
						openMarker.typ = 23;
						closeMarker.typ = 24;
					} else if (95 === closercc) {
						emStrongDel.typ = 22;
						openMarker.typ = 25;
						closeMarker.typ = 26;
					} else if (126 === closercc) {
						if (t.context.option.GFMStrikethrough) {
							emStrongDel.typ = 101;
							openMarker.typ = 104;
							closeMarker.typ = 105;
						}
					}
				}
				tmp = openerInl.next;
				while (true) {
					if (!(!(ptrType.nil === tmp) && !(tmp === closerInl))) { break; }
					next = tmp.next;
					tmp.Unlink();
					emStrongDel.AppendChild(tmp);
					tmp = next;
				}
				emStrongDel.PrependChild(openMarker);
				emStrongDel.AppendChild(closeMarker);
				openerInl.InsertAfter(emStrongDel);
				if (!(opener.next === closer)) {
					opener.next = closer;
					closer.previous = opener;
				}
				if (opener.num === 0) {
					openerInl.Unlink();
					t.removeDelimiter(opener, ctx);
				}
				if (closer.num === 0) {
					closerInl.Unlink();
					tempStack = closer.next;
					t.removeDelimiter(closer, ctx);
					closer = tempStack;
				}
			}
			if (!openerFound && !oddMatch) {
				_key$3 = closercc; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key$3)] = { k: _key$3, v: oldCloser.previous };
				if (!oldCloser.canOpen) {
					t.removeDelimiter(oldCloser, ctx);
				}
			}
		}
		while (true) {
			if (!(!(ptrType$2.nil === ctx.delimiters) && !(ctx.delimiters === stackBottom))) { break; }
			t.removeDelimiter(ctx.delimiters, ctx);
		}
	};
	Tree.prototype.processEmphasis = function(stackBottom, ctx) { return this.$val.processEmphasis(stackBottom, ctx); };
	Tree.ptr.prototype.scanDelims = function(ctx) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, afterIsPunct, afterIsWhitespace, beforeIsPunct, beforeIsWhitespace, canClose, canOpen, ctx, delimitersCount, i, isLeftFlanking, isRightFlanking, startPos, t, t$1, t$2, token, tokenAfter, tokenBefore, x, x$1, x$2, x$3, x$4, x$5;
		t = this;
		startPos = ctx.pos;
		token = (x = ctx.tokens, ((startPos < 0 || startPos >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + startPos]));
		delimitersCount = 0;
		i = ctx.pos;
		while (true) {
			if (!(i < ctx.tokensLen && (token === (x$1 = ctx.tokens, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]))))) { break; }
			delimitersCount = delimitersCount + (1) >> 0;
			ctx.pos = ctx.pos + (1) >> 0;
			i = i + (1) >> 0;
		}
		_tmp = 10;
		_tmp$1 = 10;
		tokenBefore = _tmp;
		tokenAfter = _tmp$1;
		if (0 < startPos) {
			t$1 = (x$2 = ctx.tokens, x$3 = startPos - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
			if (t$1 >= 128) {
				_tuple = utf8.DecodeLastRune($subslice(ctx.tokens, 0, startPos));
				tokenBefore = _tuple[0];
			} else {
				tokenBefore = ((t$1 >> 0));
			}
		}
		if (ctx.tokensLen > ctx.pos) {
			t$2 = (x$4 = ctx.tokens, x$5 = ctx.pos, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5]));
			if (t$2 >= 128) {
				_tuple$1 = utf8.DecodeRune($subslice(ctx.tokens, ctx.pos));
				tokenAfter = _tuple$1[0];
			} else {
				tokenAfter = ((t$2 >> 0));
			}
		}
		afterIsWhitespace = isUnicodeWhitespace(tokenAfter);
		afterIsPunct = unicode.IsPunct(tokenAfter) || unicode.IsSymbol(tokenAfter);
		beforeIsWhitespace = isUnicodeWhitespace(tokenBefore);
		beforeIsPunct = unicode.IsPunct(tokenBefore) || unicode.IsSymbol(tokenBefore);
		isLeftFlanking = !afterIsWhitespace && (!afterIsPunct || beforeIsWhitespace || beforeIsPunct);
		isRightFlanking = !beforeIsWhitespace && (!beforeIsPunct || afterIsWhitespace || afterIsPunct);
		_tmp$2 = false;
		_tmp$3 = false;
		canOpen = _tmp$2;
		canClose = _tmp$3;
		if (95 === token) {
			canOpen = isLeftFlanking && (!isRightFlanking || beforeIsPunct);
			canClose = isRightFlanking && (!isLeftFlanking || afterIsPunct);
		} else {
			canOpen = isLeftFlanking;
			canClose = isRightFlanking;
		}
		return new delimiter.ptr(ptrType.nil, token, delimitersCount, 0, canOpen, canClose, ptrType$2.nil, ptrType$2.nil, true, false, false, 0, ptrType$2.nil);
	};
	Tree.prototype.scanDelims = function(ctx) { return this.$val.scanDelims(ctx); };
	Tree.ptr.prototype.removeDelimiter = function(delim, ctx) {
		var ctx, delim, ret, t;
		ret = ptrType$2.nil;
		t = this;
		if (!(ptrType$2.nil === delim.previous)) {
			delim.previous.next = delim.next;
		}
		if (ptrType$2.nil === delim.next) {
			ctx.delimiters = delim.previous;
		} else {
			delim.next.previous = delim.previous;
		}
		return ret;
	};
	Tree.prototype.removeDelimiter = function(delim, ctx) { return this.$val.removeDelimiter(delim, ctx); };
	Lute.ptr.prototype.newEChartsJSONRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$3, _key$4, _key$5, _key$6, _key$7, _key$8, _key$9, lute, ret, tree;
		lute = this;
		ret = new EChartsJSONRenderer.ptr(lute.newBaseRenderer(tree));
		_key = 0; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocumentEChartsJSON") };
		_key$1 = 1; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraphEChartsJSON") };
		_key$2 = 16; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderTextEChartsJSON") };
		_key$3 = 27; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpanEChartsJSON") };
		_key$4 = 11; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeBlockEChartsJSON") };
		_key$5 = 300; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderMathBlockEChartsJSON") };
		_key$6 = 301; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderInlineMathEChartsJSON") };
		_key$7 = 17; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderEmphasisEChartsJSON") };
		_key$8 = 22; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderStrongEChartsJSON") };
		_key$9 = 5; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderBlockquoteEChartsJSON") };
		_key$10 = 2; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderHeadingEChartsJSON") };
		_key$11 = 7; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderListEChartsJSON") };
		_key$12 = 8; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderListItemEChartsJSON") };
		_key$13 = 4; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderThematicBreakEChartsJSON") };
		_key$14 = 31; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderHardBreakEChartsJSON") };
		_key$15 = 32; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderSoftBreakEChartsJSON") };
		_key$16 = 9; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderHTMLEChartsJSON") };
		_key$17 = 10; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderInlineHTMLEChartsJSON") };
		_key$18 = 33; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderLinkEChartsJSON") };
		_key$19 = 34; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderImageEChartsJSON") };
		_key$20 = 101; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderStrikethroughEChartsJSON") };
		_key$21 = 100; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderTaskListItemMarkerEChartsJSON") };
		_key$22 = 106; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderTableEChartsJSON") };
		_key$23 = 107; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderTableHeadEChartsJSON") };
		_key$24 = 108; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderTableRowEChartsJSON") };
		_key$25 = 109; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderTableCellEChartsJSON") };
		_key$26 = 201; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderEmojiUnicodeEChartsJSON") };
		_key$27 = 202; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderEmojiImgEChartsJSON") };
		ret.BaseRenderer.defaultRendererFunc = $methodVal(ret, "renderDefault");
		return ret;
	};
	Lute.prototype.newEChartsJSONRenderer = function(tree) { return this.$val.newEChartsJSONRenderer(tree); };
	EChartsJSONRenderer.ptr.prototype.renderDefault = function(n, entering) {
		var entering, n, r;
		r = this;
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderDefault = function(n, entering) { return this.$val.renderDefault(n, entering); };
	EChartsJSONRenderer.ptr.prototype.renderInlineMathEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Inline Math\nspan", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderInlineMathEChartsJSON = function(node, entering) { return this.$val.renderInlineMathEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderMathBlockEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Math Block\ndiv", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderMathBlockEChartsJSON = function(node, entering) { return this.$val.renderMathBlockEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmojiImgEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Emoji Img\n", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderEmojiImgEChartsJSON = function(node, entering) { return this.$val.renderEmojiImgEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmojiUnicodeEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Emoji Unicode\n", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderEmojiUnicodeEChartsJSON = function(node, entering) { return this.$val.renderEmojiUnicodeEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTableCellEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Table Cell\ntd", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderTableCellEChartsJSON = function(node, entering) { return this.$val.renderTableCellEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTableRowEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Table Row\ntr", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderTableRowEChartsJSON = function(node, entering) { return this.$val.renderTableRowEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTableHeadEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Table Head\nthead", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderTableHeadEChartsJSON = function(node, entering) { return this.$val.renderTableHeadEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTableEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Table\ntable", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderTableEChartsJSON = function(node, entering) { return this.$val.renderTableEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderStrikethroughEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Strikethrough\ndel", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderStrikethroughEChartsJSON = function(node, entering) { return this.$val.renderStrikethroughEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderImageEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Image\nimg", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderImageEChartsJSON = function(node, entering) { return this.$val.renderImageEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderLinkEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Link\na", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderLinkEChartsJSON = function(node, entering) { return this.$val.renderLinkEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderHTMLEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("HTML Block\n", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderHTMLEChartsJSON = function(node, entering) { return this.$val.renderHTMLEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderInlineHTMLEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Inline HTML\n", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderInlineHTMLEChartsJSON = function(node, entering) { return this.$val.renderInlineHTMLEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderDocumentEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.writeByte(91);
			r.openObj();
			r.val("Document", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
			r.BaseRenderer.writeByte(93);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderDocumentEChartsJSON = function(node, entering) { return this.$val.renderDocumentEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderParagraphEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Paragraph\np", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderParagraphEChartsJSON = function(node, entering) { return this.$val.renderParagraphEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTextEChartsJSON = function(node, entering) {
		var _i, _ref, _rune, entering, i, node, r, r$1, summary, text;
		r = this;
		if (entering) {
			text = bytesToStr(node.tokens);
			i = 0;
			summary = "";
			_ref = text;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				r$1 = _rune[0];
				i = i + (1) >> 0;
				summary = summary + (($encodeRune(r$1)));
				if (4 < i) {
					summary = summary + ("...");
					break;
				}
				_i += _rune[1];
			}
			r.openObj();
			r.val("Text\n" + summary, node);
			r.closeObj(node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderTextEChartsJSON = function(node, entering) { return this.$val.renderTextEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderCodeSpanEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Code Span\ncode", node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderCodeSpanEChartsJSON = function(node, entering) { return this.$val.renderCodeSpanEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmphasisEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Emphasis\nem", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderEmphasisEChartsJSON = function(node, entering) { return this.$val.renderEmphasisEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderStrongEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Strong\nstrong", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderStrongEChartsJSON = function(node, entering) { return this.$val.renderStrongEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderBlockquoteEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Blockquote\nblockquote", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderBlockquoteEChartsJSON = function(node, entering) { return this.$val.renderBlockquoteEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderHeadingEChartsJSON = function(node, entering) {
		var entering, h, node, r;
		r = this;
		if (entering) {
			r.openObj();
			h = "h" + $substring(" 123456", node.headingLevel, (node.headingLevel + 1 >> 0));
			r.val("Heading\n" + h, node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderHeadingEChartsJSON = function(node, entering) { return this.$val.renderHeadingEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderListEChartsJSON = function(node, entering) {
		var entering, list, node, r;
		r = this;
		if (entering) {
			r.openObj();
			list = "ul";
			if (1 === node.listData.typ) {
				list = "ol";
			}
			r.val("List\n" + list, node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderListEChartsJSON = function(node, entering) { return this.$val.renderListEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderListItemEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("List Item\nli " + bytesToStr(node.listData.marker), node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderListItemEChartsJSON = function(node, entering) { return this.$val.renderListItemEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTaskListItemMarkerEChartsJSON = function(node, entering) {
		var check, entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			check = " ";
			if (node.taskListItemChecked) {
				check = "X";
			}
			r.val("Task List Item Marker\n[" + check + "]", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return [2, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderTaskListItemMarkerEChartsJSON = function(node, entering) { return this.$val.renderTaskListItemMarkerEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderThematicBreakEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Thematic Break\nhr", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderThematicBreakEChartsJSON = function(node, entering) { return this.$val.renderThematicBreakEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderHardBreakEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Hard Break\nbr", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderHardBreakEChartsJSON = function(node, entering) { return this.$val.renderHardBreakEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderSoftBreakEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Soft Break\n", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderSoftBreakEChartsJSON = function(node, entering) { return this.$val.renderSoftBreakEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderCodeBlockEChartsJSON = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Code Block\npre.code", node);
		}
		return [0, $ifaceNil];
	};
	EChartsJSONRenderer.prototype.renderCodeBlockEChartsJSON = function(node, entering) { return this.$val.renderCodeBlockEChartsJSON(node, entering); };
	EChartsJSONRenderer.ptr.prototype.leaf = function(val, node) {
		var node, r, val;
		r = this;
		r.openObj();
		r.val(val, node);
		r.closeObj(node);
	};
	EChartsJSONRenderer.prototype.leaf = function(val, node) { return this.$val.leaf(val, node); };
	EChartsJSONRenderer.ptr.prototype.val = function(val, node) {
		var node, r, val;
		r = this;
		val = strings.ReplaceAll(val, "\\", "\\\\");
		val = strings.ReplaceAll(val, "\n", "\\n");
		val = strings.ReplaceAll(val, "\"", "");
		val = strings.ReplaceAll(val, "'", "");
		r.BaseRenderer.writeString("\"name\":\"" + val + "\"");
	};
	EChartsJSONRenderer.prototype.val = function(val, node) { return this.$val.val(val, node); };
	EChartsJSONRenderer.ptr.prototype.openObj = function() {
		var r;
		r = this;
		r.BaseRenderer.writeByte(123);
	};
	EChartsJSONRenderer.prototype.openObj = function() { return this.$val.openObj(); };
	EChartsJSONRenderer.ptr.prototype.closeObj = function(node) {
		var node, r;
		r = this;
		r.BaseRenderer.writeByte(125);
		if (!r.ignore(node.next)) {
			r.comma();
		}
	};
	EChartsJSONRenderer.prototype.closeObj = function(node) { return this.$val.closeObj(node); };
	EChartsJSONRenderer.ptr.prototype.openChildren = function(node) {
		var node, r;
		r = this;
		if (!(ptrType.nil === node.firstChild)) {
			r.BaseRenderer.writeString(",\"children\":[");
		}
	};
	EChartsJSONRenderer.prototype.openChildren = function(node) { return this.$val.openChildren(node); };
	EChartsJSONRenderer.ptr.prototype.closeChildren = function(node) {
		var node, r;
		r = this;
		if (!(ptrType.nil === node.firstChild)) {
			r.BaseRenderer.writeByte(93);
		}
	};
	EChartsJSONRenderer.prototype.closeChildren = function(node) { return this.$val.closeChildren(node); };
	EChartsJSONRenderer.ptr.prototype.comma = function() {
		var r;
		r = this;
		r.BaseRenderer.writeString(",");
	};
	EChartsJSONRenderer.prototype.comma = function() { return this.$val.comma(); };
	EChartsJSONRenderer.ptr.prototype.ignore = function(node) {
		var node, r;
		r = this;
		return ptrType.nil === node || (6 === node.typ) || (18 === node.typ) || (19 === node.typ) || (20 === node.typ) || (21 === node.typ) || (23 === node.typ) || (24 === node.typ) || (25 === node.typ) || (26 === node.typ) || (102 === node.typ) || (103 === node.typ) || (104 === node.typ) || (105 === node.typ);
	};
	EChartsJSONRenderer.prototype.ignore = function(node) { return this.$val.ignore(node); };
	Tree.ptr.prototype.emoji = function(node) {
		var child, next, node, t;
		t = this;
		child = node.firstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.next;
			if (16 === child.typ) {
				t.emoji0(child);
			} else {
				t.emoji(child);
			}
			child = next;
		}
	};
	Tree.prototype.emoji = function(node) { return this.$val.emoji(node); };
	Tree.ptr.prototype.emoji0 = function(node) {
		var _entry, _tuple, alias, alias$1, emoji, emojiNode, emojiTokens, emojiUnicodeOrImg, first, i, length, matchCloseColon, maybeEmoji, node, ok, pos, src, suffix, t, text, token, tokens;
		t = this;
		first = node;
		tokens = node.tokens;
		node.tokens = new sliceType([]);
		length = tokens.$length;
		token = 0;
		maybeEmoji = sliceType.nil;
		pos = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (i === (length - 1 >> 0)) {
				node.tokens = $appendSlice(node.tokens, $subslice(tokens, pos));
				break;
			}
			if (!((58 === token))) {
				i = i + (1) >> 0;
				continue;
			}
			node.tokens = $appendSlice(node.tokens, $subslice(tokens, pos, i));
			matchCloseColon = false;
			pos = i + 1 >> 0;
			while (true) {
				if (!(pos < length)) { break; }
				token = ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]);
				if (isWhitespace(token)) {
					break;
				}
				if (58 === token) {
					matchCloseColon = true;
					break;
				}
				pos = pos + (1) >> 0;
			}
			if (!matchCloseColon) {
				node.tokens = $appendSlice(node.tokens, $subslice(tokens, i, pos));
				i = i + (1) >> 0;
				continue;
			}
			maybeEmoji = $subslice(tokens, (i + 1 >> 0), pos);
			if (1 > maybeEmoji.$length) {
				node.tokens = $append(node.tokens, ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]));
				i = i + (1) >> 0;
				continue;
			}
			_tuple = (_entry = t.context.option.AliasEmoji[$String.keyFor(bytesToStr(maybeEmoji))], _entry !== undefined ? [_entry.v, true] : ["", false]);
			emoji = _tuple[0];
			ok = _tuple[1];
			if (ok) {
				emojiNode = new Node.ptr(200, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				emojiUnicodeOrImg = new Node.ptr(201, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				emojiNode.AppendChild(emojiUnicodeOrImg);
				emojiTokens = strToBytes(emoji);
				if (bytes.Contains(emojiTokens, emojiSitePlaceholder)) {
					alias = bytesToStr(maybeEmoji);
					suffix = ".png";
					if ("huaji" === alias) {
						suffix = ".gif";
					}
					src = t.context.option.EmojiSite + "/" + alias + suffix;
					emojiUnicodeOrImg.typ = 202;
					emojiUnicodeOrImg.tokens = t.emojiImgTokens(alias, src);
				} else if (bytes.Contains(emojiTokens, emojiDot)) {
					alias$1 = bytesToStr(maybeEmoji);
					emojiUnicodeOrImg.typ = 202;
					emojiUnicodeOrImg.tokens = t.emojiImgTokens(alias$1, emoji);
				} else {
					emojiUnicodeOrImg.tokens = emojiTokens;
				}
				emojiUnicodeOrImg.AppendChild(new Node.ptr(203, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(tokens, i, (pos + 1 >> 0)), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				node.InsertAfter(emojiNode);
				if ((pos + 1 >> 0) < length) {
					text = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", new sliceType([]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
					emojiNode.InsertAfter(text);
					node = text;
				}
			} else {
				node.tokens = $appendSlice(node.tokens, $subslice(tokens, i, (pos + 1 >> 0)));
			}
			pos = pos + (1) >> 0;
			i = pos;
		}
		if (1 > first.tokens.$length) {
			first.Unlink();
		}
		if (1 > node.tokens.$length) {
			node.Unlink();
		}
	};
	Tree.prototype.emoji0 = function(node) { return this.$val.emoji0(node); };
	Tree.ptr.prototype.emojiImgTokens = function(alias, src) {
		var alias, src, t;
		t = this;
		return strToBytes("<img alt=\"" + alias + "\" class=\"emoji\" src=\"" + src + "\" title=\"" + alias + "\" />");
	};
	Tree.prototype.emojiImgTokens = function(alias, src) { return this.$val.emojiImgTokens(alias, src); };
	newEmojis = function() {
		var _entry, _i, _key, _key$1, _keys, _ref, aliasEmoji, emojiAlias, k, v, x, x$1;
		emojiAlias = false;
		aliasEmoji = false;
		emojiAlias = (x = $keys(aliasUnicodeEmojiMap).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		aliasEmoji = (x$1 = $keys(aliasUnicodeEmojiMap).length, ((x$1 < 0 || x$1 > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = aliasUnicodeEmojiMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (emojiAlias || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_key$1 = v; (aliasEmoji || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: k };
			_i++;
		}
		return [emojiAlias, aliasEmoji];
	};
	init = function() {
		var _entry, _i, _key, _keys, _ref, k, v, x;
		unicodeAliasEmojiMap = (x = $keys(aliasUnicodeEmojiMap).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = aliasUnicodeEmojiMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = v; (unicodeAliasEmojiMap || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: k };
			_i++;
		}
	};
	escapeHTML = function(html$1) {
		var _1, _tmp, _tmp$1, html$1, i, inited, length, ret, start;
		ret = sliceType.nil;
		length = html$1.$length;
		_tmp = 0;
		_tmp$1 = 0;
		start = _tmp;
		i = _tmp$1;
		inited = false;
		ret = html$1;
		while (true) {
			if (!(i < length)) { break; }
			_1 = ((i < 0 || i >= html$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : html$1.$array[html$1.$offset + i]);
			if (_1 === (38)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, amp);
				start = i + 1 >> 0;
			} else if (_1 === (60)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, lt);
				start = i + 1 >> 0;
			} else if (_1 === (62)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, gt);
				start = i + 1 >> 0;
			} else if (_1 === (34)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, quot);
				start = i + 1 >> 0;
			}
			i = i + (1) >> 0;
		}
		if (inited) {
			ret = $appendSlice(ret, $subslice(html$1, start));
		}
		return ret;
	};
	encodeDestination = function(rawurl) {
		var _tmp, _tmp$1, _tuple, b, i, j, n, r, rawurl, ret, rlen, token, x, x$1, x$2, x$3;
		ret = sliceType.nil;
		ret = $makeSlice(sliceType, 0, 256);
		i = 0;
		token = 0;
		while (true) {
			if (!(i < rawurl.$length)) { break; }
			_tuple = utf8.DecodeRune($subslice(rawurl, i));
			r = _tuple[0];
			rlen = _tuple[1];
			if (128 <= r) {
				_tmp = i;
				_tmp$1 = i + rlen >> 0;
				j = _tmp;
				n = _tmp$1;
				while (true) {
					if (!(j < n)) { break; }
					b = ((j < 0 || j >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + j]);
					token = ((j < 0 || j >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + j]);
					ret = $append(ret, 37);
					ret = $append(ret, "0123456789ABCDEF".charCodeAt(((((b >>> 4 << 24 >>> 24)) & 15) >>> 0)));
					ret = $append(ret, "0123456789ABCDEF".charCodeAt(((b & 15) >>> 0)));
					j = j + (1) >> 0;
				}
			} else if (r === 37) {
				token = ((i < 0 || i >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + i]);
				if ((i + 2 >> 0) < rawurl.$length && isHexDigit((x = i + 1 >> 0, ((x < 0 || x >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x]))) && isHexDigit((x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x$1])))) {
					ret = $append(ret, 37);
					ret = $append(ret, tokenToUpper((x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x$2]))));
					ret = $append(ret, tokenToUpper((x$3 = i + 2 >> 0, ((x$3 < 0 || x$3 >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x$3]))));
					i = i + (2) >> 0;
				} else {
					ret = $append(ret, 37);
					ret = $append(ret, 50);
					ret = $append(ret, 53);
				}
			} else if (strings.IndexByte("!#$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~", ((r << 24 >>> 24))) === -1) {
				token = ((i < 0 || i >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + i]);
				ret = $append(ret, 37);
				ret = $append(ret, "0123456789ABCDEF".charCodeAt((((r >> 4 >> 0)) & 15)));
				ret = $append(ret, "0123456789ABCDEF".charCodeAt((r & 15)));
			} else {
				token = ((i < 0 || i >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + i]);
				ret = $append(ret, token);
			}
			i = i + (rlen) >> 0;
		}
		return ret;
	};
	Lute.ptr.prototype.newFormatRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$35, _key$36, _key$37, _key$38, _key$39, _key$4, _key$40, _key$41, _key$42, _key$43, _key$44, _key$45, _key$46, _key$47, _key$48, _key$49, _key$5, _key$50, _key$51, _key$52, _key$53, _key$54, _key$55, _key$56, _key$57, _key$58, _key$59, _key$6, _key$7, _key$8, _key$9, lute, ret, tree;
		lute = this;
		ret = new FormatRenderer.ptr(lute.newBaseRenderer(tree), sliceType$4.nil);
		_key = 0; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 28; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeSpanOpenMarker") };
		_key$5 = 29; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderCodeSpanContent") };
		_key$6 = 30; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderCodeSpanCloseMarker") };
		_key$7 = 11; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderCodeBlock") };
		_key$8 = 12; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderCodeBlockOpenMarker") };
		_key$9 = 14; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderCodeBlockInfoMarker") };
		_key$10 = 15; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderCodeBlockCode") };
		_key$11 = 13; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderCodeBlockCloseMarker") };
		_key$12 = 300; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderMathBlock") };
		_key$13 = 301; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderInlineMath") };
		_key$14 = 17; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderEmphasis") };
		_key$15 = 18; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderEmAsteriskOpenMarker") };
		_key$16 = 19; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderEmAsteriskCloseMarker") };
		_key$17 = 20; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderEmUnderscoreOpenMarker") };
		_key$18 = 21; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderEmUnderscoreCloseMarker") };
		_key$19 = 22; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderStrong") };
		_key$20 = 23; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderStrongA6kOpenMarker") };
		_key$21 = 24; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderStrongA6kCloseMarker") };
		_key$22 = 25; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderStrongU8eOpenMarker") };
		_key$23 = 26; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderStrongU8eCloseMarker") };
		_key$24 = 5; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderBlockquote") };
		_key$25 = 6; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderBlockquoteMarker") };
		_key$26 = 2; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderHeading") };
		_key$27 = 3; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderHeadingC8hMarker") };
		_key$28 = 7; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderList") };
		_key$29 = 8; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderListItem") };
		_key$30 = 4; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderThematicBreak") };
		_key$31 = 31; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderHardBreak") };
		_key$32 = 32; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderSoftBreak") };
		_key$33 = 9; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderHTML") };
		_key$34 = 10; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderInlineHTML") };
		_key$35 = 33; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$35)] = { k: _key$35, v: $methodVal(ret, "renderLink") };
		_key$36 = 34; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$36)] = { k: _key$36, v: $methodVal(ret, "renderImage") };
		_key$37 = 35; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$37)] = { k: _key$37, v: $methodVal(ret, "renderBang") };
		_key$38 = 36; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$38)] = { k: _key$38, v: $methodVal(ret, "renderOpenBracket") };
		_key$39 = 37; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$39)] = { k: _key$39, v: $methodVal(ret, "renderCloseBracket") };
		_key$40 = 38; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$40)] = { k: _key$40, v: $methodVal(ret, "renderOpenParen") };
		_key$41 = 39; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$41)] = { k: _key$41, v: $methodVal(ret, "renderCloseParen") };
		_key$42 = 40; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$42)] = { k: _key$42, v: $methodVal(ret, "renderLinkText") };
		_key$43 = 43; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$43)] = { k: _key$43, v: $methodVal(ret, "renderLinkSpace") };
		_key$44 = 41; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$44)] = { k: _key$44, v: $methodVal(ret, "renderLinkDest") };
		_key$45 = 42; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$45)] = { k: _key$45, v: $methodVal(ret, "renderLinkTitle") };
		_key$46 = 101; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$46)] = { k: _key$46, v: $methodVal(ret, "renderStrikethrough") };
		_key$47 = 102; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$47)] = { k: _key$47, v: $methodVal(ret, "renderStrikethrough1OpenMarker") };
		_key$48 = 103; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$48)] = { k: _key$48, v: $methodVal(ret, "renderStrikethrough1CloseMarker") };
		_key$49 = 104; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$49)] = { k: _key$49, v: $methodVal(ret, "renderStrikethrough2OpenMarker") };
		_key$50 = 105; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$50)] = { k: _key$50, v: $methodVal(ret, "renderStrikethrough2CloseMarker") };
		_key$51 = 100; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$51)] = { k: _key$51, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$52 = 106; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$52)] = { k: _key$52, v: $methodVal(ret, "renderTable") };
		_key$53 = 107; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$53)] = { k: _key$53, v: $methodVal(ret, "renderTableHead") };
		_key$54 = 108; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$54)] = { k: _key$54, v: $methodVal(ret, "renderTableRow") };
		_key$55 = 109; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$55)] = { k: _key$55, v: $methodVal(ret, "renderTableCell") };
		_key$56 = 200; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$56)] = { k: _key$56, v: $methodVal(ret, "renderEmoji") };
		_key$57 = 201; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$57)] = { k: _key$57, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$58 = 202; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$58)] = { k: _key$58, v: $methodVal(ret, "renderEmojiImg") };
		_key$59 = 203; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$59)] = { k: _key$59, v: $methodVal(ret, "renderEmojiAlias") };
		return ret;
	};
	Lute.prototype.newFormatRenderer = function(tree) { return this.$val.newFormatRenderer(tree); };
	FormatRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	FormatRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	FormatRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	FormatRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	FormatRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.writeByte(124);
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	FormatRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!entering) {
			r.BaseRenderer.writeString("|\n");
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	FormatRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var _1, align, entering, i, node, r, table, x;
		r = this;
		if (!entering) {
			table = node.parent;
			i = 0;
			while (true) {
				if (!(i < table.tableAligns.$length)) { break; }
				align = (x = table.tableAligns, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
				_1 = align;
				if (_1 === (0)) {
					r.BaseRenderer.writeString("|---");
				} else if (_1 === (1)) {
					r.BaseRenderer.writeString("|:---");
				} else if (_1 === (2)) {
					r.BaseRenderer.writeString("|:---:");
				} else if (_1 === (3)) {
					r.BaseRenderer.writeString("|---:");
				}
				i = i + (1) >> 0;
			}
			r.BaseRenderer.writeString("|\n");
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	FormatRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!entering) {
			r.BaseRenderer.newline();
			if (!r.isLastNode(r.BaseRenderer.tree.Root, node)) {
				r.BaseRenderer.writeByte(10);
			}
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough1OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(126);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrikethrough1OpenMarker = function(node, entering) { return this.$val.renderStrikethrough1OpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough1CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(126);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrikethrough1CloseMarker = function(node, entering) { return this.$val.renderStrikethrough1CloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough2OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("~~");
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrikethrough2OpenMarker = function(node, entering) { return this.$val.renderStrikethrough2OpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough2CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("~~");
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrikethrough2CloseMarker = function(node, entering) { return this.$val.renderStrikethrough2CloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkTitle = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("\"");
		r.BaseRenderer.write(node.tokens);
		r.BaseRenderer.writeString("\"");
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderLinkTitle = function(node, entering) { return this.$val.renderLinkTitle(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkDest = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderLinkDest = function(node, entering) { return this.$val.renderLinkDest(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkSpace = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(32);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderLinkSpace = function(node, entering) { return this.$val.renderLinkSpace(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkText = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderLinkText = function(node, entering) { return this.$val.renderLinkText(node, entering); };
	FormatRenderer.ptr.prototype.renderCloseParen = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(41);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCloseParen = function(node, entering) { return this.$val.renderCloseParen(node, entering); };
	FormatRenderer.ptr.prototype.renderOpenParen = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(40);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderOpenParen = function(node, entering) { return this.$val.renderOpenParen(node, entering); };
	FormatRenderer.ptr.prototype.renderCloseBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(93);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCloseBracket = function(node, entering) { return this.$val.renderCloseBracket(node, entering); };
	FormatRenderer.ptr.prototype.renderOpenBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(91);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderOpenBracket = function(node, entering) { return this.$val.renderOpenBracket(node, entering); };
	FormatRenderer.ptr.prototype.renderBang = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(33);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderBang = function(node, entering) { return this.$val.renderBang(node, entering); };
	FormatRenderer.ptr.prototype.renderImage = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	FormatRenderer.ptr.prototype.renderLink = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	FormatRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.newline();
		r.BaseRenderer.write(node.tokens);
		r.BaseRenderer.newline();
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	FormatRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	FormatRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var _r, buf, entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.writer = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.writer);
			$s = 3; continue;
		/* } else { */ case 2:
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			_r = bytes.Trim(r.BaseRenderer.writer.Bytes(), " \t\n"); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.writer.Reset();
			r.BaseRenderer.writeBytes(buf);
			r.BaseRenderer.writeByte(10);
		/* } */ case 3:
		$s = -1; return [2, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderDocument }; } $f._r = _r; $f.buf = buf; $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	FormatRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, inTightList, lastListItemLastPara, listItem, nextItem, nextPara, node, parent, r;
		r = this;
		if (!entering) {
			r.BaseRenderer.newline();
			inTightList = false;
			lastListItemLastPara = false;
			parent = node.parent;
			if (!(ptrType.nil === parent)) {
				if (8 === parent.typ) {
					listItem = parent;
					inTightList = listItem.parent.listData.tight;
					nextItem = listItem.next;
					if (ptrType.nil === nextItem) {
						nextPara = node.next;
						lastListItemLastPara = ptrType.nil === nextPara;
					}
				}
			}
			if (!inTightList || (lastListItemLastPara)) {
				r.BaseRenderer.writeByte(10);
			}
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	FormatRenderer.ptr.prototype.renderText = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (r.BaseRenderer.option.AutoSpace) {
			r.BaseRenderer.space(node);
		}
		/* */ if (r.BaseRenderer.option.FixTermTypo) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.option.FixTermTypo) { */ case 1:
			$r = r.BaseRenderer.fixTermTypo(node); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		r.BaseRenderer.write(node.tokens);
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderText }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpanOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(96);
		if (1 < node.parent.codeMarkerLen) {
			r.BaseRenderer.writeByte(96);
			r.BaseRenderer.writeByte(32);
		}
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeSpanOpenMarker = function(node, entering) { return this.$val.renderCodeSpanOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpanContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeSpanContent = function(node, entering) { return this.$val.renderCodeSpanContent(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpanCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		if (1 < node.parent.codeMarkerLen) {
			r.BaseRenderer.writeByte(32);
			r.BaseRenderer.writeByte(96);
		}
		r.BaseRenderer.writeByte(96);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeSpanCloseMarker = function(node, entering) { return this.$val.renderCodeSpanCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(36);
		r.BaseRenderer.write(node.tokens);
		r.BaseRenderer.writeByte(36);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	FormatRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.newline();
			r.BaseRenderer.write(mathBlockMarker);
			r.BaseRenderer.newline();
			r.BaseRenderer.write(node.tokens);
			return [1, $ifaceNil];
		}
		r.BaseRenderer.newline();
		r.BaseRenderer.write(mathBlockMarker);
		r.BaseRenderer.newline();
		if (!r.isLastNode(r.BaseRenderer.tree.Root, node)) {
			r.BaseRenderer.writeByte(10);
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.newline();
		r.BaseRenderer.writeBytes(bytes.Repeat(new sliceType([96]), node.codeBlockFenceLen));
		r.BaseRenderer.newline();
		if (!r.isLastNode(r.BaseRenderer.tree.Root, node)) {
			r.BaseRenderer.writeByte(10);
		}
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeBlockCloseMarker = function(node, entering) { return this.$val.renderCodeBlockCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockCode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeBlockCode = function(node, entering) { return this.$val.renderCodeBlockCode(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockInfoMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.codeBlockInfo);
		r.BaseRenderer.writeByte(10);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeBlockInfoMarker = function(node, entering) { return this.$val.renderCodeBlockInfoMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeBytes(bytes.Repeat(new sliceType([96]), node.codeBlockFenceLen));
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeBlockOpenMarker = function(node, entering) { return this.$val.renderCodeBlockOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!node.isFencedCodeBlock) {
			r.BaseRenderer.writeBytes(bytes.Repeat(new sliceType([96]), 3));
			r.BaseRenderer.writeByte(10);
			r.BaseRenderer.write(node.tokens);
			r.BaseRenderer.writeBytes(bytes.Repeat(new sliceType([96]), 3));
			r.BaseRenderer.newline();
			if (!r.isLastNode(r.BaseRenderer.tree.Root, node)) {
				r.BaseRenderer.writeByte(10);
			}
			return [0, $ifaceNil];
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	FormatRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	FormatRenderer.ptr.prototype.renderEmAsteriskOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(42);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmAsteriskOpenMarker = function(node, entering) { return this.$val.renderEmAsteriskOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderEmAsteriskCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(42);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmAsteriskCloseMarker = function(node, entering) { return this.$val.renderEmAsteriskCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderEmUnderscoreOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(95);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmUnderscoreOpenMarker = function(node, entering) { return this.$val.renderEmUnderscoreOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderEmUnderscoreCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeByte(95);
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderEmUnderscoreCloseMarker = function(node, entering) { return this.$val.renderEmUnderscoreCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongA6kOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("**");
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrongA6kOpenMarker = function(node, entering) { return this.$val.renderStrongA6kOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongA6kCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("**");
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrongA6kCloseMarker = function(node, entering) { return this.$val.renderStrongA6kCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongU8eOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("__");
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrongU8eOpenMarker = function(node, entering) { return this.$val.renderStrongU8eOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongU8eCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("__");
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderStrongU8eCloseMarker = function(node, entering) { return this.$val.renderStrongU8eCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var _i, _r, _ref, blockquoteLines, buf, entering, length, line, lines, node, r, writer, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; blockquoteLines = $f.blockquoteLines; buf = $f.buf; entering = $f.entering; length = $f.length; line = $f.line; lines = $f.lines; node = $f.node; r = $f.r; writer = $f.writer; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.writer = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.writer);
			$s = 3; continue;
		/* } else { */ case 2:
			writer = (x = r.nodeWriterStack, x$1 = r.nodeWriterStack.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			blockquoteLines = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
			buf = writer.Bytes();
			lines = bytes.Split(buf, new sliceType([10]));
			length = lines.$length;
			if (2 < length && isBlank((x$2 = length - 1 >> 0, ((x$2 < 0 || x$2 >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + x$2]))) && isBlank((x$3 = length - 2 >> 0, ((x$3 < 0 || x$3 >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + x$3])))) {
				lines = $subslice(lines, 0, (length - 1 >> 0));
			}
			if (1 === r.nodeWriterStack.$length) {
				length = lines.$length;
				if (1 < length && isBlank((x$4 = length - 1 >> 0, ((x$4 < 0 || x$4 >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + x$4])))) {
					lines = $subslice(lines, 0, (length - 1 >> 0));
				}
			}
			_ref = lines;
			_i = 0;
			/* while (true) { */ case 4:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
				line = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (0 === line.$length) {
					blockquoteLines.WriteString(">\n");
					_i++;
					/* continue; */ $s = 4; continue;
				}
				blockquoteLines.WriteString("> ");
				blockquoteLines.Write(line);
				blockquoteLines.WriteByte(10);
				_i++;
			/* } */ $s = 4; continue; case 5:
			buf = blockquoteLines.Bytes();
			writer.Reset();
			writer.Write(buf);
			(x$5 = r.nodeWriterStack, x$6 = r.nodeWriterStack.$length - 1 >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6])).Write(writer.Bytes());
			r.BaseRenderer.writer = (x$7 = r.nodeWriterStack, x$8 = r.nodeWriterStack.$length - 1 >> 0, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8]));
			_r = bytes.TrimSpace(r.BaseRenderer.writer.Bytes()); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.writer.Reset();
			r.BaseRenderer.writeBytes(buf);
			r.BaseRenderer.writeString("\n\n");
		/* } */ case 3:
		$s = -1; return [2, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderBlockquote }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.blockquoteLines = blockquoteLines; $f.buf = buf; $f.entering = entering; $f.length = length; $f.line = line; $f.lines = lines; $f.node = node; $f.r = r; $f.writer = writer; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	FormatRenderer.ptr.prototype.renderBlockquoteMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderBlockquoteMarker = function(node, entering) { return this.$val.renderBlockquoteMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.writeBytes(bytes.Repeat(new sliceType([35]), node.headingLevel));
			r.BaseRenderer.writeByte(32);
		} else {
			r.BaseRenderer.newline();
			r.BaseRenderer.writeByte(10);
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	FormatRenderer.ptr.prototype.renderHeadingC8hMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderHeadingC8hMarker = function(node, entering) { return this.$val.renderHeadingC8hMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderList = function(node, entering) {
		var _r, buf, entering, node, r, writer, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; entering = $f.entering; node = $f.node; r = $f.r; writer = $f.writer; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.writer = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.writer);
			$s = 3; continue;
		/* } else { */ case 2:
			writer = (x = r.nodeWriterStack, x$1 = r.nodeWriterStack.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			(x$2 = r.nodeWriterStack, x$3 = r.nodeWriterStack.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Write(writer.Bytes());
			r.BaseRenderer.writer = (x$4 = r.nodeWriterStack, x$5 = r.nodeWriterStack.$length - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5]));
			_r = bytes.TrimSpace(r.BaseRenderer.writer.Bytes()); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.writer.Reset();
			r.BaseRenderer.writeBytes(buf);
			r.BaseRenderer.writeString("\n\n");
		/* } */ case 3:
		$s = -1; return [2, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderList }; } $f._r = _r; $f.buf = buf; $f.entering = entering; $f.node = node; $f.r = r; $f.writer = writer; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	FormatRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var _i, _r, _ref, buf, entering, indent, indentSpaces, indentedLines, line, lines, listItemBuf, node, r, writer, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; buf = $f.buf; entering = $f.entering; indent = $f.indent; indentSpaces = $f.indentSpaces; indentedLines = $f.indentedLines; line = $f.line; lines = $f.lines; listItemBuf = $f.listItemBuf; node = $f.node; r = $f.r; writer = $f.writer; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.writer = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.writer);
			$s = 3; continue;
		/* } else { */ case 2:
			writer = (x = r.nodeWriterStack, x$1 = r.nodeWriterStack.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			indent = node.listData.marker.$length + 1 >> 0;
			if (1 === node.listData.typ) {
				indent = indent + (1) >> 0;
			}
			indentSpaces = bytes.Repeat(new sliceType([32]), indent);
			indentedLines = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
			buf = writer.Bytes();
			lines = bytes.Split(buf, new sliceType([10]));
			_ref = lines;
			_i = 0;
			/* while (true) { */ case 4:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
				line = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (0 === line.$length) {
					indentedLines.WriteByte(10);
					_i++;
					/* continue; */ $s = 4; continue;
				}
				indentedLines.Write(indentSpaces);
				indentedLines.Write(line);
				indentedLines.WriteByte(10);
				_i++;
			/* } */ $s = 4; continue; case 5:
			buf = indentedLines.Bytes();
			if (indent < buf.$length) {
				buf = $subslice(buf, indent);
			}
			listItemBuf = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
			if (1 === node.listData.typ) {
				listItemBuf.WriteString(strconv.Itoa(node.listData.num) + ".");
			} else {
				listItemBuf.Write(node.listData.marker);
			}
			listItemBuf.WriteByte(32);
			buf = $appendSlice(listItemBuf.Bytes(), buf);
			writer.Reset();
			writer.Write(buf);
			(x$2 = r.nodeWriterStack, x$3 = r.nodeWriterStack.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Write(writer.Bytes());
			r.BaseRenderer.writer = (x$4 = r.nodeWriterStack, x$5 = r.nodeWriterStack.$length - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5]));
			_r = bytes.TrimSpace(r.BaseRenderer.writer.Bytes()); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.writer.Reset();
			r.BaseRenderer.writeBytes(buf);
			r.BaseRenderer.writeString("\n");
		/* } */ case 3:
		$s = -1; return [2, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderListItem }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.buf = buf; $f.entering = entering; $f.indent = indent; $f.indentSpaces = indentSpaces; $f.indentedLines = indentedLines; $f.line = line; $f.lines = lines; $f.listItemBuf = listItemBuf; $f.node = node; $f.r = r; $f.writer = writer; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	FormatRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.writeByte(91);
			if (node.taskListItemChecked) {
				r.BaseRenderer.writeByte(88);
			} else {
				r.BaseRenderer.writeByte(32);
			}
			r.BaseRenderer.writeByte(93);
		}
		return [2, $ifaceNil];
	};
	FormatRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.newline();
			r.BaseRenderer.writeString("---");
			r.BaseRenderer.newline();
		}
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	FormatRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			if (!r.BaseRenderer.option.SoftBreak2HardBreak) {
				r.BaseRenderer.writeString("\\\n");
			} else {
				r.BaseRenderer.writeByte(10);
			}
		}
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	FormatRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.newline();
		}
		return [0, $ifaceNil];
	};
	FormatRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	FormatRenderer.ptr.prototype.isLastNode = function(treeRoot, node) {
		var n, node, r, treeRoot;
		r = this;
		if (treeRoot === node) {
			return true;
		}
		if (!(ptrType.nil === node.next)) {
			return false;
		}
		if (0 === node.parent.typ) {
			return treeRoot.lastChild === node;
		}
		n = ptrType.nil;
		n = node.parent;
		while (true) {
			if (0 === n.parent.typ) {
				break;
			}
			n = n.parent;
		}
		return treeRoot.lastChild === n;
	};
	FormatRenderer.prototype.isLastNode = function(treeRoot, node) { return this.$val.isLastNode(treeRoot, node); };
	Tree.ptr.prototype.parseATXHeading = function() {
		var _i, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3, closingCrosshatchIndex, content, level, marker, markers$1, ok, t, token, tokens;
		ok = false;
		markers$1 = sliceType.nil;
		content = sliceType.nil;
		level = 0;
		t = this;
		tokens = $subslice(t.context.currentLine, t.context.nextNonspace);
		marker = (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]);
		if (!((35 === marker))) {
			return [ok, markers$1, content, level];
		}
		level = accept(tokens, 35);
		if (6 < level) {
			return [ok, markers$1, content, level];
		}
		if (level < tokens.$length && !isWhitespace(((level < 0 || level >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + level]))) {
			return [ok, markers$1, content, level];
		}
		markers$1 = $subslice(t.context.currentLine, t.context.nextNonspace, ((t.context.nextNonspace + level >> 0) + 1 >> 0));
		content = $makeSlice(sliceType, 0, 256);
		_tuple = trimLeft(tokens);
		tokens = _tuple[1];
		_tuple$1 = trimLeft($subslice(tokens, level));
		tokens = _tuple$1[1];
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (10 === token) {
				break;
			}
			content = $append(content, token);
			_i++;
		}
		_tuple$2 = trimRight(content);
		content = _tuple$2[1];
		closingCrosshatchIndex = content.$length - 1 >> 0;
		while (true) {
			if (!(0 <= closingCrosshatchIndex)) { break; }
			if (35 === ((closingCrosshatchIndex < 0 || closingCrosshatchIndex >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + closingCrosshatchIndex])) {
				closingCrosshatchIndex = closingCrosshatchIndex - (1) >> 0;
				continue;
			}
			if (32 === ((closingCrosshatchIndex < 0 || closingCrosshatchIndex >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + closingCrosshatchIndex])) {
				break;
			} else {
				closingCrosshatchIndex = content.$length;
				break;
			}
			closingCrosshatchIndex = closingCrosshatchIndex - (1) >> 0;
		}
		if (0 >= closingCrosshatchIndex) {
			content = $makeSlice(sliceType, 0, 0);
		} else if (0 < closingCrosshatchIndex) {
			content = $subslice(content, 0, closingCrosshatchIndex);
			_tuple$3 = trimRight(content);
			content = _tuple$3[1];
		}
		ok = true;
		return [ok, markers$1, content, level];
	};
	Tree.prototype.parseATXHeading = function() { return this.$val.parseATXHeading(); };
	Tree.ptr.prototype.parseSetextHeading = function() {
		var length, level, ln, marker, markers$1, start, t, token;
		level = 0;
		t = this;
		ln = trimWhitespace(t.context.currentLine);
		start = 0;
		marker = ((start < 0 || start >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + start]);
		if (!((61 === marker)) && !((45 === marker))) {
			return level;
		}
		markers$1 = 0;
		length = ln.$length;
		while (true) {
			if (!(start < length)) { break; }
			token = ((start < 0 || start >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + start]);
			if (!((61 === token)) && !((45 === token))) {
				return level;
			}
			if (!((0 === marker))) {
				if (!((marker === token))) {
					return level;
				}
			} else {
				marker = token;
			}
			markers$1 = markers$1 + (1) >> 0;
			start = start + (1) >> 0;
		}
		level = 1;
		if (45 === marker) {
			level = 2;
		}
		return level;
	};
	Tree.prototype.parseSetextHeading = function() { return this.$val.parseSetextHeading(); };
	Node.ptr.prototype.htmlBlockContinue = function(context) {
		var context, html$1;
		html$1 = this;
		if (context.blank && ((html$1.htmlBlockType === 6) || (html$1.htmlBlockType === 7))) {
			return 1;
		}
		return 0;
	};
	Node.prototype.htmlBlockContinue = function(context) { return this.$val.htmlBlockContinue(context); };
	Node.ptr.prototype.htmlBlockFinalize = function(context) {
		var _tuple, context, html$1;
		html$1 = this;
		_tuple = trimRight(replaceNewlineSpace(html$1.tokens));
		html$1.tokens = _tuple[1];
	};
	Node.prototype.htmlBlockFinalize = function(context) { return this.$val.htmlBlockFinalize(context); };
	Tree.ptr.prototype.isHTMLBlockClose = function(tokens, htmlType) {
		var _1, htmlType, i, i$1, i$2, length, pos, t, tokens, x, x$1, x$2, x$3;
		t = this;
		length = tokens.$length;
		_1 = htmlType;
		if (_1 === (1)) {
			pos = acceptTokenss(tokens, htmlBlockCloseTags1);
			if (0 <= pos) {
				return true;
			}
			return false;
		} else if (_1 === (2)) {
			i = 0;
			while (true) {
				if (!(i < (length - 3 >> 0))) { break; }
				if ((45 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])) && (45 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) && (62 === (x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1])))) {
					return true;
				}
				i = i + (1) >> 0;
			}
		} else if (_1 === (3)) {
			i$1 = 0;
			while (true) {
				if (!(i$1 < (length - 2 >> 0))) { break; }
				if ((63 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1])) && (62 === (x$2 = i$1 + 1 >> 0, ((x$2 < 0 || x$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$2])))) {
					return true;
				}
				i$1 = i$1 + (1) >> 0;
			}
		} else if (_1 === (4)) {
			return bytes.Contains(tokens, htmlBlockGreater);
		} else if (_1 === (5)) {
			i$2 = 0;
			while (true) {
				if (!(i$2 < (length - 2 >> 0))) { break; }
				if ((93 === ((i$2 < 0 || i$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$2])) && (93 === (x$3 = i$2 + 1 >> 0, ((x$3 < 0 || x$3 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$3])))) {
					return true;
				}
				i$2 = i$2 + (1) >> 0;
			}
		}
		return false;
	};
	Tree.prototype.isHTMLBlockClose = function(tokens, htmlType) { return this.$val.isHTMLBlockClose(tokens, htmlType); };
	Tree.ptr.prototype.parseHTML = function(tokens) {
		var _tuple, following, isCloseTag, isOpenTag, length, pos, pos$1, t, tag, tokens, typ, x;
		typ = 0;
		t = this;
		_tuple = trimLeft(tokens);
		tokens = _tuple[1];
		length = tokens.$length;
		if (3 > length) {
			return typ;
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return typ;
		}
		typ = 1;
		pos = acceptTokenss(tokens, htmlBlockTags1);
		if (0 <= pos) {
			if (isWhitespace(((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos])) || (62 === ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]))) {
				return typ;
			}
		}
		pos$1 = acceptTokenss(tokens, htmlBlockTags6);
		if (0 <= pos$1) {
			if (isWhitespace(((pos$1 < 0 || pos$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos$1])) || (62 === ((pos$1 < 0 || pos$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos$1]))) {
				typ = 6;
				return typ;
			}
			if ((47 === ((pos$1 < 0 || pos$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos$1])) && (62 === (x = pos$1 + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
				typ = 6;
				return typ;
			}
		}
		tag = trimWhitespace(tokens);
		isOpenTag = t.isOpenTag(tag);
		if (isOpenTag && !((t.context.tip.typ === 1))) {
			typ = 7;
			return typ;
		}
		isCloseTag = t.isCloseTag(tag);
		if (isCloseTag && !((t.context.tip.typ === 1))) {
			typ = 7;
			return typ;
		}
		if (0 === bytes.Index(tokens, strToBytes("<!--"))) {
			typ = 2;
			return typ;
		}
		if (0 === bytes.Index(tokens, strToBytes("<?"))) {
			typ = 3;
			return typ;
		}
		if (2 < tokens.$length && (0 === bytes.Index(tokens, strToBytes("<!")))) {
			following = $subslice(tokens, 2);
			if (65 <= (0 >= following.$length ? ($throwRuntimeError("index out of range"), undefined) : following.$array[following.$offset + 0]) && 90 >= (0 >= following.$length ? ($throwRuntimeError("index out of range"), undefined) : following.$array[following.$offset + 0])) {
				typ = 4;
				return typ;
			}
			if (0 === bytes.Index(following, strToBytes("[CDATA["))) {
				typ = 5;
				return typ;
			}
		}
		typ = 0;
		return typ;
	};
	Tree.prototype.parseHTML = function(tokens) { return this.$val.parseHTML(tokens); };
	Tree.ptr.prototype.isOpenTag = function(tokens) {
		var _i, _i$1, _i$2, _ref, _ref$1, _ref$2, attr, attrs, isOpenTag, length, n, n$1, name, name$1, nameAndAttrs, nameAndValue, t, tokens, value, x, x$1;
		isOpenTag = false;
		t = this;
		length = tokens.$length;
		if (3 > length) {
			return isOpenTag;
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return isOpenTag;
		}
		if (!((62 === (x = length - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))))) {
			return isOpenTag;
		}
		if (47 === (x$1 = length - 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]))) {
			tokens = $subslice(tokens, 1, (length - 2 >> 0));
		} else {
			tokens = $subslice(tokens, 1, (length - 1 >> 0));
		}
		length = tokens.$length;
		if (0 === length) {
			return isOpenTag;
		}
		if (isWhitespace((0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) {
			return isOpenTag;
		}
		nameAndAttrs = splitWhitespace(tokens);
		name = (0 >= nameAndAttrs.$length ? ($throwRuntimeError("index out of range"), undefined) : nameAndAttrs.$array[nameAndAttrs.$offset + 0]);
		if (!isASCIILetter((0 >= name.$length ? ($throwRuntimeError("index out of range"), undefined) : name.$array[name.$offset + 0]))) {
			return isOpenTag;
		}
		if (1 < name.$length) {
			name = $subslice(name, 1);
			_ref = name;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (!isASCIILetterNumHyphen(n)) {
					return isOpenTag;
				}
				_i++;
			}
		}
		attrs = $subslice(nameAndAttrs, 1);
		_ref$1 = attrs;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			attr = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			if (1 >= attr.$length) {
				_i$1++;
				continue;
			}
			nameAndValue = split(attr, 61);
			name$1 = (0 >= nameAndValue.$length ? ($throwRuntimeError("index out of range"), undefined) : nameAndValue.$array[nameAndValue.$offset + 0]);
			if (1 > name$1.$length) {
				_i$1++;
				continue;
			}
			if (!isASCIILetter((0 >= name$1.$length ? ($throwRuntimeError("index out of range"), undefined) : name$1.$array[name$1.$offset + 0])) && !((95 === (0 >= name$1.$length ? ($throwRuntimeError("index out of range"), undefined) : name$1.$array[name$1.$offset + 0]))) && !((58 === (0 >= name$1.$length ? ($throwRuntimeError("index out of range"), undefined) : name$1.$array[name$1.$offset + 0])))) {
				return isOpenTag;
			}
			if (1 < name$1.$length) {
				name$1 = $subslice(name$1, 1);
				_ref$2 = name$1;
				_i$2 = 0;
				while (true) {
					if (!(_i$2 < _ref$2.$length)) { break; }
					n$1 = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
					if (!isASCIILetter(n$1) && !isDigit(n$1) && !((95 === n$1)) && !((46 === n$1)) && !((58 === n$1)) && !((45 === n$1))) {
						return isOpenTag;
					}
					_i$2++;
				}
			}
			if (1 < nameAndValue.$length) {
				value = (1 >= nameAndValue.$length ? ($throwRuntimeError("index out of range"), undefined) : nameAndValue.$array[nameAndValue.$offset + 1]);
				if (bytes.HasPrefix(value, htmlBlockSinglequote) && bytes.HasSuffix(value, htmlBlockSinglequote)) {
					value = $subslice(value, 1);
					value = $subslice(value, 0, (value.$length - 1 >> 0));
					isOpenTag = !bytes.Contains(value, htmlBlockSinglequote);
					return isOpenTag;
				}
				if (bytes.HasPrefix(value, htmlBlockDoublequote) && bytes.HasSuffix(value, htmlBlockDoublequote)) {
					value = $subslice(value, 1);
					value = $subslice(value, 0, (value.$length - 1 >> 0));
					isOpenTag = !bytes.Contains(value, htmlBlockDoublequote);
					return isOpenTag;
				}
				isOpenTag = !bytes.ContainsAny(value, " \t\n") && !bytes.ContainsAny(value, "\"'=<>`");
				return isOpenTag;
			}
			_i$1++;
		}
		isOpenTag = true;
		return isOpenTag;
	};
	Tree.prototype.isOpenTag = function(tokens) { return this.$val.isOpenTag(tokens); };
	Tree.ptr.prototype.isCloseTag = function(tokens) {
		var _i, _ref, length, n, name, t, tokens, x;
		t = this;
		tokens = trimWhitespace(tokens);
		length = tokens.$length;
		if (4 > length) {
			return false;
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((47 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1])))) {
			return false;
		}
		if (!((62 === (x = length - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))))) {
			return false;
		}
		tokens = $subslice(tokens, 2, (length - 1 >> 0));
		length = tokens.$length;
		if (0 === length) {
			return false;
		}
		name = $subslice(tokens, 0);
		if (!isASCIILetter((0 >= name.$length ? ($throwRuntimeError("index out of range"), undefined) : name.$array[name.$offset + 0]))) {
			return false;
		}
		if (1 < name.$length) {
			name = $subslice(name, 1);
			_ref = name;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (!isASCIILetterNumHyphen(n)) {
					return false;
				}
				_i++;
			}
		}
		return true;
	};
	Tree.prototype.isCloseTag = function(tokens) { return this.$val.isCloseTag(tokens); };
	Lute.ptr.prototype.newHTMLRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$35, _key$36, _key$37, _key$38, _key$39, _key$4, _key$40, _key$41, _key$42, _key$43, _key$44, _key$45, _key$46, _key$47, _key$48, _key$49, _key$5, _key$50, _key$51, _key$52, _key$53, _key$54, _key$55, _key$56, _key$57, _key$58, _key$59, _key$6, _key$7, _key$8, _key$9, lute, ret, tree;
		lute = this;
		ret = new HTMLRenderer.ptr(lute.newBaseRenderer(tree));
		_key = 0; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 28; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeSpanOpenMarker") };
		_key$5 = 29; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderCodeSpanContent") };
		_key$6 = 30; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderCodeSpanCloseMarker") };
		_key$7 = 11; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderCodeBlock") };
		_key$8 = 12; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderCodeBlockOpenMarker") };
		_key$9 = 14; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderCodeBlockInfoMarker") };
		_key$10 = 15; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderCodeBlockCode") };
		_key$11 = 13; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderCodeBlockCloseMarker") };
		_key$12 = 300; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderMathBlock") };
		_key$13 = 301; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderInlineMath") };
		_key$14 = 17; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderEmphasis") };
		_key$15 = 18; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderEmAsteriskOpenMarker") };
		_key$16 = 19; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderEmAsteriskCloseMarker") };
		_key$17 = 20; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderEmUnderscoreOpenMarker") };
		_key$18 = 21; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderEmUnderscoreCloseMarker") };
		_key$19 = 22; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderStrong") };
		_key$20 = 23; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderStrongA6kOpenMarker") };
		_key$21 = 24; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderStrongA6kCloseMarker") };
		_key$22 = 25; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderStrongU8eOpenMarker") };
		_key$23 = 26; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderStrongU8eCloseMarker") };
		_key$24 = 5; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderBlockquote") };
		_key$25 = 6; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderBlockquoteMarker") };
		_key$26 = 2; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderHeading") };
		_key$27 = 3; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderHeadingC8hMarker") };
		_key$28 = 7; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderList") };
		_key$29 = 8; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderListItem") };
		_key$30 = 4; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderThematicBreak") };
		_key$31 = 31; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderHardBreak") };
		_key$32 = 32; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderSoftBreak") };
		_key$33 = 9; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderHTML") };
		_key$34 = 10; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderInlineHTML") };
		_key$35 = 33; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$35)] = { k: _key$35, v: $methodVal(ret, "renderLink") };
		_key$36 = 34; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$36)] = { k: _key$36, v: $methodVal(ret, "renderImage") };
		_key$37 = 35; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$37)] = { k: _key$37, v: $methodVal(ret, "renderBang") };
		_key$38 = 36; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$38)] = { k: _key$38, v: $methodVal(ret, "renderOpenBracket") };
		_key$39 = 37; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$39)] = { k: _key$39, v: $methodVal(ret, "renderCloseBracket") };
		_key$40 = 38; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$40)] = { k: _key$40, v: $methodVal(ret, "renderOpenParen") };
		_key$41 = 39; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$41)] = { k: _key$41, v: $methodVal(ret, "renderCloseParen") };
		_key$42 = 40; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$42)] = { k: _key$42, v: $methodVal(ret, "renderLinkText") };
		_key$43 = 43; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$43)] = { k: _key$43, v: $methodVal(ret, "renderLinkSpace") };
		_key$44 = 41; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$44)] = { k: _key$44, v: $methodVal(ret, "renderLinkDest") };
		_key$45 = 42; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$45)] = { k: _key$45, v: $methodVal(ret, "renderLinkTitle") };
		_key$46 = 101; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$46)] = { k: _key$46, v: $methodVal(ret, "renderStrikethrough") };
		_key$47 = 102; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$47)] = { k: _key$47, v: $methodVal(ret, "renderStrikethrough1OpenMarker") };
		_key$48 = 103; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$48)] = { k: _key$48, v: $methodVal(ret, "renderStrikethrough1CloseMarker") };
		_key$49 = 104; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$49)] = { k: _key$49, v: $methodVal(ret, "renderStrikethrough2OpenMarker") };
		_key$50 = 105; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$50)] = { k: _key$50, v: $methodVal(ret, "renderStrikethrough2CloseMarker") };
		_key$51 = 100; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$51)] = { k: _key$51, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$52 = 106; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$52)] = { k: _key$52, v: $methodVal(ret, "renderTable") };
		_key$53 = 107; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$53)] = { k: _key$53, v: $methodVal(ret, "renderTableHead") };
		_key$54 = 108; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$54)] = { k: _key$54, v: $methodVal(ret, "renderTableRow") };
		_key$55 = 109; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$55)] = { k: _key$55, v: $methodVal(ret, "renderTableCell") };
		_key$56 = 200; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$56)] = { k: _key$56, v: $methodVal(ret, "renderEmoji") };
		_key$57 = 201; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$57)] = { k: _key$57, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$58 = 202; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$58)] = { k: _key$58, v: $methodVal(ret, "renderEmojiImg") };
		_key$59 = 203; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$59)] = { k: _key$59, v: $methodVal(ret, "renderEmojiAlias") };
		return ret;
	};
	Lute.prototype.newHTMLRenderer = function(tree) { return this.$val.newHTMLRenderer(tree); };
	HTMLRenderer.ptr.prototype.renderCodeBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeBlockCloseMarker = function(node, entering) { return this.$val.renderCodeBlockCloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderCodeBlockInfoMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeBlockInfoMarker = function(node, entering) { return this.$val.renderCodeBlockInfoMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderCodeBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeBlockOpenMarker = function(node, entering) { return this.$val.renderCodeBlockOpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	HTMLRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		attrs = new sliceType$6([new sliceType$5(["class", "vditor-math"])]);
		r.tag("span", attrs, false);
		r.BaseRenderer.write(escapeHTML(node.tokens));
		r.tag("/span", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	HTMLRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		r.BaseRenderer.newline();
		attrs = new sliceType$6([new sliceType$5(["class", "vditor-math"])]);
		r.tag("div", attrs, false);
		r.BaseRenderer.write(escapeHTML(node.tokens));
		r.tag("/div", sliceType$6.nil, false);
		r.BaseRenderer.newline();
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	HTMLRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var _1, attrs, entering, node, r, tag;
		r = this;
		tag = "td";
		if (107 === node.parent.parent.typ) {
			tag = "th";
		}
		if (entering) {
			attrs = sliceType$6.nil;
			_1 = node.tableCellAlign;
			if (_1 === (1)) {
				attrs = $append(attrs, new sliceType$5(["align", "left"]));
			} else if (_1 === (2)) {
				attrs = $append(attrs, new sliceType$5(["align", "center"]));
			} else if (_1 === (3)) {
				attrs = $append(attrs, new sliceType$5(["align", "right"]));
			}
			r.tag(tag, attrs, false);
		} else {
			r.tag("/" + tag, sliceType$6.nil, false);
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	HTMLRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("tr", sliceType$6.nil, false);
			r.BaseRenderer.newline();
		} else {
			r.tag("/tr", sliceType$6.nil, false);
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	HTMLRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("thead", sliceType$6.nil, false);
			r.BaseRenderer.newline();
		} else {
			r.tag("/thead", sliceType$6.nil, false);
			r.BaseRenderer.newline();
			if (!(ptrType.nil === node.next)) {
				r.tag("tbody", sliceType$6.nil, false);
			}
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	HTMLRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("table", sliceType$6.nil, false);
			r.BaseRenderer.newline();
		} else {
			if (!(ptrType.nil === node.firstChild.next)) {
				r.tag("/tbody", sliceType$6.nil, false);
			}
			r.BaseRenderer.newline();
			r.tag("/table", sliceType$6.nil, false);
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrikethrough1OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("del", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrikethrough1OpenMarker = function(node, entering) { return this.$val.renderStrikethrough1OpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrikethrough1CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/del", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrikethrough1CloseMarker = function(node, entering) { return this.$val.renderStrikethrough1CloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrikethrough2OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("del", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrikethrough2OpenMarker = function(node, entering) { return this.$val.renderStrikethrough2OpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrikethrough2CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/del", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrikethrough2CloseMarker = function(node, entering) { return this.$val.renderStrikethrough2CloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderLinkTitle = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderLinkTitle = function(node, entering) { return this.$val.renderLinkTitle(node, entering); };
	HTMLRenderer.ptr.prototype.renderLinkDest = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderLinkDest = function(node, entering) { return this.$val.renderLinkDest(node, entering); };
	HTMLRenderer.ptr.prototype.renderLinkSpace = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderLinkSpace = function(node, entering) { return this.$val.renderLinkSpace(node, entering); };
	HTMLRenderer.ptr.prototype.renderLinkText = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.write(escapeHTML(node.tokens));
		}
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderLinkText = function(node, entering) { return this.$val.renderLinkText(node, entering); };
	HTMLRenderer.ptr.prototype.renderCloseParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCloseParen = function(node, entering) { return this.$val.renderCloseParen(node, entering); };
	HTMLRenderer.ptr.prototype.renderOpenParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderOpenParen = function(node, entering) { return this.$val.renderOpenParen(node, entering); };
	HTMLRenderer.ptr.prototype.renderCloseBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCloseBracket = function(node, entering) { return this.$val.renderCloseBracket(node, entering); };
	HTMLRenderer.ptr.prototype.renderOpenBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderOpenBracket = function(node, entering) { return this.$val.renderOpenBracket(node, entering); };
	HTMLRenderer.ptr.prototype.renderBang = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderBang = function(node, entering) { return this.$val.renderBang(node, entering); };
	HTMLRenderer.ptr.prototype.renderImage = function(node, entering) {
		var entering, node, r, title;
		r = this;
		if (entering) {
			if (0 === r.BaseRenderer.disableTags) {
				r.BaseRenderer.writeString("<img src=\"");
				r.BaseRenderer.write(escapeHTML(node.ChildByType(41).tokens));
				r.BaseRenderer.writeString("\" alt=\"");
			}
			r.BaseRenderer.disableTags = r.BaseRenderer.disableTags + (1) >> 0;
			return [2, $ifaceNil];
		}
		r.BaseRenderer.disableTags = r.BaseRenderer.disableTags - (1) >> 0;
		if (0 === r.BaseRenderer.disableTags) {
			r.BaseRenderer.writeString("\"");
			title = node.ChildByType(42);
			if (!(ptrType.nil === title) && !(sliceType.nil === title.tokens)) {
				r.BaseRenderer.writeString(" title=\"");
				r.BaseRenderer.write(escapeHTML(title.tokens));
				r.BaseRenderer.writeString("\"");
			}
			r.BaseRenderer.writeString(" />");
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	HTMLRenderer.ptr.prototype.renderLink = function(node, entering) {
		var attrs, dest, entering, node, r, title;
		r = this;
		if (entering) {
			dest = node.ChildByType(41);
			attrs = new sliceType$6([new sliceType$5(["href", bytesToStr(escapeHTML(dest.tokens))])]);
			title = node.ChildByType(42);
			if (!(ptrType.nil === title) && !(sliceType.nil === title.tokens)) {
				attrs = $append(attrs, new sliceType$5(["title", bytesToStr(escapeHTML(title.tokens))]));
			}
			r.tag("a", attrs, false);
		} else {
			r.tag("/a", sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	HTMLRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.newline();
		r.BaseRenderer.write(node.tokens);
		r.BaseRenderer.newline();
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	HTMLRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	HTMLRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	HTMLRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, grandparent, node, r;
		r = this;
		grandparent = node.parent.parent;
		if (!(ptrType.nil === grandparent)) {
			if (7 === grandparent.typ) {
				if (grandparent.listData.tight) {
					return [2, $ifaceNil];
				}
			}
		}
		if (entering) {
			r.BaseRenderer.newline();
			r.tag("p", sliceType$6.nil, false);
		} else {
			r.tag("/p", sliceType$6.nil, false);
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	HTMLRenderer.ptr.prototype.renderText = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (r.BaseRenderer.option.AutoSpace) {
			r.BaseRenderer.space(node);
		}
		/* */ if (r.BaseRenderer.option.FixTermTypo) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.option.FixTermTypo) { */ case 1:
			$r = r.BaseRenderer.fixTermTypo(node); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		r.BaseRenderer.write(escapeHTML(node.tokens));
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: HTMLRenderer.ptr.prototype.renderText }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	HTMLRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	HTMLRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	HTMLRenderer.ptr.prototype.renderCodeSpanOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("<code>");
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeSpanOpenMarker = function(node, entering) { return this.$val.renderCodeSpanOpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderCodeSpanContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(escapeHTML(node.tokens));
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeSpanContent = function(node, entering) { return this.$val.renderCodeSpanContent(node, entering); };
	HTMLRenderer.ptr.prototype.renderCodeSpanCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("</code>");
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderCodeSpanCloseMarker = function(node, entering) { return this.$val.renderCodeSpanCloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmAsteriskOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmAsteriskOpenMarker = function(node, entering) { return this.$val.renderEmAsteriskOpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmAsteriskCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmAsteriskCloseMarker = function(node, entering) { return this.$val.renderEmAsteriskCloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmUnderscoreOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmUnderscoreOpenMarker = function(node, entering) { return this.$val.renderEmUnderscoreOpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderEmUnderscoreCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderEmUnderscoreCloseMarker = function(node, entering) { return this.$val.renderEmUnderscoreCloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrongA6kOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrongA6kOpenMarker = function(node, entering) { return this.$val.renderStrongA6kOpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrongA6kCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrongA6kCloseMarker = function(node, entering) { return this.$val.renderStrongA6kCloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrongU8eOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrongU8eOpenMarker = function(node, entering) { return this.$val.renderStrongU8eOpenMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderStrongU8eCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderStrongU8eCloseMarker = function(node, entering) { return this.$val.renderStrongU8eCloseMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.newline();
			r.BaseRenderer.writeString("<blockquote>");
			r.BaseRenderer.newline();
		} else {
			r.BaseRenderer.newline();
			r.BaseRenderer.writeString("</blockquote>");
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	HTMLRenderer.ptr.prototype.renderBlockquoteMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderBlockquoteMarker = function(node, entering) { return this.$val.renderBlockquoteMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var _r, anchor, entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; anchor = $f.anchor; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.newline();
			r.BaseRenderer.writeString("<h" + $substring(" 123456", node.headingLevel, (node.headingLevel + 1 >> 0)) + ">");
			/* */ if (r.BaseRenderer.option.HeadingAnchor) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (r.BaseRenderer.option.HeadingAnchor) { */ case 4:
				_r = node.Text(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				anchor = _r;
				anchor = strings.ReplaceAll(anchor, " ", "-");
				r.tag("a", new sliceType$6([new sliceType$5(["id", "vditorAnchor-" + anchor]), new sliceType$5(["class", "vditor-anchor"]), new sliceType$5(["href", "#" + anchor])]), false);
				r.BaseRenderer.writeString("<svg viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>");
				r.tag("/a", sliceType$6.nil, false);
			/* } */ case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.writeString("</h" + $substring(" 123456", node.headingLevel, (node.headingLevel + 1 >> 0)) + ">");
			r.BaseRenderer.newline();
		/* } */ case 3:
		$s = -1; return [2, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: HTMLRenderer.ptr.prototype.renderHeading }; } $f._r = _r; $f.anchor = anchor; $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	HTMLRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	HTMLRenderer.ptr.prototype.renderHeadingC8hMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderHeadingC8hMarker = function(node, entering) { return this.$val.renderHeadingC8hMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderList = function(node, entering) {
		var attrs, entering, node, r, tag;
		r = this;
		tag = "ul";
		if (1 === node.listData.typ) {
			tag = "ol";
		}
		if (entering) {
			r.BaseRenderer.newline();
			attrs = new sliceType$6([new sliceType$5(["start", strconv.Itoa(node.listData.start)])]);
			if (sliceType.nil === node.listData.bulletChar && !((1 === node.listData.start))) {
				r.tag(tag, attrs, false);
			} else {
				r.tag(tag, sliceType$6.nil, false);
			}
			r.BaseRenderer.newline();
		} else {
			r.BaseRenderer.newline();
			r.tag("/" + tag, sliceType$6.nil, false);
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	HTMLRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			if ((3 === node.listData.typ) && !("" === r.BaseRenderer.option.GFMTaskListItemClass)) {
				r.tag("li", new sliceType$6([new sliceType$5(["class", r.BaseRenderer.option.GFMTaskListItemClass])]), false);
			} else {
				r.tag("li", sliceType$6.nil, false);
			}
		} else {
			r.tag("/li", sliceType$6.nil, false);
			r.BaseRenderer.newline();
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	HTMLRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		if (entering) {
			attrs = sliceType$6.nil;
			if (node.taskListItemChecked) {
				attrs = $append(attrs, new sliceType$5(["checked", ""]));
			}
			attrs = $append(attrs, new sliceType$5(["disabled", ""]), new sliceType$5(["type", "checkbox"]));
			r.tag("input", attrs, true);
		}
		return [2, $ifaceNil];
	};
	HTMLRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	HTMLRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.newline();
		r.tag("hr", sliceType$6.nil, true);
		r.BaseRenderer.newline();
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	HTMLRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("br", sliceType$6.nil, true);
			r.BaseRenderer.newline();
		}
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	HTMLRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (r.BaseRenderer.option.SoftBreak2HardBreak) {
			r.tag("br", sliceType$6.nil, true);
			r.BaseRenderer.newline();
		} else {
			r.BaseRenderer.newline();
		}
		return [0, $ifaceNil];
	};
	HTMLRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	HTMLRenderer.ptr.prototype.tag = function(name, attrs, selfclosing) {
		var _i, _ref, attr, attrs, name, r, selfclosing;
		r = this;
		if (r.BaseRenderer.disableTags > 0) {
			return;
		}
		r.BaseRenderer.writeString("<");
		r.BaseRenderer.writeString(name);
		if (0 < attrs.$length) {
			_ref = attrs;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				attr = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				r.BaseRenderer.writeString(" " + (0 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 0]) + "=\"" + (1 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 1]) + "\"");
				_i++;
			}
		}
		if (selfclosing) {
			r.BaseRenderer.writeString(" /");
		}
		r.BaseRenderer.writeString(">");
	};
	HTMLRenderer.prototype.tag = function(name, attrs, selfclosing) { return this.$val.tag(name, attrs, selfclosing); };
	Tree.ptr.prototype.parseBang = function(ctx) {
		var ctx, ret, startPos, t, x, x$1;
		ret = ptrType.nil;
		t = this;
		startPos = ctx.pos;
		ctx.pos = ctx.pos + (1) >> 0;
		if (ctx.pos < ctx.tokensLen && (91 === (x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])))) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(ctx.tokens, startPos, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			t.addBracket(ret, startPos + 2 >> 0, true, ctx);
			return ret;
		}
		ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(ctx.tokens, startPos, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		return ret;
	};
	Tree.prototype.parseBang = function(ctx) { return this.$val.parseBang(ctx); };
	Tree.ptr.prototype.parseInline = function(block, ctx) {
		var _1, _r, block, ctx, n, t, token, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; block = $f.block; ctx = $f.ctx; n = $f.n; t = $f.t; token = $f.token; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		/* while (true) { */ case 1:
			/* if (!(ctx.pos < ctx.tokensLen)) { break; } */ if(!(ctx.pos < ctx.tokensLen)) { $s = 2; continue; }
			token = (x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			n = ptrType.nil;
				_1 = token;
				/* */ if (_1 === (92)) { $s = 4; continue; }
				/* */ if (_1 === (96)) { $s = 5; continue; }
				/* */ if ((_1 === (42)) || (_1 === (95)) || (_1 === (126))) { $s = 6; continue; }
				/* */ if (_1 === (10)) { $s = 7; continue; }
				/* */ if (_1 === (60)) { $s = 8; continue; }
				/* */ if (_1 === (91)) { $s = 9; continue; }
				/* */ if (_1 === (93)) { $s = 10; continue; }
				/* */ if (_1 === (38)) { $s = 11; continue; }
				/* */ if (_1 === (33)) { $s = 12; continue; }
				/* */ if (_1 === (36)) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (_1 === (92)) { */ case 4:
					n = t.parseBackslash(ctx);
					$s = 15; continue;
				/* } else if (_1 === (96)) { */ case 5:
					n = t.parseCodeSpan(ctx);
					$s = 15; continue;
				/* } else if ((_1 === (42)) || (_1 === (95)) || (_1 === (126))) { */ case 6:
					t.handleDelim(block, ctx);
					$s = 15; continue;
				/* } else if (_1 === (10)) { */ case 7:
					n = t.parseNewline(block, ctx);
					$s = 15; continue;
				/* } else if (_1 === (60)) { */ case 8:
					n = t.parseAutolink(ctx);
					if (ptrType.nil === n) {
						n = t.parseAutoEmailLink(ctx);
						if (ptrType.nil === n) {
							n = t.parseInlineHTML(ctx);
						}
					}
					$s = 15; continue;
				/* } else if (_1 === (91)) { */ case 9:
					n = t.parseOpenBracket(ctx);
					$s = 15; continue;
				/* } else if (_1 === (93)) { */ case 10:
					_r = t.parseCloseBracket(ctx); /* */ $s = 16; case 16: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					n = _r;
					$s = 15; continue;
				/* } else if (_1 === (38)) { */ case 11:
					n = t.parseEntity(ctx);
					$s = 15; continue;
				/* } else if (_1 === (33)) { */ case 12:
					n = t.parseBang(ctx);
					$s = 15; continue;
				/* } else if (_1 === (36)) { */ case 13:
					n = t.parseInlineMath(ctx);
					$s = 15; continue;
				/* } else { */ case 14:
					n = t.parseText(ctx);
				/* } */ case 15:
			case 3:
			if (!(ptrType.nil === n)) {
				block.AppendChild(n);
			}
		/* } */ $s = 1; continue; case 2:
		block.tokens = sliceType.nil;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseInline }; } $f._1 = _1; $f._r = _r; $f.block = block; $f.ctx = ctx; $f.n = n; $f.t = t; $f.token = token; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseInline = function(block, ctx) { return this.$val.parseInline(block, ctx); };
	Tree.ptr.prototype.parseEntity = function(ctx) {
		var _entry, _tuple, and, ctx, endWithSemicolon, entityName, entityNameLen, entityValue, hex, i, numeric, ok, ret, start, t, token, v, x, x$1, x$2, x$3, x$4;
		ret = ptrType.nil;
		t = this;
		and = new sliceType([(x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))]);
		if (2 > ctx.tokensLen || ctx.tokensLen <= (ctx.pos + 1 >> 0)) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		start = ctx.pos;
		numeric = false;
		if (3 < ctx.tokensLen) {
			numeric = 35 === (x$2 = ctx.tokens, x$3 = start + 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
		}
		i = ctx.pos;
		token = 0;
		endWithSemicolon = false;
		while (true) {
			if (!(i < ctx.tokensLen)) { break; }
			token = (x$4 = ctx.tokens, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i]));
			if (isWhitespace(token)) {
				break;
			}
			if (59 === token) {
				i = i + (1) >> 0;
				endWithSemicolon = true;
				break;
			}
			i = i + (1) >> 0;
		}
		entityName = bytesToStr($subslice(ctx.tokens, start, i));
		_tuple = (_entry = html.Entities[$String.keyFor(entityName)], _entry !== undefined ? [_entry.v, true] : ["", false]);
		entityValue = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			ctx.pos = ctx.pos + ((i - start >> 0)) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(entityValue), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		if (!endWithSemicolon) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		if (numeric) {
			entityNameLen = entityName.length;
			if (10 < entityNameLen || 4 > entityNameLen) {
				ctx.pos = ctx.pos + (1) >> 0;
				ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				return ret;
			}
			hex = (120 === entityName.charCodeAt(2)) || (88 === entityName.charCodeAt(2));
			if (hex) {
				if (5 > entityNameLen) {
					ctx.pos = ctx.pos + (1) >> 0;
					ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
					return ret;
				}
			}
		}
		v = htmlUnescapeString(entityName);
		if (v === entityName) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		ctx.pos = ctx.pos + ((i - start >> 0)) >> 0;
		ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(v), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		return ret;
	};
	Tree.prototype.parseEntity = function(ctx) { return this.$val.parseEntity(ctx); };
	Tree.ptr.prototype.parseCloseBracket = function(ctx) {
		var _entry, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, beforelabel, closeBracket, closeParen, ctx, dest, isImage, isLink, label, link, matched, n, next, node, openParen, opener, passed, reflabel, remains, savepos, space, start, startPos, t, title, titleNode, tmp, validTitle, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; beforelabel = $f.beforelabel; closeBracket = $f.closeBracket; closeParen = $f.closeParen; ctx = $f.ctx; dest = $f.dest; isImage = $f.isImage; isLink = $f.isLink; label = $f.label; link = $f.link; matched = $f.matched; n = $f.n; next = $f.next; node = $f.node; openParen = $f.openParen; opener = $f.opener; passed = $f.passed; reflabel = $f.reflabel; remains = $f.remains; savepos = $f.savepos; space = $f.space; start = $f.start; startPos = $f.startPos; t = $f.t; title = $f.title; titleNode = $f.titleNode; tmp = $f.tmp; validTitle = $f.validTitle; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		closeBracket = new sliceType([(x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))]);
		ctx.pos = ctx.pos + (1) >> 0;
		startPos = ctx.pos;
		opener = ctx.brackets;
		if (ptrType$2.nil === opener) {
			$s = -1; return new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		}
		if (!opener.active) {
			t.removeBracket(ctx);
			$s = -1; return new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		}
		isImage = opener.image;
		_tmp = sliceType.nil;
		_tmp$1 = sliceType.nil;
		_tmp$2 = sliceType.nil;
		_tmp$3 = sliceType.nil;
		_tmp$4 = sliceType.nil;
		openParen = _tmp;
		dest = _tmp$1;
		space = _tmp$2;
		title = _tmp$3;
		closeParen = _tmp$4;
		savepos = ctx.pos;
		matched = false;
		if ((ctx.pos + 1 >> 0) < ctx.tokensLen && (40 === (x$2 = ctx.tokens, x$3 = ctx.pos, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])))) {
			ctx.pos = ctx.pos + (1) >> 0;
			isLink = false;
			_tmp$5 = sliceType.nil;
			_tmp$6 = sliceType.nil;
			passed = _tmp$5;
			remains = _tmp$6;
			while (true) {
				_tuple = spnl($subslice(ctx.tokens, (ctx.pos - 1 >> 0)));
				isLink = _tuple[0];
				passed = _tuple[1];
				remains = _tuple[2];
				if (!isLink) {
					break;
				}
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				_tuple$1 = t.context.parseInlineLinkDest(remains);
				passed = _tuple$1[0];
				remains = _tuple$1[1];
				dest = _tuple$1[2];
				if (sliceType.nil === passed) {
					break;
				}
				if (t.context.option.VditorWYSIWYG && (1 > dest.$length || ptrType.nil === opener.node.next)) {
					break;
				}
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				openParen = $subslice(passed, 0, 1);
				closeParen = $subslice(passed, (passed.$length - 1 >> 0));
				matched = 41 === (x$4 = passed.$length - 1 >> 0, ((x$4 < 0 || x$4 >= passed.$length) ? ($throwRuntimeError("index out of range"), undefined) : passed.$array[passed.$offset + x$4]));
				if (matched) {
					ctx.pos = ctx.pos - (1) >> 0;
					break;
				}
				if (1 > remains.$length || !isWhitespace((0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0]))) {
					break;
				}
				_tuple$2 = spnl(remains);
				isLink = _tuple$2[0];
				passed = _tuple$2[1];
				remains = _tuple$2[2];
				if (!isLink) {
					break;
				}
				space = passed;
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				matched = 41 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0]);
				closeParen = $subslice(remains, 0, 1);
				if (matched) {
					break;
				}
				ctx.pos = ctx.pos + (1) >> 0;
				validTitle = false;
				_tuple$3 = t.context.parseLinkTitle(remains);
				validTitle = _tuple$3[0];
				passed = _tuple$3[1];
				remains = _tuple$3[2];
				title = _tuple$3[3];
				if (!validTitle) {
					break;
				}
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				_tuple$4 = spnl(remains);
				isLink = _tuple$4[0];
				passed = _tuple$4[1];
				remains = _tuple$4[2];
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				matched = isLink && 0 < remains.$length && (41 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0]));
				closeParen = $subslice(remains, 0);
				break;
			}
			if (!matched) {
				ctx.pos = savepos;
			}
		}
		reflabel = sliceType.nil;
		/* */ if (!matched) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!matched) { */ case 1:
			beforelabel = ctx.pos;
			_tuple$5 = t.context.parseLinkLabel($subslice(ctx.tokens, beforelabel));
			n = _tuple$5[0];
			label = _tuple$5[2];
			if (2 < n) {
				reflabel = label;
				ctx.pos = ctx.pos + (n) >> 0;
			} else if (!opener.bracketAfter) {
				start = opener.index;
				if (91 === (x$5 = ctx.tokens, ((start < 0 || start >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + start]))) {
					start = start + (1) >> 0;
				}
				reflabel = $subslice(ctx.tokens, start, (startPos - 1 >> 0));
				ctx.pos = ctx.pos + (reflabel.$length) >> 0;
			}
			if (0 === n) {
				ctx.pos = startPos;
			}
			/* */ if (!(sliceType.nil === reflabel)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(sliceType.nil === reflabel)) { */ case 3:
				_r = strings.ToLower(bytesToStr(reflabel)); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				link = (_entry = t.context.linkRefDef[$String.keyFor(_r)], _entry !== undefined ? _entry.v : ptrType.nil);
				if (!(ptrType.nil === link)) {
					dest = link.ChildByType(41).tokens;
					titleNode = link.ChildByType(42);
					if (!(ptrType.nil === titleNode)) {
						title = titleNode.tokens;
					}
					matched = true;
				}
			/* } */ case 4:
		/* } */ case 2:
		if (matched) {
			node = new Node.ptr(33, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			if (isImage) {
				node.typ = 34;
				node.AppendChild(new Node.ptr(35, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(opener.node.tokens, 0, 1), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				opener.node.tokens = $subslice(opener.node.tokens, 1);
			}
			node.AppendChild(new Node.ptr(36, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", opener.node.tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			_tmp$7 = ptrType.nil;
			_tmp$8 = ptrType.nil;
			tmp = _tmp$7;
			next = _tmp$8;
			tmp = opener.node.next;
			while (true) {
				if (!(!(ptrType.nil === tmp))) { break; }
				next = tmp.next;
				tmp.Unlink();
				if (16 === tmp.typ) {
					tmp.typ = 40;
				}
				node.AppendChild(tmp);
				tmp = next;
			}
			node.AppendChild(new Node.ptr(37, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			node.AppendChild(new Node.ptr(38, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", openParen, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			node.AppendChild(new Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", dest, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			if (!(sliceType.nil === space)) {
				node.AppendChild(new Node.ptr(43, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", space, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
			if (0 < title.$length) {
				node.AppendChild(new Node.ptr(42, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", title, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
			node.AppendChild(new Node.ptr(39, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", closeParen, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			t.processEmphasis(opener.previousDelimiter, ctx);
			t.removeBracket(ctx);
			opener.node.Unlink();
			if (!isImage) {
				opener = ctx.brackets;
				while (true) {
					if (!(!(ptrType$2.nil === opener))) { break; }
					if (!opener.image) {
						opener.active = false;
					}
					opener = opener.previous;
				}
			}
			$s = -1; return node;
		} else {
			t.removeBracket(ctx);
			ctx.pos = startPos;
			$s = -1; return new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		}
		$s = -1; return ptrType.nil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseCloseBracket }; } $f._entry = _entry; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.beforelabel = beforelabel; $f.closeBracket = closeBracket; $f.closeParen = closeParen; $f.ctx = ctx; $f.dest = dest; $f.isImage = isImage; $f.isLink = isLink; $f.label = label; $f.link = link; $f.matched = matched; $f.n = n; $f.next = next; $f.node = node; $f.openParen = openParen; $f.opener = opener; $f.passed = passed; $f.reflabel = reflabel; $f.remains = remains; $f.savepos = savepos; $f.space = space; $f.start = start; $f.startPos = startPos; $f.t = t; $f.title = title; $f.titleNode = titleNode; $f.tmp = tmp; $f.validTitle = validTitle; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseCloseBracket = function(ctx) { return this.$val.parseCloseBracket(ctx); };
	Tree.ptr.prototype.parseOpenBracket = function(ctx) {
		var ctx, ret, startPos, t;
		ret = ptrType.nil;
		t = this;
		startPos = ctx.pos;
		ctx.pos = ctx.pos + (1) >> 0;
		ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(ctx.tokens, startPos, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		t.addBracket(ret, ctx.pos - 1 >> 0, false, ctx);
		return ret;
	};
	Tree.prototype.parseOpenBracket = function(ctx) { return this.$val.parseOpenBracket(ctx); };
	Tree.ptr.prototype.addBracket = function(node, index, image, ctx) {
		var ctx, image, index, node, t;
		t = this;
		if (!(ptrType$2.nil === ctx.brackets)) {
			ctx.brackets.bracketAfter = true;
		}
		ctx.brackets = new delimiter.ptr(node, 0, 0, 0, false, false, ctx.brackets, ptrType$2.nil, true, image, false, index, ctx.delimiters);
	};
	Tree.prototype.addBracket = function(node, index, image, ctx) { return this.$val.addBracket(node, index, image, ctx); };
	Tree.ptr.prototype.removeBracket = function(ctx) {
		var ctx, t;
		t = this;
		ctx.brackets = ctx.brackets.previous;
	};
	Tree.prototype.removeBracket = function(ctx) { return this.$val.removeBracket(ctx); };
	Tree.ptr.prototype.parseBackslash = function(ctx) {
		var ctx, t, token, x, x$1;
		t = this;
		if (ctx.pos === (ctx.tokensLen - 1 >> 0)) {
			ctx.pos = ctx.pos + (1) >> 0;
			return new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", backslash, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		}
		ctx.pos = ctx.pos + (1) >> 0;
		token = (x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (10 === token) {
			ctx.pos = ctx.pos + (1) >> 0;
			return new Node.ptr(31, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", new sliceType([token]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		}
		if (isASCIIPunct(token)) {
			ctx.pos = ctx.pos + (1) >> 0;
			return new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", new sliceType([token]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		}
		return new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", backslash, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
	};
	Tree.prototype.parseBackslash = function(ctx) { return this.$val.parseBackslash(ctx); };
	Tree.ptr.prototype.parseText = function(ctx) {
		var ctx, ret, start, t, x, x$1;
		ret = ptrType.nil;
		t = this;
		start = ctx.pos;
		while (true) {
			if (!(ctx.pos < ctx.tokensLen)) { break; }
			if (t.isMarker((x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])))) {
				break;
			}
			ctx.pos = ctx.pos + (1) >> 0;
		}
		ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(ctx.tokens, start, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		return ret;
	};
	Tree.prototype.parseText = function(ctx) { return this.$val.parseText(ctx); };
	Tree.ptr.prototype.isMarker = function(token) {
		var _1, t, token;
		t = this;
		_1 = token;
		if ((_1 === (42)) || (_1 === (95)) || (_1 === (91)) || (_1 === (33)) || (_1 === (10)) || (_1 === (92)) || (_1 === (96)) || (_1 === (60)) || (_1 === (93)) || (_1 === (38)) || (_1 === (126)) || (_1 === (36))) {
			return true;
		} else {
			return false;
		}
	};
	Tree.prototype.isMarker = function(token) { return this.$val.isMarker(token); };
	Tree.ptr.prototype.parseNewline = function(block, ctx) {
		var _tuple, block, ctx, hardbreak, lastc, pos, ret, t, tokens, valueLen, x, x$1, x$2;
		ret = ptrType.nil;
		t = this;
		pos = ctx.pos;
		ctx.pos = ctx.pos + (1) >> 0;
		hardbreak = false;
		lastc = block.lastChild;
		if (!(ptrType.nil === lastc)) {
			if (16 === lastc.typ) {
				tokens = lastc.tokens;
				valueLen = tokens.$length;
				if (32 === (x = valueLen - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) {
					_tuple = trimRight(tokens);
					lastc.tokens = _tuple[1];
					if (1 < valueLen) {
						hardbreak = 32 === (x$1 = tokens.$length - 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]));
					}
				}
			}
		}
		ret = new Node.ptr(32, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", new sliceType([(x$2 = ctx.tokens, ((pos < 0 || pos >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pos]))]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		if (hardbreak) {
			ret.typ = 31;
		}
		return ret;
	};
	Tree.prototype.parseNewline = function(block, ctx) { return this.$val.parseNewline(block, ctx); };
	Tree.ptr.prototype.parseInlineHTML = function(ctx) {
		var _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, attr, cdata, comment, ctx, decl, ins, length, remains, remains$1, remains$2, remains$3, remains$4, remains$5, remains$6, ret, startPos, t, tagName, tagName$1, tags, tokens, valid, valid$1, valid$2, valid$3, valid$4, whitespaces, x, x$1, x$2;
		ret = ptrType.nil;
		t = this;
		tokens = ctx.tokens;
		startPos = ctx.pos;
		ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", new sliceType([(x = ctx.pos, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		if (3 > ctx.tokensLen || ctx.tokensLen <= (startPos + 1 >> 0)) {
			ctx.pos = ctx.pos + (1) >> 0;
			return ret;
		}
		tags = sliceType.nil;
		tags = $append(tags, ((startPos < 0 || startPos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + startPos]));
		if (47 === (x$1 = startPos + 1 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]))) {
			tags = $append(tags, (x$2 = startPos + 1 >> 0, ((x$2 < 0 || x$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$2])));
			_tuple = t.parseTagName($subslice(tokens, (ctx.pos + 2 >> 0)));
			remains = _tuple[0];
			tagName = _tuple[1];
			if (1 > tagName.$length) {
				ctx.pos = ctx.pos + (1) >> 0;
				return ret;
			}
			tags = $appendSlice(tags, tagName);
			tokens = remains;
		} else {
			_tuple$1 = t.parseTagName($subslice(tokens, (ctx.pos + 1 >> 0)));
			remains$1 = _tuple$1[0];
			tagName$1 = _tuple$1[1];
			if (0 < tagName$1.$length) {
				tags = $appendSlice(tags, tagName$1);
				tokens = remains$1;
				while (true) {
					_tuple$2 = t.parseTagAttr(tokens);
					valid = _tuple$2[0];
					remains$2 = _tuple$2[1];
					attr = _tuple$2[2];
					if (!valid) {
						ctx.pos = ctx.pos + (1) >> 0;
						return ret;
					}
					tokens = remains$2;
					tags = $appendSlice(tags, attr);
					if (1 > attr.$length) {
						break;
					}
				}
			} else {
				_tuple$3 = t.parseHTMLComment($subslice(tokens, (ctx.pos + 1 >> 0)));
				valid$1 = _tuple$3[0];
				remains$3 = _tuple$3[1];
				comment = _tuple$3[2];
				if (valid$1) {
					tags = $appendSlice(tags, comment);
					tokens = remains$3;
					ctx.pos = ctx.pos + (tags.$length) >> 0;
					ret = new Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
					return ret;
				} else {
					_tuple$4 = t.parseProcessingInstruction($subslice(tokens, (ctx.pos + 1 >> 0)));
					valid$2 = _tuple$4[0];
					remains$4 = _tuple$4[1];
					ins = _tuple$4[2];
					if (valid$2) {
						tags = $appendSlice(tags, ins);
						tokens = remains$4;
						ctx.pos = ctx.pos + (tags.$length) >> 0;
						ret = new Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
						return ret;
					} else {
						_tuple$5 = t.parseDeclaration($subslice(tokens, (ctx.pos + 1 >> 0)));
						valid$3 = _tuple$5[0];
						remains$5 = _tuple$5[1];
						decl = _tuple$5[2];
						if (valid$3) {
							tags = $appendSlice(tags, decl);
							tokens = remains$5;
							ctx.pos = ctx.pos + (tags.$length) >> 0;
							ret = new Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
							return ret;
						} else {
							_tuple$6 = t.parseCDATA($subslice(tokens, (ctx.pos + 1 >> 0)));
							valid$4 = _tuple$6[0];
							remains$6 = _tuple$6[1];
							cdata = _tuple$6[2];
							if (valid$4) {
								tags = $appendSlice(tags, cdata);
								tokens = remains$6;
								ctx.pos = ctx.pos + (tags.$length) >> 0;
								ret = new Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
								return ret;
							} else {
								ctx.pos = ctx.pos + (1) >> 0;
								return ret;
							}
						}
					}
				}
			}
		}
		length = tokens.$length;
		if (1 > length) {
			ctx.pos = startPos + 1 >> 0;
			return ret;
		}
		_tuple$7 = trimLeft(tokens);
		whitespaces = _tuple$7[0];
		tokens = _tuple$7[1];
		if (((62 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || (1 < ctx.tokensLen && (47 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) && (62 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1])))) {
			tags = $appendSlice(tags, whitespaces);
			tags = $append(tags, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
			if (47 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) {
				tags = $append(tags, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
			}
			ctx.pos = ctx.pos + (tags.$length) >> 0;
			ret = new Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		ctx.pos = startPos + 1 >> 0;
		return ret;
	};
	Tree.prototype.parseInlineHTML = function(ctx) { return this.$val.parseInlineHTML(ctx); };
	Tree.ptr.prototype.parseCDATA = function(tokens) {
		var content, i, length, remains, t, token, tokens, valid, x, x$1;
		valid = false;
		remains = sliceType.nil;
		content = sliceType.nil;
		t = this;
		remains = tokens;
		if (!((33 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		if (!((91 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1])))) {
			return [valid, remains, content];
		}
		if (!((67 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]))) || !((68 === (3 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 3]))) || !((65 === (4 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 4]))) || !((84 === (5 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 5]))) || !((65 === (6 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 6])))) {
			return [valid, remains, content];
		}
		if (!((91 === (7 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 7])))) {
			return [valid, remains, content];
		}
		content = $appendSlice(content, $subslice(tokens, 0, 7));
		tokens = $subslice(tokens, 7);
		token = 0;
		i = 0;
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			content = $append(content, token);
			if (i <= (length - 3 >> 0) && (93 === token) && (93 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) && (62 === (x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1])))) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (!((93 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((93 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) || !((62 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2])))) {
			return [valid, remains, content];
		}
		content = $append(content, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]), (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]));
		valid = true;
		remains = $subslice(tokens, 3);
		return [valid, remains, content];
	};
	Tree.prototype.parseCDATA = function(tokens) { return this.$val.parseCDATA(tokens); };
	Tree.ptr.prototype.parseDeclaration = function(tokens) {
		var _i, _ref, content, i, length, remains, t, token, tokens, valid;
		valid = false;
		remains = sliceType.nil;
		content = sliceType.nil;
		t = this;
		remains = tokens;
		if (!((33 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		token = 0;
		i = 0;
		_ref = $subslice(tokens, 1);
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (isWhitespace(token)) {
				break;
			}
			if (!(65 <= token && 90 >= token)) {
				return [valid, remains, content];
			}
			_i++;
		}
		content = $append(content, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]), (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
		tokens = $subslice(tokens, 2);
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			content = $append(content, token);
			if (62 === token) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (!((62 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		valid = true;
		remains = $subslice(tokens, 1);
		return [valid, remains, content];
	};
	Tree.prototype.parseDeclaration = function(tokens) { return this.$val.parseDeclaration(tokens); };
	Tree.ptr.prototype.parseProcessingInstruction = function(tokens) {
		var content, i, length, remains, t, token, tokens, valid, x;
		valid = false;
		remains = sliceType.nil;
		content = sliceType.nil;
		t = this;
		remains = tokens;
		if (!((63 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		content = $append(content, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
		tokens = $subslice(tokens, 1);
		token = 0;
		i = 0;
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			content = $append(content, token);
			if (i <= (length - 2 >> 0) && (63 === token) && (62 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (1 > tokens.$length) {
			return [valid, remains, content];
		}
		if (!((63 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((62 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1])))) {
			return [valid, remains, content];
		}
		content = $append(content, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
		valid = true;
		remains = $subslice(tokens, 2);
		return [valid, remains, content];
	};
	Tree.prototype.parseProcessingInstruction = function(tokens) { return this.$val.parseProcessingInstruction(tokens); };
	Tree.ptr.prototype.parseHTMLComment = function(tokens) {
		var comment, i, length, remains, t, token, tokens, valid, x, x$1, x$2;
		valid = false;
		remains = sliceType.nil;
		comment = sliceType.nil;
		t = this;
		remains = tokens;
		if (!((33 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((45 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) || !((45 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2])))) {
			return [valid, remains, comment];
		}
		comment = $append(comment, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]), (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]), (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]));
		tokens = $subslice(tokens, 3);
		if (62 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) {
			return [valid, remains, comment];
		}
		if ((45 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) && (62 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) {
			return [valid, remains, comment];
		}
		token = 0;
		i = 0;
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			comment = $append(comment, token);
			if (i <= (length - 2 >> 0) && (45 === token) && (45 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
				break;
			}
			if (i <= (length - 3 >> 0) && (45 === token) && (45 === (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]))) && (62 === (x$2 = i + 2 >> 0, ((x$2 < 0 || x$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$2])))) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (!((45 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((45 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) || !((62 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2])))) {
			return [valid, remains, comment];
		}
		comment = $append(comment, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]), (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]));
		valid = true;
		remains = $subslice(tokens, 3);
		return [valid, remains, comment];
	};
	Tree.prototype.parseHTMLComment = function(tokens) { return this.$val.parseHTMLComment(tokens); };
	Tree.ptr.prototype.parseTagAttr = function(tokens) {
		var _i, _ref, _tuple, _tuple$1, attr, attrName, i, remains, t, token, tokens, valSpec, valid, whitespaces;
		valid = false;
		remains = sliceType.nil;
		attr = sliceType.nil;
		t = this;
		valid = true;
		remains = tokens;
		whitespaces = sliceType.nil;
		i = 0;
		token = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!isWhitespace(token)) {
				break;
			}
			whitespaces = $append(whitespaces, token);
			_i++;
		}
		if (1 > whitespaces.$length) {
			return [valid, remains, attr];
		}
		tokens = $subslice(tokens, i);
		attrName = sliceType.nil;
		_tuple = t.parseAttrName(tokens);
		tokens = _tuple[0];
		attrName = _tuple[1];
		if (1 > attrName.$length) {
			return [valid, remains, attr];
		}
		valSpec = sliceType.nil;
		_tuple$1 = t.parseAttrValSpec(tokens);
		valid = _tuple$1[0];
		tokens = _tuple$1[1];
		valSpec = _tuple$1[2];
		if (!valid) {
			return [valid, remains, attr];
		}
		remains = tokens;
		attr = $appendSlice(attr, whitespaces);
		attr = $appendSlice(attr, attrName);
		attr = $appendSlice(attr, valSpec);
		return [valid, remains, attr];
	};
	Tree.prototype.parseTagAttr = function(tokens) { return this.$val.parseTagAttr(tokens); };
	Tree.ptr.prototype.parseAttrValSpec = function(tokens) {
		var _i, _i$1, _i$2, _i$3, _i$4, _ref, _ref$1, _ref$2, _ref$3, _ref$4, closed, i, remains, t, token, tokens, valSpec, valid;
		valid = false;
		remains = sliceType.nil;
		valSpec = sliceType.nil;
		t = this;
		valid = true;
		remains = tokens;
		i = 0;
		token = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!isWhitespace(token)) {
				break;
			}
			valSpec = $append(valSpec, token);
			_i++;
		}
		if (!((61 === token))) {
			valSpec = sliceType.nil;
			return [valid, remains, valSpec];
		}
		valSpec = $append(valSpec, token);
		tokens = $subslice(tokens, (i + 1 >> 0));
		_ref$1 = tokens;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i = _i$1;
			token = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			if (!isWhitespace(token)) {
				break;
			}
			valSpec = $append(valSpec, token);
			_i$1++;
		}
		token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
		valSpec = $append(valSpec, token);
		tokens = $subslice(tokens, (i + 1 >> 0));
		closed = false;
		if (34 === token) {
			_ref$2 = tokens;
			_i$2 = 0;
			while (true) {
				if (!(_i$2 < _ref$2.$length)) { break; }
				i = _i$2;
				token = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
				valSpec = $append(valSpec, token);
				if (34 === token) {
					closed = true;
					break;
				}
				_i$2++;
			}
		} else if (39 === token) {
			_ref$3 = tokens;
			_i$3 = 0;
			while (true) {
				if (!(_i$3 < _ref$3.$length)) { break; }
				i = _i$3;
				token = ((_i$3 < 0 || _i$3 >= _ref$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$3.$array[_ref$3.$offset + _i$3]);
				valSpec = $append(valSpec, token);
				if (39 === token) {
					closed = true;
					break;
				}
				_i$3++;
			}
		} else {
			_ref$4 = tokens;
			_i$4 = 0;
			while (true) {
				if (!(_i$4 < _ref$4.$length)) { break; }
				i = _i$4;
				token = ((_i$4 < 0 || _i$4 >= _ref$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$4.$array[_ref$4.$offset + _i$4]);
				if (62 === token) {
					i = i - (1) >> 0;
					break;
				}
				valSpec = $append(valSpec, token);
				if (isWhitespace(token)) {
					break;
				}
				if ((34 === token) || (39 === token) || (61 === token) || (60 === token) || (62 === token) || (96 === token)) {
					closed = false;
					break;
				}
				closed = true;
				_i$4++;
			}
		}
		if (!closed) {
			valid = false;
			valSpec = sliceType.nil;
			return [valid, remains, valSpec];
		}
		remains = $subslice(tokens, (i + 1 >> 0));
		return [valid, remains, valSpec];
	};
	Tree.prototype.parseAttrValSpec = function(tokens) { return this.$val.parseAttrValSpec(tokens); };
	Tree.ptr.prototype.parseAttrName = function(tokens) {
		var _i, _ref, attrName, i, remains, t, token, tokens;
		remains = sliceType.nil;
		attrName = sliceType.nil;
		t = this;
		remains = tokens;
		if (!isASCIILetter((0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) && !((95 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) && !((58 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [remains, attrName];
		}
		attrName = $append(attrName, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
		tokens = $subslice(tokens, 1);
		i = 0;
		token = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!isASCIILetterNumHyphen(token) && !((95 === token)) && !((46 === token)) && !((58 === token))) {
				break;
			}
			attrName = $append(attrName, token);
			_i++;
		}
		if (1 > attrName.$length) {
			return [remains, attrName];
		}
		remains = $subslice(tokens, i);
		return [remains, attrName];
	};
	Tree.prototype.parseAttrName = function(tokens) { return this.$val.parseAttrName(tokens); };
	Tree.ptr.prototype.parseTagName = function(tokens) {
		var _tmp, _tmp$1, i, remains, t, tagName, token, tokens;
		remains = sliceType.nil;
		tagName = sliceType.nil;
		t = this;
		i = 0;
		token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
		if (!isASCIILetter(token)) {
			_tmp = tokens;
			_tmp$1 = sliceType.nil;
			remains = _tmp;
			tagName = _tmp$1;
			return [remains, tagName];
		}
		tagName = $append(tagName, token);
		i = 1;
		while (true) {
			if (!(i < tokens.$length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!isASCIILetterNumHyphen(token)) {
				break;
			}
			tagName = $append(tagName, token);
			i = i + (1) >> 0;
		}
		remains = $subslice(tokens, i);
		return [remains, tagName];
	};
	Tree.prototype.parseTagName = function(tokens) { return this.$val.parseTagName(tokens); };
	Context.ptr.prototype.parseInlineLinkDest = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, context, dest, dest$1, destStarted, destination, i, i$1, isPointyBrackets, length, matchEnd, openParens, passed, r, r$1, remains, runes, runes$1, size, size$1, token, token$1, tokens, x, x$1;
		passed = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (2 > length) {
			return [passed, remains, destination];
		}
		passed = $makeSlice(sliceType, 0, 256);
		destination = $makeSlice(sliceType, 0, 256);
		isPointyBrackets = 60 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]);
		if (isPointyBrackets) {
			matchEnd = false;
			passed = $append(passed, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]), (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
			i = 2;
			size = 1;
			r = 0;
			_tmp = sliceType.nil;
			_tmp$1 = sliceType.nil;
			dest = _tmp;
			runes = _tmp$1;
			while (true) {
				if (!(i < length)) { break; }
				size = 1;
				token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
				if (10 === token) {
					passed = sliceType.nil;
					return [passed, remains, destination];
				}
				if (token < 128) {
					passed = $append(passed, token);
					dest = new sliceType([token]);
				} else {
					dest = new sliceType([]);
					_tuple = utf8.DecodeRune($subslice(tokens, i));
					r = _tuple[0];
					size = _tuple[1];
					runes = strToBytes(($encodeRune(r)));
					passed = $appendSlice(passed, runes);
					dest = $appendSlice(dest, runes);
				}
				destination = $appendSlice(destination, dest);
				if ((62 === token) && !isBackslashEscapePunct(tokens, i)) {
					destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
					matchEnd = true;
					break;
				}
				i = i + (size) >> 0;
			}
			if (!matchEnd || (length > i && !((41 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))))) {
				passed = sliceType.nil;
				return [passed, remains, destination];
			}
			passed = $append(passed, (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1])));
			remains = $subslice(tokens, (i + 2 >> 0));
		} else {
			openParens = 0;
			i$1 = 0;
			size$1 = 1;
			r$1 = 0;
			_tmp$2 = sliceType.nil;
			_tmp$3 = sliceType.nil;
			dest$1 = _tmp$2;
			runes$1 = _tmp$3;
			destStarted = false;
			while (true) {
				if (!(i$1 < length)) { break; }
				size$1 = 1;
				token$1 = ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]);
				if (token$1 < 128) {
					passed = $append(passed, token$1);
					dest$1 = new sliceType([token$1]);
				} else {
					dest$1 = new sliceType([]);
					_tuple$1 = utf8.DecodeRune($subslice(tokens, i$1));
					r$1 = _tuple$1[0];
					size$1 = _tuple$1[1];
					runes$1 = strToBytes(($encodeRune(r$1)));
					passed = $appendSlice(passed, runes$1);
					dest$1 = $appendSlice(dest$1, runes$1);
				}
				destination = $appendSlice(destination, dest$1);
				if (!destStarted && !isWhitespace(token$1) && 0 < i$1) {
					destStarted = true;
					destination = $subslice(destination, size$1);
					destination = trimWhitespace(destination);
				}
				if (destStarted && (isWhitespace(token$1) || isControl(token$1))) {
					destination = $subslice(destination, 0, (destination.$length - size$1 >> 0));
					passed = $subslice(passed, 0, (passed.$length - 1 >> 0));
					openParens = openParens - (1) >> 0;
					break;
				}
				if ((40 === token$1) && !isBackslashEscapePunct(tokens, i$1)) {
					openParens = openParens + (1) >> 0;
				}
				if ((41 === token$1) && !isBackslashEscapePunct(tokens, i$1)) {
					openParens = openParens - (1) >> 0;
					if (1 > openParens) {
						if (40 === (0 >= destination.$length ? ($throwRuntimeError("index out of range"), undefined) : destination.$array[destination.$offset + 0])) {
							destination = $subslice(destination, 1);
						}
						destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
						break;
					}
				}
				i$1 = i$1 + (size$1) >> 0;
			}
			remains = $subslice(tokens, i$1);
			if (length > i$1 && (!((41 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]))) && !((32 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]))) && !((10 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]))))) {
				passed = sliceType.nil;
				return [passed, remains, destination];
			}
			if (!((0 === openParens))) {
				passed = sliceType.nil;
				return [passed, remains, destination];
			}
		}
		if (!(sliceType.nil === passed)) {
			if (!context.option.VditorWYSIWYG) {
				destination = encodeDestination(unescapeString(destination));
			}
		}
		return [passed, remains, destination];
	};
	Context.prototype.parseInlineLinkDest = function(tokens) { return this.$val.parseInlineLinkDest(tokens); };
	Tree.ptr.prototype.parseInlineMath = function(ctx) {
		var blockEndPos, blockStartPos, content, ctx, dollars, endPos, matchBlock, ret, startPos, t, token, x, x$1, x$2, x$3, x$4, x$5;
		ret = ptrType.nil;
		t = this;
		if (2 > ctx.tokensLen) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", dollar, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		startPos = ctx.pos;
		blockStartPos = startPos;
		dollars = 0;
		while (true) {
			if (!(blockStartPos < ctx.tokensLen && (36 === (x = ctx.tokens, ((blockStartPos < 0 || blockStartPos >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + blockStartPos]))))) { break; }
			dollars = dollars + (1) >> 0;
			blockStartPos = blockStartPos + (1) >> 0;
		}
		if (2 <= dollars) {
			matchBlock = false;
			blockEndPos = blockStartPos + dollars >> 0;
			token = 0;
			while (true) {
				if (!(blockEndPos < ctx.tokensLen)) { break; }
				token = (x$1 = ctx.tokens, ((blockEndPos < 0 || blockEndPos >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + blockEndPos]));
				if ((36 === token) && blockEndPos < (ctx.tokensLen - 1 >> 0) && (36 === (x$2 = ctx.tokens, x$3 = blockEndPos + 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])))) {
					matchBlock = true;
					break;
				}
				blockEndPos = blockEndPos + (1) >> 0;
			}
			if (matchBlock) {
				ret = new Node.ptr(300, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(ctx.tokens, blockStartPos, blockEndPos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				ctx.pos = blockEndPos + 2 >> 0;
				return ret;
			}
		}
		if (isDigit((x$4 = ctx.tokens, x$5 = startPos + 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])))) {
			ctx.pos = ctx.pos + (2) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(ctx.tokens, startPos, (startPos + 2 >> 0)), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		endPos = t.matchInlineMathEnd($subslice(ctx.tokens, (startPos + 1 >> 0)));
		if (1 > endPos) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", dollar, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			return ret;
		}
		endPos = (startPos + endPos >> 0) + 2 >> 0;
		content = $subslice(ctx.tokens, (startPos + 1 >> 0), (endPos - 1 >> 0));
		ret = new Node.ptr(301, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", content, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		ctx.pos = endPos;
		return ret;
	};
	Tree.prototype.parseInlineMath = function(ctx) { return this.$val.parseInlineMath(ctx); };
	Tree.ptr.prototype.matchInlineMathEnd = function(tokens) {
		var length, pos, t, tokens, x;
		pos = 0;
		t = this;
		length = tokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			if (36 === ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos])) {
				if (pos < (length - 1 >> 0)) {
					if (!isDigit((x = pos + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
						pos = pos;
						return pos;
					}
				} else {
					pos = pos;
					return pos;
				}
			}
			pos = pos + (1) >> 0;
		}
		pos = -1;
		return pos;
	};
	Tree.prototype.matchInlineMathEnd = function(tokens) { return this.$val.matchInlineMathEnd(tokens); };
	Tree.ptr.prototype.parseInlines = function() {
		var t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		$r = t.walkParseInline(t.Root, ptrType$5.nil); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseInlines }; } $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseInlines = function() { return this.$val.parseInlines(); };
	Tree.ptr.prototype.walkParseInline = function(node, wg) {
		var child, child$1, closeMarker, code, ctx, cwg, info, length, next, node, openMarker, t, tokens, typ, wg, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; child = $f.child; child$1 = $f.child$1; closeMarker = $f.closeMarker; code = $f.code; ctx = $f.ctx; cwg = $f.cwg; info = $f.info; length = $f.length; next = $f.next; node = $f.node; openMarker = $f.openMarker; t = $f.t; tokens = $f.tokens; typ = $f.typ; wg = $f.wg; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		t = this;
		$deferred.push([recoverPanic, [ptrType$6.nil]]);
		if (!(ptrType$5.nil === wg)) {
			$deferred.push([$methodVal(wg, "Done"), []]);
		}
		if (ptrType.nil === node) {
			$s = -1; return;
		}
		typ = node.typ;
		/* */ if ((1 === typ) || (2 === typ) || (109 === typ)) { $s = 1; continue; }
		/* */ if (11 === typ) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if ((1 === typ) || (2 === typ) || (109 === typ)) { */ case 1:
			tokens = node.tokens;
			if ((1 === typ) && sliceType.nil === tokens) {
				next = node.next;
				node.Unlink();
				node.next = next;
				$s = -1; return;
			}
			length = tokens.$length;
			if (1 > length) {
				$s = -1; return;
			}
			ctx = new InlineContext.ptr(tokens, length, 0, 0, 0, ptrType$2.nil, ptrType$2.nil);
			$r = t.parseInline(node, ctx); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			t.processEmphasis(ptrType$2.nil, ctx);
			t.mergeText(node);
			if (t.context.option.GFMAutoLink && !t.context.option.VditorWYSIWYG) {
				t.parseGFMAutoEmailLink(node);
				t.parseGFMAutoLink(node);
			}
			if (t.context.option.Emoji) {
				t.emoji(node);
			}
			$s = -1; return;
		/* } else if (11 === typ) { */ case 2:
			if (node.isFencedCodeBlock) {
				openMarker = new Node.ptr(12, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", node.codeBlockOpenFence, false, false, false, 0, false, 0, node.codeBlockFenceLen, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.PrependChild(openMarker);
				info = new Node.ptr(14, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, node.codeBlockInfo, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.AppendChild(info);
				code = new Node.ptr(15, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", node.tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.AppendChild(code);
				node.tokens = sliceType.nil;
				closeMarker = new Node.ptr(13, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", node.codeBlockCloseFence, false, false, false, 0, false, 0, node.codeBlockFenceLen, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				node.AppendChild(closeMarker);
			}
		/* } */ case 3:
		/* */ if (t.context.option.ParallelParsing) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (t.context.option.ParallelParsing) { */ case 5:
			cwg = new sync.WaitGroup.ptr(0, $chanNil, arrayType.zero());
			child = node.firstChild;
			/* while (true) { */ case 8:
				/* if (!(!(ptrType.nil === child))) { break; } */ if(!(!(ptrType.nil === child))) { $s = 9; continue; }
				cwg.Add(1);
				$go($methodVal(t, "walkParseInline"), [child, cwg]);
				child = child.next;
			/* } */ $s = 8; continue; case 9:
			$r = cwg.Wait(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 7; continue;
		/* } else { */ case 6:
			child$1 = node.firstChild;
			/* while (true) { */ case 11:
				/* if (!(!(ptrType.nil === child$1))) { break; } */ if(!(!(ptrType.nil === child$1))) { $s = 12; continue; }
				$r = t.walkParseInline(child$1, ptrType$5.nil); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				child$1 = child$1.next;
			/* } */ $s = 11; continue; case 12:
		/* } */ case 7:
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.walkParseInline }; } $f.child = child; $f.child$1 = child$1; $f.closeMarker = closeMarker; $f.code = code; $f.ctx = ctx; $f.cwg = cwg; $f.info = info; $f.length = length; $f.next = next; $f.node = node; $f.openMarker = openMarker; $f.t = t; $f.tokens = tokens; $f.typ = typ; $f.wg = wg; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Tree.prototype.walkParseInline = function(node, wg) { return this.$val.walkParseInline(node, wg); };
	bytesToStr = function(bytes$1) {
		var bytes$1;
		return bytes$1;
	};
	strToBytes = function(str) {
		var h, str, str$24ptr, x;
		x = (((str$24ptr || (str$24ptr = new ptrType$7(function() { return str; }, function($v) { str = $v; })))));
		h = $toNativeArray($kindUintptr, [(x.nilCheck, x[0]), (x.nilCheck, x[1]), (x.nilCheck, x[1])]);
		return h;
	};
	lexer.ptr.prototype.nextLine = function() {
		var _tmp, _tmp$1, _tuple, b, i, l, nb, ret, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		ret = sliceType.nil;
		l = this;
		if (l.offset >= l.length) {
			return ret;
		}
		l.ln = l.ln + (1) >> 0;
		l.col = 0;
		_tmp = 0;
		_tmp$1 = 0;
		b = _tmp;
		nb = _tmp$1;
		i = l.offset;
		while (true) {
			if (!(i < l.length)) { break; }
			b = (x = l.input, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			l.col = l.col + (1) >> 0;
			if (10 === b) {
				i = i + (1) >> 0;
				break;
			} else if (13 === b) {
				if (i < (l.length - 1 >> 0)) {
					nb = (x$1 = l.input, x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2]));
					if (10 === nb) {
						l.input = $appendSlice($subslice(l.input, 0, i), $subslice(l.input, (i + 1 >> 0)));
						l.length = l.length - (1) >> 0;
					}
				}
				i = i + (1) >> 0;
				break;
			} else if (0 === b) {
				l.input = $append(l.input, 0, 0);
				$copySlice($subslice(l.input, (i + 2 >> 0)), $subslice(l.input, i));
				(x$3 = l.input, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i] = 239));
				(x$4 = l.input, x$5 = i + 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5] = 191));
				(x$6 = l.input, x$7 = i + 2 >> 0, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7] = 189));
				l.length = l.length + (2) >> 0;
				l.width = 3;
				i = i + (l.width) >> 0;
				continue;
			}
			if (128 <= b) {
				_tuple = utf8.DecodeRune($subslice(l.input, i));
				l.width = _tuple[1];
			} else {
				l.width = 1;
			}
			i = i + (l.width) >> 0;
		}
		ret = $subslice(l.input, l.offset, i);
		l.offset = i;
		return ret;
	};
	lexer.prototype.nextLine = function() { return this.$val.nextLine(); };
	newLexer = function(input) {
		var input, ret, x, x$1;
		ret = ptrType$8.nil;
		ret = new lexer.ptr(sliceType.nil, 0, 0, 0, 0, 0);
		ret.input = input;
		ret.length = input.$length;
		if (0 < ret.length && !((10 === (x = ret.input, x$1 = ret.length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))))) {
			ret.input = $append(ret.input, 10);
			ret.length = ret.length + (1) >> 0;
		}
		return ret;
	};
	Context.ptr.prototype.parseLinkRefDef = function(tokens) {
		var _entry, _key, _r, _tuple, _tuple$1, _tuple$10, _tuple$11, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, context, destination, label, length, link, linkDest, lowerCaseLabel, n, newlines, ok, remains, spaces1, spaces2, tabs1, tabs2, title, titleLine, tokens, validTitle, whitespaces, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$10 = $f._tuple$10; _tuple$11 = $f._tuple$11; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; context = $f.context; destination = $f.destination; label = $f.label; length = $f.length; link = $f.link; linkDest = $f.linkDest; lowerCaseLabel = $f.lowerCaseLabel; n = $f.n; newlines = $f.newlines; ok = $f.ok; remains = $f.remains; spaces1 = $f.spaces1; spaces2 = $f.spaces2; tabs1 = $f.tabs1; tabs2 = $f.tabs2; title = $f.title; titleLine = $f.titleLine; tokens = $f.tokens; validTitle = $f.validTitle; whitespaces = $f.whitespaces; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		context = this;
		_tuple = trimLeft(tokens);
		tokens = _tuple[1];
		if (1 > tokens.$length) {
			$s = -1; return sliceType.nil;
		}
		_tuple$1 = context.parseLinkLabel(tokens);
		n = _tuple$1[0];
		remains = _tuple$1[1];
		label = _tuple$1[2];
		if (2 > n || 1 > label.$length) {
			$s = -1; return sliceType.nil;
		}
		length = remains.$length;
		if (1 > length) {
			$s = -1; return sliceType.nil;
		}
		if (!((58 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0])))) {
			$s = -1; return sliceType.nil;
		}
		remains = $subslice(remains, 1);
		_tuple$2 = trimLeft(remains);
		whitespaces = _tuple$2[0];
		remains = _tuple$2[1];
		_tuple$3 = statWhitespace(whitespaces);
		newlines = _tuple$3[0];
		if (1 < newlines) {
			$s = -1; return sliceType.nil;
		}
		tokens = remains;
		_tuple$4 = context.parseLinkDest(tokens);
		linkDest = _tuple$4[0];
		remains = _tuple$4[1];
		destination = _tuple$4[2];
		if (sliceType.nil === linkDest) {
			$s = -1; return sliceType.nil;
		}
		_tuple$5 = trimLeft(remains);
		whitespaces = _tuple$5[0];
		remains = _tuple$5[1];
		if (sliceType.nil === whitespaces && 0 < remains.$length) {
			$s = -1; return sliceType.nil;
		}
		_tuple$6 = statWhitespace(whitespaces);
		newlines = _tuple$6[0];
		spaces1 = _tuple$6[1];
		tabs1 = _tuple$6[2];
		if (1 < newlines) {
			$s = -1; return sliceType.nil;
		}
		_tuple$7 = trimLeft(remains);
		tokens = _tuple$7[1];
		_tuple$8 = context.parseLinkTitle(tokens);
		validTitle = _tuple$8[0];
		remains = _tuple$8[2];
		title = _tuple$8[3];
		if (!validTitle && 1 > newlines) {
			$s = -1; return sliceType.nil;
		}
		if (0 < (spaces1 + tabs1 >> 0) && !isBlankLine(remains) && !((10 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0])))) {
			$s = -1; return sliceType.nil;
		}
		titleLine = tokens;
		_tuple$9 = trimLeft(remains);
		whitespaces = _tuple$9[0];
		tokens = _tuple$9[1];
		_tuple$10 = statWhitespace(whitespaces);
		spaces2 = _tuple$10[1];
		tabs2 = _tuple$10[2];
		if (!isBlankLine(tokens) && 0 < (spaces2 + tabs2 >> 0)) {
			remains = titleLine;
		} else {
			remains = tokens;
		}
		link = context.tree.newLink(33, label, destination, title, 1);
		_r = bytes.ToLower(label); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		lowerCaseLabel = _r;
		_tuple$11 = (_entry = context.linkRefDef[$String.keyFor(bytesToStr(lowerCaseLabel))], _entry !== undefined ? [_entry.v, true] : [ptrType.nil, false]);
		ok = _tuple$11[1];
		if (!ok) {
			_key = bytesToStr(lowerCaseLabel); (context.linkRefDef || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: link };
		}
		$s = -1; return remains;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.parseLinkRefDef }; } $f._entry = _entry; $f._key = _key; $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$10 = _tuple$10; $f._tuple$11 = _tuple$11; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.context = context; $f.destination = destination; $f.label = label; $f.length = length; $f.link = link; $f.linkDest = linkDest; $f.lowerCaseLabel = lowerCaseLabel; $f.n = n; $f.newlines = newlines; $f.ok = ok; $f.remains = remains; $f.spaces1 = spaces1; $f.spaces2 = spaces2; $f.tabs1 = tabs1; $f.tabs2 = tabs2; $f.title = title; $f.titleLine = titleLine; $f.tokens = tokens; $f.validTitle = validTitle; $f.whitespaces = whitespaces; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.parseLinkRefDef = function(tokens) { return this.$val.parseLinkRefDef(tokens); };
	Context.ptr.prototype.parseLinkTitle = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$2, context, passed, remains, title, tokens, validTitle;
		validTitle = false;
		passed = sliceType.nil;
		remains = sliceType.nil;
		title = sliceType.nil;
		context = this;
		if (1 > tokens.$length) {
			_tmp = true;
			_tmp$1 = sliceType.nil;
			_tmp$2 = tokens;
			_tmp$3 = sliceType.nil;
			validTitle = _tmp;
			passed = _tmp$1;
			remains = _tmp$2;
			title = _tmp$3;
			return [validTitle, passed, remains, title];
		}
		if (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) {
			_tmp$4 = true;
			_tmp$5 = sliceType.nil;
			_tmp$6 = tokens;
			_tmp$7 = sliceType.nil;
			validTitle = _tmp$4;
			passed = _tmp$5;
			remains = _tmp$6;
			title = _tmp$7;
			return [validTitle, passed, remains, title];
		}
		_tuple = context.parseLinkTitleMatch(34, 34, tokens);
		validTitle = _tuple[0];
		passed = _tuple[1];
		remains = _tuple[2];
		title = _tuple[3];
		if (!validTitle) {
			_tuple$1 = context.parseLinkTitleMatch(39, 39, tokens);
			validTitle = _tuple$1[0];
			passed = _tuple$1[1];
			remains = _tuple$1[2];
			title = _tuple$1[3];
			if (!validTitle) {
				_tuple$2 = context.parseLinkTitleMatch(40, 41, tokens);
				validTitle = _tuple$2[0];
				passed = _tuple$2[1];
				remains = _tuple$2[2];
				title = _tuple$2[3];
			}
		}
		if (!(sliceType.nil === title)) {
			if (!context.option.VditorWYSIWYG) {
				title = unescapeString(title);
			}
		}
		return [validTitle, passed, remains, title];
	};
	Context.prototype.parseLinkTitle = function(tokens) { return this.$val.parseLinkTitle(tokens); };
	Context.ptr.prototype.parseLinkTitleMatch = function(opener, closer, tokens) {
		var _tuple, closed, closer, context, i, j, length, line, opener, passed, r, remains, size, title, token, tokens, validTitle, x;
		validTitle = false;
		passed = sliceType.nil;
		remains = sliceType.nil;
		title = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (2 > length) {
			return [validTitle, passed, remains, title];
		}
		if (!((opener === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [validTitle, passed, remains, title];
		}
		line = tokens;
		length = line.$length;
		closed = false;
		i = 1;
		size = 0;
		r = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + i]);
			passed = $append(passed, token);
			_tuple = utf8.DecodeRune($subslice(line, i));
			r = _tuple[0];
			size = _tuple[1];
			j = 1;
			while (true) {
				if (!(j < size)) { break; }
				passed = $append(passed, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
				j = j + (1) >> 0;
			}
			title = $appendSlice(title, strToBytes(($encodeRune(r))));
			if ((closer === token) && !isBackslashEscapePunct(tokens, i)) {
				closed = true;
				title = $subslice(title, 0, (title.$length - 1 >> 0));
				break;
			}
			i = i + (size) >> 0;
		}
		if (!closed) {
			passed = sliceType.nil;
			return [validTitle, passed, remains, title];
		}
		validTitle = true;
		remains = $subslice(tokens, (i + 1 >> 0));
		return [validTitle, passed, remains, title];
	};
	Context.prototype.parseLinkTitleMatch = function(opener, closer, tokens) { return this.$val.parseLinkTitleMatch(opener, closer, tokens); };
	Context.ptr.prototype.parseLinkDest = function(tokens) {
		var _tuple, _tuple$1, context, destination, remains, ret, tokens;
		ret = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		_tuple = context.parseLinkDest1(tokens);
		ret = _tuple[0];
		remains = _tuple[1];
		destination = _tuple[2];
		if (sliceType.nil === ret) {
			_tuple$1 = context.parseLinkDest2(tokens);
			ret = _tuple$1[0];
			remains = _tuple$1[1];
			destination = _tuple$1[2];
		}
		if (!(sliceType.nil === ret)) {
			if (!context.option.VditorWYSIWYG) {
				destination = encodeDestination(unescapeString(destination));
			}
		}
		return [ret, remains, destination];
	};
	Context.prototype.parseLinkDest = function(tokens) { return this.$val.parseLinkDest(tokens); };
	Context.ptr.prototype.parseLinkDest2 = function(tokens) {
		var _tuple, context, destination, i, j, length, openParens, r, remains, ret, size, token, tokens, x;
		ret = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (1 > length) {
			return [ret, remains, destination];
		}
		ret = $makeSlice(sliceType, 0, 256);
		destination = $makeSlice(sliceType, 0, 256);
		openParens = 0;
		i = 0;
		size = 0;
		r = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			ret = $append(ret, token);
			_tuple = utf8.DecodeRune($subslice(tokens, i));
			r = _tuple[0];
			size = _tuple[1];
			j = 1;
			while (true) {
				if (!(j < size)) { break; }
				ret = $append(ret, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
				j = j + (1) >> 0;
			}
			destination = $appendSlice(destination, strToBytes(($encodeRune(r))));
			if (isWhitespace(token) || isControl(token)) {
				destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
				ret = $subslice(ret, 0, (ret.$length - 1 >> 0));
				break;
			}
			if ((40 === token) && !isBackslashEscapePunct(tokens, i)) {
				openParens = openParens + (1) >> 0;
			}
			if ((41 === token) && !isBackslashEscapePunct(tokens, i)) {
				openParens = openParens - (1) >> 0;
				if (1 > openParens) {
					i = i + (1) >> 0;
					break;
				}
			}
			i = i + (size) >> 0;
		}
		remains = $subslice(tokens, i);
		if (length > i && !isWhitespace(((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]))) {
			ret = sliceType.nil;
			return [ret, remains, destination];
		}
		return [ret, remains, destination];
	};
	Context.prototype.parseLinkDest2 = function(tokens) { return this.$val.parseLinkDest2(tokens); };
	Context.ptr.prototype.parseLinkDest1 = function(tokens) {
		var _tuple, closed, context, destination, i, j, length, r, remains, ret, size, token, tokens, x;
		ret = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (2 > length) {
			return [ret, remains, destination];
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [ret, remains, destination];
		}
		ret = $makeSlice(sliceType, 0, 256);
		destination = $makeSlice(sliceType, 0, 256);
		closed = false;
		i = 0;
		size = 0;
		r = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			ret = $append(ret, token);
			size = 1;
			if (0 < i) {
				_tuple = utf8.DecodeRune($subslice(tokens, i));
				r = _tuple[0];
				size = _tuple[1];
				j = 1;
				while (true) {
					if (!(j < size)) { break; }
					ret = $append(ret, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
					j = j + (1) >> 0;
				}
				destination = $appendSlice(destination, strToBytes(($encodeRune(r))));
				if ((60 === token) && !isBackslashEscapePunct(tokens, i)) {
					ret = sliceType.nil;
					return [ret, remains, destination];
				}
			}
			if ((62 === token) && !isBackslashEscapePunct(tokens, i)) {
				closed = true;
				destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
				break;
			}
			i = i + (size) >> 0;
		}
		if (!closed) {
			ret = sliceType.nil;
			return [ret, remains, destination];
		}
		remains = $subslice(tokens, (i + 1 >> 0));
		return [ret, remains, destination];
	};
	Context.prototype.parseLinkDest1 = function(tokens) { return this.$val.parseLinkDest1(tokens); };
	Context.ptr.prototype.parseLinkLabel = function(tokens) {
		var _tuple, closed, context, i, i$1, j, label, length, length$1, n, passed, r, remains, size, token, token$1, tokens, x, x$1;
		n = 0;
		remains = sliceType.nil;
		label = sliceType.nil;
		context = this;
		length = tokens.$length;
		if (2 > length) {
			return [n, remains, label];
		}
		if (!((91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [n, remains, label];
		}
		passed = $makeSlice(sliceType, 0, tokens.$length);
		passed = $append(passed, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
		closed = false;
		i = 1;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			passed = $append(passed, token);
			_tuple = utf8.DecodeRune($subslice(tokens, i));
			r = _tuple[0];
			size = _tuple[1];
			j = 1;
			while (true) {
				if (!(j < size)) { break; }
				passed = $append(passed, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
				j = j + (1) >> 0;
			}
			label = $appendSlice(label, strToBytes(($encodeRune(r))));
			if ((93 === token) && !isBackslashEscapePunct(tokens, i)) {
				closed = true;
				label = $subslice(label, 0, (label.$length - 1 >> 0));
				remains = $subslice(tokens, (i + 1 >> 0));
				break;
			}
			if ((91 === token) && !isBackslashEscapePunct(tokens, i)) {
				passed = sliceType.nil;
				return [n, remains, label];
			}
			i = i + (size) >> 0;
		}
		if (!closed || sliceType.nil === trimWhitespace(label) || 999 < label.$length) {
			passed = sliceType.nil;
			return [n, remains, label];
		}
		label = trimWhitespace(label);
		if (!context.option.VditorWYSIWYG) {
			label = bytes.ReplaceAll(label, new sliceType([10]), new sliceType([32]));
			length$1 = label.$length;
			token$1 = 0;
			i$1 = 0;
			while (true) {
				if (!(i$1 < length$1)) { break; }
				token$1 = ((i$1 < 0 || i$1 >= label.$length) ? ($throwRuntimeError("index out of range"), undefined) : label.$array[label.$offset + i$1]);
				if ((token$1 === 32) && i$1 < (length$1 - 1 >> 0) && ((x$1 = i$1 + 1 >> 0, ((x$1 < 0 || x$1 >= label.$length) ? ($throwRuntimeError("index out of range"), undefined) : label.$array[label.$offset + x$1])) === 32)) {
					label = $appendSlice($subslice(label, 0, i$1), $subslice(label, (i$1 + 1 >> 0)));
					length$1 = length$1 - (1) >> 0;
				}
				i$1 = i$1 + (1) >> 0;
			}
		}
		n = passed.$length;
		return [n, remains, label];
	};
	Context.prototype.parseLinkLabel = function(tokens) { return this.$val.parseLinkLabel(tokens); };
	Node.ptr.prototype.listFinalize = function(context) {
		var context, item, list, subitem;
		list = this;
		item = list.firstChild;
		while (true) {
			if (!(!(ptrType.nil === item))) { break; }
			if (list.endsWithBlankLine(item) && !(ptrType.nil === item.next)) {
				list.listData.tight = false;
				break;
			}
			subitem = item.firstChild;
			while (true) {
				if (!(!(ptrType.nil === subitem))) { break; }
				if (list.endsWithBlankLine(subitem) && (!(ptrType.nil === item.next) || !(ptrType.nil === subitem.next))) {
					list.listData.tight = false;
					break;
				}
				subitem = subitem.next;
			}
			item = item.next;
		}
	};
	Node.prototype.listFinalize = function(context) { return this.$val.listFinalize(context); };
	Tree.ptr.prototype.parseListMarker = function(container) {
		var _tuple, _tuple$1, container, content, data, delim, isBlankItem, ln, marker, markerLength, spacesAfterMarker, spacesStartCol, spacesStartOffset, t, token, tokens, x, x$1;
		t = this;
		if (t.context.indent >= 4) {
			return ptrType$1.nil;
		}
		ln = t.context.currentLine;
		tokens = $subslice(ln, t.context.nextNonspace);
		data = new listData.ptr(0, true, sliceType.nil, 0, 0, 0, t.context.indent, false, sliceType.nil, -1);
		markerLength = 1;
		marker = new sliceType([(0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])]);
		delim = 0;
		if ((43 === (0 >= marker.$length ? ($throwRuntimeError("index out of range"), undefined) : marker.$array[marker.$offset + 0])) || (45 === (0 >= marker.$length ? ($throwRuntimeError("index out of range"), undefined) : marker.$array[marker.$offset + 0])) || (42 === (0 >= marker.$length ? ($throwRuntimeError("index out of range"), undefined) : marker.$array[marker.$offset + 0]))) {
			data.bulletChar = marker;
		} else {
			_tuple = t.parseOrderedListMarker(tokens);
			marker = _tuple[0];
			delim = _tuple[1];
			if (!(sliceType.nil === marker)) {
				if (!((container.typ === 1)) || bytes.Equal(items1, marker)) {
					data.typ = 1;
					_tuple$1 = strconv.Atoi(bytesToStr(marker));
					data.start = _tuple$1[0];
					markerLength = marker.$length + 1 >> 0;
					data.delimiter = delim;
				} else {
					return ptrType$1.nil;
				}
			} else {
				return ptrType$1.nil;
			}
		}
		data.marker = marker;
		token = (x = t.context.nextNonspace + markerLength >> 0, ((x < 0 || x >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + x]));
		if (!isWhitespace(token)) {
			return ptrType$1.nil;
		}
		if (t.context.option.VditorWYSIWYG) {
			if (10 === token) {
				return ptrType$1.nil;
			}
		}
		if ((container.typ === 1) && (10 === (x$1 = t.context.nextNonspace + markerLength >> 0, ((x$1 < 0 || x$1 >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + x$1])))) {
			return ptrType$1.nil;
		}
		t.context.advanceNextNonspace();
		t.context.advanceOffset(markerLength, true);
		spacesStartCol = t.context.column;
		spacesStartOffset = t.context.offset;
		while (true) {
			t.context.advanceOffset(1, true);
			token = peek(ln, t.context.offset);
			if ((t.context.column - spacesStartCol >> 0) >= 5 || (0 === (token)) || (!((32 === token)) && !((9 === token)))) {
				break;
			}
		}
		token = peek(ln, t.context.offset);
		isBlankItem = (0 === token) || (10 === token);
		spacesAfterMarker = t.context.column - spacesStartCol >> 0;
		if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || isBlankItem) {
			data.padding = markerLength + 1 >> 0;
			t.context.column = spacesStartCol;
			t.context.offset = spacesStartOffset;
			token = peek(ln, t.context.offset);
			if ((32 === token) || (9 === token)) {
				t.context.advanceOffset(1, true);
			}
		} else {
			data.padding = markerLength + spacesAfterMarker >> 0;
		}
		if (!isBlankItem) {
			content = $subslice(ln, t.context.offset);
			if (3 <= content.$length) {
				if ((91 === (0 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 0])) && ((120 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1])) || (88 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1])) || (32 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1]))) && (93 === (2 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 2]))) {
					data.typ = 3;
					data.checked = (120 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1])) || (88 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1]));
				}
			}
		}
		return data;
	};
	Tree.prototype.parseListMarker = function(container) { return this.$val.parseListMarker(container); };
	Tree.ptr.prototype.parseOrderedListMarker = function(tokens) {
		var _tmp, _tmp$1, delimiter$1, i, length, marker, t, token, tokens;
		marker = sliceType.nil;
		delimiter$1 = 0;
		t = this;
		length = tokens.$length;
		i = 0;
		token = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!isDigit(token) || 8 < i) {
				delimiter$1 = token;
				break;
			}
			marker = $append(marker, token);
			i = i + (1) >> 0;
		}
		if (1 > marker.$length || (!((46 === delimiter$1)) && !((41 === delimiter$1)))) {
			_tmp = sliceType.nil;
			_tmp$1 = 0;
			marker = _tmp;
			delimiter$1 = _tmp$1;
			return [marker, delimiter$1];
		}
		return [marker, delimiter$1];
	};
	Tree.prototype.parseOrderedListMarker = function(tokens) { return this.$val.parseOrderedListMarker(tokens); };
	Node.ptr.prototype.endsWithBlankLine = function(block) {
		var block, list, t;
		list = this;
		while (true) {
			if (!(!(ptrType.nil === block))) { break; }
			if (block.lastLineBlank) {
				return true;
			}
			t = block.typ;
			if (!block.lastLineChecked && ((t === 7) || (t === 8))) {
				block.lastLineChecked = true;
				block = block.lastChild;
			} else {
				block.lastLineChecked = true;
				break;
			}
		}
		return false;
	};
	Node.prototype.endsWithBlankLine = function(block) { return this.$val.endsWithBlankLine(block); };
	Node.ptr.prototype.listItemContinue = function(context) {
		var context, listItem;
		listItem = this;
		if (context.blank) {
			if (ptrType.nil === listItem.firstChild) {
				return 1;
			}
			context.advanceNextNonspace();
		} else if (context.indent >= (listItem.listData.markerOffset + listItem.listData.padding >> 0)) {
			context.advanceOffset(listItem.listData.markerOffset + listItem.listData.padding >> 0, true);
		} else {
			return 1;
		}
		return 0;
	};
	Node.prototype.listItemContinue = function(context) { return this.$val.listItemContinue(context); };
	New = function(opts) {
		var _i, _ref, _tuple, opt, opts, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; _tuple = $f._tuple; opt = $f.opt; opts = $f.opts; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = ptrType$9.nil;
		ret = new Lute.ptr(new options.ptr(false, false, "", false, false, false, false, false, false, "", false, false, false, false, false, "", false, false, false, false));
		ret.options.GFMTable = true;
		ret.options.GFMTaskListItem = true;
		ret.options.GFMTaskListItemClass = "vditor-task";
		ret.options.GFMStrikethrough = true;
		ret.options.GFMAutoLink = true;
		ret.options.SoftBreak2HardBreak = true;
		ret.options.CodeSyntaxHighlight = true;
		ret.options.CodeSyntaxHighlightInlineStyle = false;
		ret.options.CodeSyntaxHighlightLineNum = false;
		ret.options.CodeSyntaxHighlightStyleName = "github";
		ret.options.AutoSpace = true;
		ret.options.FixTermTypo = true;
		ret.options.Emoji = true;
		_tuple = newEmojis();
		ret.options.AliasEmoji = _tuple[0];
		ret.options.EmojiAlias = _tuple[1];
		ret.options.Terms = newTerms();
		ret.options.EmojiSite = "https://cdn.jsdelivr.net/npm/vditor/dist/images/emoji";
		ret.options.ParallelParsing = true;
		_ref = opts;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			opt = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			$r = opt(ret); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		ret = ret;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: New }; } $f._i = _i; $f._ref = _ref; $f._tuple = _tuple; $f.opt = opt; $f.opts = opts; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.New = New;
	Lute.ptr.prototype.Markdown = function(name, markdown) {
		var _r, _r$1, _tuple, _tuple$1, err, html$1, lute, markdown, name, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; err = $f.err; html$1 = $f.html$1; lute = $f.lute; markdown = $f.markdown; name = $f.name; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		html$1 = sliceType.nil;
		err = $ifaceNil;
		lute = this;
		tree = ptrType$11.nil;
		_r = lute.parse(name, markdown); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		tree = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [html$1, err];
		}
		renderer = lute.newHTMLRenderer(tree);
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		html$1 = _tuple$1[0];
		err = _tuple$1[1];
		$s = -1; return [html$1, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Markdown }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.err = err; $f.html$1 = html$1; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Markdown = function(name, markdown) { return this.$val.Markdown(name, markdown); };
	Lute.ptr.prototype.MarkdownStr = function(name, markdown) {
		var _r, _tuple, err, html$1, htmlBytes, lute, markdown, name, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; html$1 = $f.html$1; htmlBytes = $f.htmlBytes; lute = $f.lute; markdown = $f.markdown; name = $f.name; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		html$1 = "";
		err = $ifaceNil;
		lute = this;
		htmlBytes = sliceType.nil;
		_r = lute.Markdown(name, (new sliceType($stringToBytes(markdown)))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		htmlBytes = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [html$1, err];
		}
		html$1 = bytesToStr(htmlBytes);
		$s = -1; return [html$1, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.MarkdownStr }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.html$1 = html$1; $f.htmlBytes = htmlBytes; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.MarkdownStr = function(name, markdown) { return this.$val.MarkdownStr(name, markdown); };
	Lute.ptr.prototype.Format = function(name, markdown) {
		var _r, _r$1, _tuple, _tuple$1, err, formatted, lute, markdown, name, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; err = $f.err; formatted = $f.formatted; lute = $f.lute; markdown = $f.markdown; name = $f.name; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		formatted = sliceType.nil;
		err = $ifaceNil;
		lute = this;
		tree = ptrType$11.nil;
		_r = lute.parse(name, markdown); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		tree = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [formatted, err];
		}
		renderer = lute.newFormatRenderer(tree);
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		formatted = _tuple$1[0];
		err = _tuple$1[1];
		$s = -1; return [formatted, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Format }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.err = err; $f.formatted = formatted; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Format = function(name, markdown) { return this.$val.Format(name, markdown); };
	Lute.ptr.prototype.FormatStr = function(name, markdown) {
		var _r, _tuple, err, formatted, formattedBytes, lute, markdown, name, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; formatted = $f.formatted; formattedBytes = $f.formattedBytes; lute = $f.lute; markdown = $f.markdown; name = $f.name; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		formatted = "";
		err = $ifaceNil;
		lute = this;
		formattedBytes = sliceType.nil;
		_r = lute.Format(name, (new sliceType($stringToBytes(markdown)))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		formattedBytes = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [formatted, err];
		}
		formatted = bytesToStr(formattedBytes);
		$s = -1; return [formatted, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.FormatStr }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.formatted = formatted; $f.formattedBytes = formattedBytes; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.FormatStr = function(name, markdown) { return this.$val.FormatStr(name, markdown); };
	Lute.ptr.prototype.Html2Md = function(htmlStr) {
		var _i, _r, _r$1, _ref, _tuple, _tuple$1, err, formatted, htmlNode, htmlNodes, htmlRoot, htmlStr, lute, md, reader, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; err = $f.err; formatted = $f.formatted; htmlNode = $f.htmlNode; htmlNodes = $f.htmlNodes; htmlRoot = $f.htmlRoot; htmlStr = $f.htmlStr; lute = $f.lute; md = $f.md; reader = $f.reader; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		md = "";
		err = $ifaceNil;
		lute = this;
		reader = strings.NewReader(htmlStr);
		htmlRoot = new html.Node.ptr(ptrType$12.nil, ptrType$12.nil, ptrType$12.nil, ptrType$12.nil, ptrType$12.nil, 3, 0, "", "", sliceType$7.nil);
		_r = html.ParseFragment(reader, htmlRoot); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		htmlNodes = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [md, err];
		}
		tree = new Tree.ptr("", new Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""), ptrType$8.nil, new Context.ptr(ptrType$11.nil, lute.options, false, ptrType.nil, ptrType.nil, sliceType.nil, 0, 0, 0, 0, 0, 0, 0, false, false, false, false, ptrType.nil), ptrType$14.nil);
		tree.context.tip = tree.Root;
		_ref = htmlNodes;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			htmlNode = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			lute.genASTByVditorDOM(htmlNode, tree);
			_i++;
		}
		formatted = sliceType.nil;
		renderer = lute.newFormatRenderer(tree);
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		formatted = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [md, err];
		}
		md = bytesToStr(formatted);
		$s = -1; return [md, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Html2Md }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.err = err; $f.formatted = formatted; $f.htmlNode = htmlNode; $f.htmlNodes = htmlNodes; $f.htmlRoot = htmlRoot; $f.htmlStr = htmlStr; $f.lute = lute; $f.md = md; $f.reader = reader; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Html2Md = function(htmlStr) { return this.$val.Html2Md(htmlStr); };
	Lute.ptr.prototype.Space = function(text) {
		var lute, text;
		lute = this;
		return space0(text);
	};
	Lute.prototype.Space = function(text) { return this.$val.Space(text); };
	Lute.ptr.prototype.GetEmojis = function() {
		var _entry, _i, _key, _keys, _ref, k, lute, placeholder, ret, v, x;
		ret = false;
		lute = this;
		ret = (x = $keys(lute.options.AliasEmoji).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		placeholder = bytesToStr(emojiSitePlaceholder);
		_ref = lute.options.AliasEmoji;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			if (strings.Contains(v, placeholder)) {
				v = strings.ReplaceAll(v, placeholder, lute.options.EmojiSite);
			}
			_key = k; (ret || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_i++;
		}
		return ret;
	};
	Lute.prototype.GetEmojis = function() { return this.$val.GetEmojis(); };
	Lute.ptr.prototype.PutEmojis = function(emojiMap) {
		var _entry, _i, _key, _key$1, _keys, _ref, emojiMap, k, lute, v;
		lute = this;
		_ref = emojiMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (lute.options.AliasEmoji || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_key$1 = v; (lute.options.EmojiAlias || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: k };
			_i++;
		}
	};
	Lute.prototype.PutEmojis = function(emojiMap) { return this.$val.PutEmojis(emojiMap); };
	Lute.ptr.prototype.GetTerms = function() {
		var lute;
		lute = this;
		return lute.options.Terms;
	};
	Lute.prototype.GetTerms = function() { return this.$val.GetTerms(); };
	Lute.ptr.prototype.PutTerms = function(termMap) {
		var _entry, _i, _key, _keys, _ref, k, lute, termMap, v;
		lute = this;
		_ref = termMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (lute.options.Terms || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_i++;
		}
	};
	Lute.prototype.PutTerms = function(termMap) { return this.$val.PutTerms(termMap); };
	Lute.ptr.prototype.RenderEChartsJSON = function(markdownText) {
		var _r, _r$1, _tuple, _tuple$1, err, json, lute, markdownText, output, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; err = $f.err; json = $f.json; lute = $f.lute; markdownText = $f.markdownText; output = $f.output; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		json = "";
		err = $ifaceNil;
		lute = this;
		tree = ptrType$11.nil;
		_r = lute.parse("", (new sliceType($stringToBytes(markdownText)))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		tree = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [json, err];
		}
		renderer = lute.newEChartsJSONRenderer(tree);
		output = sliceType.nil;
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		output = _tuple$1[0];
		err = _tuple$1[1];
		json = ($bytesToString(output));
		$s = -1; return [json, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.RenderEChartsJSON }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.err = err; $f.json = json; $f.lute = lute; $f.markdownText = markdownText; $f.output = output; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.RenderEChartsJSON = function(markdownText) { return this.$val.RenderEChartsJSON(markdownText); };
	Lute.ptr.prototype.SetGFMTable = function(b) {
		var b, lute;
		lute = this;
		lute.options.GFMTable = b;
	};
	Lute.prototype.SetGFMTable = function(b) { return this.$val.SetGFMTable(b); };
	Lute.ptr.prototype.SetGFMTaskListItem = function(b) {
		var b, lute;
		lute = this;
		lute.options.GFMTaskListItem = b;
	};
	Lute.prototype.SetGFMTaskListItem = function(b) { return this.$val.SetGFMTaskListItem(b); };
	Lute.ptr.prototype.SetGFMTaskListItemClass = function(class$1) {
		var class$1, lute;
		lute = this;
		lute.options.GFMTaskListItemClass = class$1;
	};
	Lute.prototype.SetGFMTaskListItemClass = function(class$1) { return this.$val.SetGFMTaskListItemClass(class$1); };
	Lute.ptr.prototype.SetGFMStrikethrough = function(b) {
		var b, lute;
		lute = this;
		lute.options.GFMStrikethrough = b;
	};
	Lute.prototype.SetGFMStrikethrough = function(b) { return this.$val.SetGFMStrikethrough(b); };
	Lute.ptr.prototype.SetGFMAutoLink = function(b) {
		var b, lute;
		lute = this;
		lute.options.GFMAutoLink = b;
	};
	Lute.prototype.SetGFMAutoLink = function(b) { return this.$val.SetGFMAutoLink(b); };
	Lute.ptr.prototype.SetSoftBreak2HardBreak = function(b) {
		var b, lute;
		lute = this;
		lute.options.SoftBreak2HardBreak = b;
	};
	Lute.prototype.SetSoftBreak2HardBreak = function(b) { return this.$val.SetSoftBreak2HardBreak(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlight = function(b) {
		var b, lute;
		lute = this;
		lute.options.CodeSyntaxHighlight = b;
	};
	Lute.prototype.SetCodeSyntaxHighlight = function(b) { return this.$val.SetCodeSyntaxHighlight(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlightInlineStyle = function(b) {
		var b, lute;
		lute = this;
		lute.options.CodeSyntaxHighlightInlineStyle = b;
	};
	Lute.prototype.SetCodeSyntaxHighlightInlineStyle = function(b) { return this.$val.SetCodeSyntaxHighlightInlineStyle(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlightLineNum = function(b) {
		var b, lute;
		lute = this;
		lute.options.CodeSyntaxHighlightLineNum = b;
	};
	Lute.prototype.SetCodeSyntaxHighlightLineNum = function(b) { return this.$val.SetCodeSyntaxHighlightLineNum(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlightStyleName = function(name) {
		var lute, name;
		lute = this;
		lute.options.CodeSyntaxHighlightStyleName = name;
	};
	Lute.prototype.SetCodeSyntaxHighlightStyleName = function(name) { return this.$val.SetCodeSyntaxHighlightStyleName(name); };
	Lute.ptr.prototype.SetAutoSpace = function(b) {
		var b, lute;
		lute = this;
		lute.options.AutoSpace = b;
	};
	Lute.prototype.SetAutoSpace = function(b) { return this.$val.SetAutoSpace(b); };
	Lute.ptr.prototype.SetFixTermTypo = function(b) {
		var b, lute;
		lute = this;
		lute.options.FixTermTypo = b;
	};
	Lute.prototype.SetFixTermTypo = function(b) { return this.$val.SetFixTermTypo(b); };
	Lute.ptr.prototype.SetEmoji = function(b) {
		var b, lute;
		lute = this;
		lute.options.Emoji = b;
	};
	Lute.prototype.SetEmoji = function(b) { return this.$val.SetEmoji(b); };
	Lute.ptr.prototype.SetEmojis = function(emojis) {
		var emojis, lute;
		lute = this;
		lute.options.AliasEmoji = emojis;
	};
	Lute.prototype.SetEmojis = function(emojis) { return this.$val.SetEmojis(emojis); };
	Lute.ptr.prototype.SetEmojiSite = function(emojiSite) {
		var emojiSite, lute;
		lute = this;
		lute.options.EmojiSite = emojiSite;
	};
	Lute.prototype.SetEmojiSite = function(emojiSite) { return this.$val.SetEmojiSite(emojiSite); };
	Lute.ptr.prototype.SetHeadingAnchor = function(b) {
		var b, lute;
		lute = this;
		lute.options.HeadingAnchor = b;
	};
	Lute.prototype.SetHeadingAnchor = function(b) { return this.$val.SetHeadingAnchor(b); };
	Lute.ptr.prototype.SetTerms = function(terms$1) {
		var lute, terms$1;
		lute = this;
		lute.options.Terms = terms$1;
	};
	Lute.prototype.SetTerms = function(terms$1) { return this.$val.SetTerms(terms$1); };
	Lute.ptr.prototype.SetVditorWYSIWYG = function(b) {
		var b, lute;
		lute = this;
		lute.options.VditorWYSIWYG = b;
	};
	Lute.prototype.SetVditorWYSIWYG = function(b) { return this.$val.SetVditorWYSIWYG(b); };
	Lute.ptr.prototype.SetParallelParsing = function(b) {
		var b, lute;
		lute = this;
		lute.options.ParallelParsing = b;
	};
	Lute.prototype.SetParallelParsing = function(b) { return this.$val.SetParallelParsing(b); };
	Node.ptr.prototype.mathBlockContinue = function(context) {
		var context, i, indent, ln, mathBlock, token, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; context = $f.context; i = $f.i; indent = $f.indent; ln = $f.ln; mathBlock = $f.mathBlock; token = $f.token; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		mathBlock = this;
		ln = context.currentLine;
		indent = context.indent;
		/* */ if (indent <= 3 && mathBlock.isMathBlockClose($subslice(ln, context.nextNonspace))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (indent <= 3 && mathBlock.isMathBlockClose($subslice(ln, context.nextNonspace))) { */ case 1:
			$r = context.finalize(mathBlock, context.lineNum); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return 2;
		/* } else { */ case 2:
			i = mathBlock.mathBlockDollarOffset;
			token = 0;
			while (true) {
				if (!(i > 0)) { break; }
				token = peek(ln, context.offset);
				if (!((32 === token)) && !((9 === token))) {
					break;
				}
				context.advanceOffset(1, true);
				i = i - (1) >> 0;
			}
		/* } */ case 3:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.mathBlockContinue }; } $f.context = context; $f.i = i; $f.indent = indent; $f.ln = ln; $f.mathBlock = mathBlock; $f.token = token; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.mathBlockContinue = function(context) { return this.$val.mathBlockContinue(context); };
	Node.ptr.prototype.mathBlockFinalize = function(context) {
		var context, mathBlock, tokens;
		mathBlock = this;
		tokens = $subslice(mathBlock.tokens, 2);
		tokens = trimWhitespace(tokens);
		if (bytes.HasSuffix(tokens, mathBlockMarker)) {
			tokens = $subslice(tokens, 0, (tokens.$length - 2 >> 0));
		}
		mathBlock.tokens = tokens;
	};
	Node.prototype.mathBlockFinalize = function(context) { return this.$val.mathBlockFinalize(context); };
	Tree.ptr.prototype.parseMathBlock = function() {
		var _tmp, _tmp$1, fenceChar, fenceLength, i, marker, mathBlockDollarOffset, ok, t, x, x$1, x$2;
		ok = false;
		mathBlockDollarOffset = 0;
		t = this;
		marker = (x = t.context.currentLine, x$1 = t.context.nextNonspace, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (!((36 === marker))) {
			return [ok, mathBlockDollarOffset];
		}
		fenceChar = marker;
		fenceLength = 0;
		i = t.context.nextNonspace;
		while (true) {
			if (!(i < t.context.currentLineLen && (fenceChar === (x$2 = t.context.currentLine, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]))))) { break; }
			fenceLength = fenceLength + (1) >> 0;
			i = i + (1) >> 0;
		}
		if (2 > fenceLength) {
			return [ok, mathBlockDollarOffset];
		}
		_tmp = true;
		_tmp$1 = t.context.indent;
		ok = _tmp;
		mathBlockDollarOffset = _tmp$1;
		return [ok, mathBlockDollarOffset];
	};
	Tree.prototype.parseMathBlock = function() { return this.$val.parseMathBlock(); };
	Node.ptr.prototype.isMathBlockClose = function(tokens) {
		var _i, _ref, closeMarker, mathBlock, token, tokens;
		mathBlock = this;
		closeMarker = (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]);
		if (!((closeMarker === 36))) {
			return false;
		}
		if (2 > accept(tokens, closeMarker)) {
			return false;
		}
		tokens = trimWhitespace(tokens);
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((token === 36))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	Node.prototype.isMathBlockClose = function(tokens) { return this.$val.isMathBlockClose(tokens); };
	Node.ptr.prototype.lastDeepestChild = function() {
		var n, ret;
		ret = ptrType.nil;
		n = this;
		if (ptrType.nil === n.lastChild) {
			ret = n;
			return ret;
		}
		ret = n.lastChild.lastDeepestChild();
		return ret;
	};
	Node.prototype.lastDeepestChild = function() { return this.$val.lastDeepestChild(); };
	Node.ptr.prototype.ChildByType = function(childType) {
		var c, childType, n;
		n = this;
		c = n.firstChild;
		while (true) {
			if (!(!(ptrType.nil === c))) { break; }
			if (c.typ === childType) {
				return c;
			}
			c = c.next;
		}
		return ptrType.nil;
	};
	Node.prototype.ChildByType = function(childType) { return this.$val.ChildByType(childType); };
	Node.ptr.prototype.Text = function() {
		var _r, n, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = [ret];
		ret[0] = "";
		n = this;
		_r = Walk(n, (function(ret) { return function(n$1, entering) {
			var _tmp, _tmp$1, e, entering, n$1, status;
			status = 0;
			e = $ifaceNil;
			if (((16 === n$1.typ) || (40 === n$1.typ)) && entering) {
				ret[0] = ret[0] + (bytesToStr(n$1.tokens));
			}
			_tmp = 2;
			_tmp$1 = $ifaceNil;
			status = _tmp;
			e = _tmp$1;
			return [status, e];
		}; })(ret)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return ret[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.Text }; } $f._r = _r; $f.n = n; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.Text = function() { return this.$val.Text(); };
	Node.ptr.prototype.Finalize = function(context) {
		var _1, context, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; context = $f.context; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = this;
			_1 = n.typ;
			/* */ if (_1 === (11)) { $s = 2; continue; }
			/* */ if (_1 === (9)) { $s = 3; continue; }
			/* */ if (_1 === (1)) { $s = 4; continue; }
			/* */ if (_1 === (300)) { $s = 5; continue; }
			/* */ if (_1 === (7)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (11)) { */ case 2:
				n.codeBlockFinalize(context);
				$s = 7; continue;
			/* } else if (_1 === (9)) { */ case 3:
				n.htmlBlockFinalize(context);
				$s = 7; continue;
			/* } else if (_1 === (1)) { */ case 4:
				$r = n.paragraphFinalize(context); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 7; continue;
			/* } else if (_1 === (300)) { */ case 5:
				n.mathBlockFinalize(context);
				$s = 7; continue;
			/* } else if (_1 === (7)) { */ case 6:
				n.listFinalize(context);
			/* } */ case 7:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.Finalize }; } $f._1 = _1; $f.context = context; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.Finalize = function(context) { return this.$val.Finalize(context); };
	Node.ptr.prototype.Continue = function(context) {
		var _1, _r, _r$1, context, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; context = $f.context; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = this;
			_1 = n.typ;
			/* */ if (_1 === (11)) { $s = 2; continue; }
			/* */ if (_1 === (9)) { $s = 3; continue; }
			/* */ if (_1 === (1)) { $s = 4; continue; }
			/* */ if (_1 === (8)) { $s = 5; continue; }
			/* */ if (_1 === (5)) { $s = 6; continue; }
			/* */ if (_1 === (300)) { $s = 7; continue; }
			/* */ if ((_1 === (2)) || (_1 === (4))) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (_1 === (11)) { */ case 2:
				_r = n.codeBlockContinue(context); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (9)) { */ case 3:
				$s = -1; return n.htmlBlockContinue(context);
			/* } else if (_1 === (1)) { */ case 4:
				$s = -1; return n.paragraphContinue(context);
			/* } else if (_1 === (8)) { */ case 5:
				$s = -1; return n.listItemContinue(context);
			/* } else if (_1 === (5)) { */ case 6:
				$s = -1; return n.blockquoteContinue(context);
			/* } else if (_1 === (300)) { */ case 7:
				_r$1 = n.mathBlockContinue(context); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return _r$1;
			/* } else if ((_1 === (2)) || (_1 === (4))) { */ case 8:
				$s = -1; return 1;
			/* } */ case 9:
		case 1:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.Continue }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.context = context; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.Continue = function(context) { return this.$val.Continue(context); };
	Node.ptr.prototype.AcceptLines = function() {
		var _1, n;
		n = this;
		_1 = n.typ;
		if ((_1 === (1)) || (_1 === (11)) || (_1 === (9)) || (_1 === (106)) || (_1 === (300))) {
			return true;
		}
		return false;
	};
	Node.prototype.AcceptLines = function() { return this.$val.AcceptLines(); };
	Node.ptr.prototype.CanContain = function(nodeType$1) {
		var _1, n, nodeType$1;
		n = this;
		_1 = n.typ;
		if ((_1 === (11)) || (_1 === (9)) || (_1 === (1)) || (_1 === (4)) || (_1 === (106)) || (_1 === (300))) {
			return false;
		} else if (_1 === (7)) {
			return 8 === nodeType$1;
		}
		return !((8 === nodeType$1));
	};
	Node.prototype.CanContain = function(nodeType$1) { return this.$val.CanContain(nodeType$1); };
	Node.ptr.prototype.Unlink = function() {
		var n;
		n = this;
		if (!(ptrType.nil === n.previous)) {
			n.previous.next = n.next;
		} else if (!(ptrType.nil === n.parent)) {
			n.parent.firstChild = n.next;
		}
		if (!(ptrType.nil === n.next)) {
			n.next.previous = n.previous;
		} else if (!(ptrType.nil === n.parent)) {
			n.parent.lastChild = n.previous;
		}
		n.parent = ptrType.nil;
		n.next = ptrType.nil;
		n.previous = ptrType.nil;
	};
	Node.prototype.Unlink = function() { return this.$val.Unlink(); };
	Node.ptr.prototype.RawText = function() {
		var n;
		n = this;
		return n.rawText;
	};
	Node.prototype.RawText = function() { return this.$val.RawText(); };
	Node.ptr.prototype.SetRawText = function(rawText) {
		var n, rawText;
		n = this;
		n.rawText = rawText;
	};
	Node.prototype.SetRawText = function(rawText) { return this.$val.SetRawText(rawText); };
	Node.ptr.prototype.AppendRawText = function(rawText) {
		var n, rawText;
		n = this;
		n.rawText = n.rawText + (rawText);
	};
	Node.prototype.AppendRawText = function(rawText) { return this.$val.AppendRawText(rawText); };
	Node.ptr.prototype.AppendTokens = function(tokens) {
		var n, tokens;
		n = this;
		n.tokens = $appendSlice(n.tokens, tokens);
	};
	Node.prototype.AppendTokens = function(tokens) { return this.$val.AppendTokens(tokens); };
	Node.ptr.prototype.InsertAfter = function(sibling) {
		var n, sibling;
		n = this;
		sibling.Unlink();
		sibling.next = n.next;
		if (!(ptrType.nil === sibling.next)) {
			sibling.next.previous = sibling;
		}
		sibling.previous = n;
		n.next = sibling;
		sibling.parent = n.parent;
		if (ptrType.nil === sibling.next) {
			sibling.parent.lastChild = sibling;
		}
	};
	Node.prototype.InsertAfter = function(sibling) { return this.$val.InsertAfter(sibling); };
	Node.ptr.prototype.InsertBefore = function(sibling) {
		var n, sibling;
		n = this;
		sibling.Unlink();
		sibling.previous = n.previous;
		if (!(ptrType.nil === sibling.previous)) {
			sibling.previous.next = sibling;
		}
		sibling.next = n;
		n.previous = sibling;
		sibling.parent = n.parent;
		if (ptrType.nil === sibling.previous) {
			sibling.parent.firstChild = sibling;
		}
	};
	Node.prototype.InsertBefore = function(sibling) { return this.$val.InsertBefore(sibling); };
	Node.ptr.prototype.AppendChild = function(child) {
		var child, n;
		n = this;
		child.Unlink();
		child.parent = n;
		if (!(ptrType.nil === n.lastChild)) {
			n.lastChild.next = child;
			child.previous = n.lastChild;
			n.lastChild = child;
		} else {
			n.firstChild = child;
			n.lastChild = child;
		}
	};
	Node.prototype.AppendChild = function(child) { return this.$val.AppendChild(child); };
	Node.ptr.prototype.PrependChild = function(child) {
		var child, n;
		n = this;
		child.Unlink();
		child.parent = n;
		if (!(ptrType.nil === n.firstChild)) {
			n.firstChild.previous = child;
			child.next = n.firstChild;
			n.firstChild = child;
		} else {
			n.firstChild = child;
			n.lastChild = child;
		}
	};
	Node.prototype.PrependChild = function(child) { return this.$val.PrependChild(child); };
	Node.ptr.prototype.List = function() {
		var _r, n, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = [ret];
		ret[0] = sliceType$8.nil;
		n = this;
		ret[0] = $makeSlice(sliceType$8, 0, 512);
		_r = Walk(n, (function(ret) { return function(n$1, entering) {
			var _tmp, _tmp$1, e, entering, n$1, status;
			status = 0;
			e = $ifaceNil;
			if (entering) {
				ret[0] = $append(ret[0], n$1);
			}
			_tmp = 2;
			_tmp$1 = $ifaceNil;
			status = _tmp;
			e = _tmp$1;
			return [status, e];
		}; })(ret)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return ret[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.List }; } $f._r = _r; $f.n = n; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.List = function() { return this.$val.List(); };
	Node.ptr.prototype.isMarker = function() {
		var _1, n;
		n = this;
		_1 = n.typ;
		if ((_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (23)) || (_1 === (24)) || (_1 === (25)) || (_1 === (26)) || (_1 === (102)) || (_1 === (103)) || (_1 === (104)) || (_1 === (105))) {
			return true;
		}
		return false;
	};
	Node.prototype.isMarker = function() { return this.$val.isMarker(); };
	nodeType.prototype.String = function() {
		var typ;
		typ = this.$val;
		return strconv.Itoa(((typ >> 0)));
	};
	$ptrType(nodeType).prototype.String = function() { return new nodeType(this.$get()).String(); };
	recoverPanic = function(err) {
		var err;
	};
	Node.ptr.prototype.paragraphContinue = function(context) {
		var context, p;
		p = this;
		if (context.blank) {
			return 1;
		}
		return 0;
	};
	Node.prototype.paragraphContinue = function(context) { return this.$val.paragraphContinue(context); };
	Node.ptr.prototype.paragraphFinalize = function(context) {
		var _r, context, hasReferenceDefs, listItem, nextTr, p, table, taskListItemMarker, tokens, tr, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; context = $f.context; hasReferenceDefs = $f.hasReferenceDefs; listItem = $f.listItem; nextTr = $f.nextTr; p = $f.p; table = $f.table; taskListItemMarker = $f.taskListItemMarker; tokens = $f.tokens; tr = $f.tr; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.tokens = trimWhitespace(p.tokens);
		hasReferenceDefs = false;
		tokens = p.tokens;
		/* while (true) { */ case 1:
			/* if (!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { break; } */ if(!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { $s = 2; continue; }
			_r = context.parseLinkRefDef(tokens); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tokens = _r;
			if (!(sliceType.nil === tokens)) {
				p.tokens = tokens;
				hasReferenceDefs = true;
				tokens = p.tokens;
				/* continue; */ $s = 1; continue;
			}
			/* break; */ $s = 2; continue;
		/* } */ $s = 1; continue; case 2:
		if (hasReferenceDefs && isBlankLine(p.tokens)) {
			p.Unlink();
		}
		if (context.option.GFMTaskListItem) {
			listItem = p.parent;
			if (!(ptrType.nil === listItem) && (8 === listItem.typ)) {
				if ((3 === listItem.listData.typ) && 3 < p.tokens.$length && isWhitespace((x = p.tokens, (3 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 3])))) {
					taskListItemMarker = new Node.ptr(100, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", $subslice(p.tokens, 0, 3), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, listItem.listData.checked, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
					p.InsertBefore(taskListItemMarker);
					p.tokens = $subslice(p.tokens, 3);
				}
			}
		}
		if (context.option.GFMTable) {
			table = context.parseTable(p);
			if (!(ptrType.nil === table)) {
				p.typ = 106;
				p.tableAligns = table.tableAligns;
				tr = table.firstChild;
				while (true) {
					if (!(!(ptrType.nil === tr))) { break; }
					nextTr = tr.next;
					p.AppendChild(tr);
					tr = nextTr;
				}
				p.tokens = sliceType.nil;
			}
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.paragraphFinalize }; } $f._r = _r; $f.context = context; $f.hasReferenceDefs = hasReferenceDefs; $f.listItem = listItem; $f.nextTr = nextTr; $f.p = p; $f.table = table; $f.taskListItemMarker = taskListItemMarker; $f.tokens = tokens; $f.tr = tr; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.paragraphFinalize = function(context) { return this.$val.paragraphFinalize(context); };
	Lute.ptr.prototype.parse = function(name, markdown) {
		var err, lute, markdown, name, tree, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; lute = $f.lute; markdown = $f.markdown; name = $f.name; tree = $f.tree; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = [err];
		tree = ptrType$11.nil;
		err[0] = $ifaceNil;
		lute = this;
		$deferred.push([recoverPanic, [(err.$ptr || (err.$ptr = new ptrType$6(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, err)))]]);
		tree = new Tree.ptr(name, ptrType.nil, ptrType$8.nil, new Context.ptr(ptrType$11.nil, lute.options, false, ptrType.nil, ptrType.nil, sliceType.nil, 0, 0, 0, 0, 0, 0, 0, false, false, false, false, ptrType.nil), ptrType$14.nil);
		tree.context.tree = tree;
		tree.lexer = newLexer(markdown);
		tree.Root = new Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		$r = tree.parseBlocks(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = tree.parseInlines(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		tree.lexer = ptrType$8.nil;
		$s = -1; return [tree, err[0]];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [tree, err[0]]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.parse }; } $f.err = err; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.tree = tree; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Lute.prototype.parse = function(name, markdown) { return this.$val.parse(name, markdown); };
	Context.ptr.prototype.advanceOffset = function(count, columns) {
		var _r, _tmp, _tmp$1, c, charsToAdvance, charsToTab, columns, context, count, currentLine, x;
		context = this;
		currentLine = context.currentLine;
		_tmp = 0;
		_tmp$1 = 0;
		charsToTab = _tmp;
		charsToAdvance = _tmp$1;
		c = 0;
		while (true) {
			if (!(0 < count)) { break; }
			c = (x = context.offset, ((x < 0 || x >= currentLine.$length) ? ($throwRuntimeError("index out of range"), undefined) : currentLine.$array[currentLine.$offset + x]));
			if (9 === c) {
				charsToTab = 4 - ((_r = context.column % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))) >> 0;
				if (columns) {
					context.partiallyConsumedTab = charsToTab > count;
					if (context.partiallyConsumedTab) {
						charsToAdvance = count;
					} else {
						charsToAdvance = charsToTab;
						context.offset = context.offset + (1) >> 0;
					}
					context.column = context.column + (charsToAdvance) >> 0;
					count = count - (charsToAdvance) >> 0;
				} else {
					context.partiallyConsumedTab = false;
					context.column = context.column + (charsToTab) >> 0;
					context.offset = context.offset + (1) >> 0;
					count = count - (1) >> 0;
				}
			} else {
				context.partiallyConsumedTab = false;
				context.offset = context.offset + (1) >> 0;
				context.column = context.column + (1) >> 0;
				count = count - (1) >> 0;
			}
		}
	};
	Context.prototype.advanceOffset = function(count, columns) { return this.$val.advanceOffset(count, columns); };
	Context.ptr.prototype.advanceNextNonspace = function() {
		var context;
		context = this;
		context.offset = context.nextNonspace;
		context.column = context.nextNonspaceColumn;
		context.partiallyConsumedTab = false;
	};
	Context.prototype.advanceNextNonspace = function() { return this.$val.advanceNextNonspace(); };
	Context.ptr.prototype.findNextNonspace = function() {
		var _r, cols, context, i, token, x;
		context = this;
		i = context.offset;
		cols = context.column;
		token = 0;
		while (true) {
			token = (x = context.currentLine, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (32 === token) {
				i = i + (1) >> 0;
				cols = cols + (1) >> 0;
			} else if (9 === token) {
				i = i + (1) >> 0;
				cols = cols + ((4 - ((_r = cols % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))) >> 0)) >> 0;
			} else {
				break;
			}
		}
		context.blank = 10 === token;
		context.nextNonspace = i;
		context.nextNonspaceColumn = cols;
		context.indent = context.nextNonspaceColumn - context.column >> 0;
		context.indented = context.indent >= 4;
	};
	Context.prototype.findNextNonspace = function() { return this.$val.findNextNonspace(); };
	Context.ptr.prototype.closeUnmatchedBlocks = function() {
		var context, parent, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; context = $f.context; parent = $f.parent; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		context = this;
		/* */ if (!context.allClosed) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!context.allClosed) { */ case 1:
			/* while (true) { */ case 3:
				/* if (!(!(context.oldtip === context.lastMatchedContainer))) { break; } */ if(!(!(context.oldtip === context.lastMatchedContainer))) { $s = 4; continue; }
				parent = context.oldtip.parent;
				$r = context.finalize(context.oldtip, context.lineNum - 1 >> 0); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				context.oldtip = parent;
			/* } */ $s = 3; continue; case 4:
			context.allClosed = true;
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.closeUnmatchedBlocks }; } $f.context = context; $f.parent = parent; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.closeUnmatchedBlocks = function() { return this.$val.closeUnmatchedBlocks(); };
	Context.ptr.prototype.finalize = function(block, lineNum) {
		var block, context, lineNum, parent, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; block = $f.block; context = $f.context; lineNum = $f.lineNum; parent = $f.parent; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		context = this;
		parent = block.parent;
		block.close = true;
		$r = block.Finalize(context); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		context.tip = parent;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.finalize }; } $f.block = block; $f.context = context; $f.lineNum = lineNum; $f.parent = parent; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.finalize = function(block, lineNum) { return this.$val.finalize(block, lineNum); };
	Context.ptr.prototype.addChildMarker = function(nodeType$1, tokens) {
		var context, nodeType$1, ret, tokens;
		ret = ptrType.nil;
		context = this;
		ret = new Node.ptr(nodeType$1, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", tokens, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		context.tip.AppendChild(ret);
		ret = ret;
		return ret;
	};
	Context.prototype.addChildMarker = function(nodeType$1, tokens) { return this.$val.addChildMarker(nodeType$1, tokens); };
	Context.ptr.prototype.addChild = function(nodeType$1, offset) {
		var context, nodeType$1, offset, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; context = $f.context; nodeType$1 = $f.nodeType$1; offset = $f.offset; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = ptrType.nil;
		context = this;
		/* while (true) { */ case 1:
			/* if (!(!context.tip.CanContain(nodeType$1))) { break; } */ if(!(!context.tip.CanContain(nodeType$1))) { $s = 2; continue; }
			$r = context.finalize(context.tip, context.lineNum - 1 >> 0); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		ret = new Node.ptr(nodeType$1, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		context.tip.AppendChild(ret);
		context.tip = ret;
		ret = ret;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.addChild }; } $f.context = context; $f.nodeType$1 = nodeType$1; $f.offset = offset; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.addChild = function(nodeType$1, offset) { return this.$val.addChild(nodeType$1, offset); };
	Context.ptr.prototype.listsMatch = function(listData$1, itemData) {
		var context, itemData, listData$1;
		context = this;
		return (listData$1.typ === itemData.typ) && (((0 === listData$1.delimiter) && (0 === itemData.delimiter)) || (listData$1.delimiter === itemData.delimiter)) && bytes.Equal(listData$1.bulletChar, itemData.bulletChar);
	};
	Context.prototype.listsMatch = function(listData$1, itemData) { return this.$val.listsMatch(listData$1, itemData); };
	Lute.ptr.prototype.newBaseRenderer = function(tree) {
		var lute, ret, tree;
		lute = this;
		ret = new BaseRenderer.ptr(ptrType$4.nil, 0, $makeMap(nodeType.keyFor, []), $throwNilPointerError, 0, lute.options, tree);
		ret.writer = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
		ret.writer.Grow(4096);
		return ret;
	};
	Lute.prototype.newBaseRenderer = function(tree) { return this.$val.newBaseRenderer(tree); };
	BaseRenderer.ptr.prototype.Render = function() {
		var _r, err, output, r, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; output = $f.output; r = $f.r; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = [err];
		r = [r];
		output = sliceType.nil;
		err[0] = $ifaceNil;
		r[0] = this;
		$deferred.push([recoverPanic, [(err.$ptr || (err.$ptr = new ptrType$6(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, err)))]]);
		r[0].lastOut = 10;
		r[0].writer = new bytes.Buffer.ptr(sliceType.nil, 0, 0);
		r[0].writer.Grow(4096);
		_r = Walk(r[0].tree.Root, (function(err, r) { return function $b(n, entering) {
			var _entry, _r, _r$1, entering, f, n, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _r$1 = $f._r$1; entering = $f.entering; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			f = (_entry = r[0].rendererFuncs[nodeType.keyFor(n.typ)], _entry !== undefined ? _entry.v : $throwNilPointerError);
			/* */ if ($throwNilPointerError === f) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if ($throwNilPointerError === f) { */ case 1:
				/* */ if (!($throwNilPointerError === r[0].defaultRendererFunc)) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (!($throwNilPointerError === r[0].defaultRendererFunc)) { */ case 3:
					_r = r[0].defaultRendererFunc(n, entering); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					$s = -1; return _r;
				/* } else { */ case 4:
					$s = -1; return r[0].renderDefault(n, entering);
				/* } */ case 5:
			/* } */ case 2:
			_r$1 = f(n, entering); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._entry = _entry; $f._r = _r; $f._r$1 = _r$1; $f.entering = entering; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
		}; })(err, r)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err[0] = _r;
		if (!($interfaceIsEqual($ifaceNil, err[0]))) {
			$s = -1; return [output, err[0]];
		}
		output = r[0].writer.Bytes();
		$s = -1; return [output, err[0]];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [output, err[0]]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: BaseRenderer.ptr.prototype.Render }; } $f._r = _r; $f.err = err; $f.output = output; $f.r = r; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	BaseRenderer.prototype.Render = function() { return this.$val.Render(); };
	BaseRenderer.ptr.prototype.renderDefault = function(n, entering) {
		var entering, n, r;
		r = this;
		return [0, errors.New("not found render function for node [type=" + new nodeType(n.typ).String() + ", tokens=" + bytesToStr(n.tokens) + "]")];
	};
	BaseRenderer.prototype.renderDefault = function(n, entering) { return this.$val.renderDefault(n, entering); };
	BaseRenderer.ptr.prototype.writeByte = function(c) {
		var c, r;
		r = this;
		r.writer.WriteByte(c);
		r.lastOut = c;
	};
	BaseRenderer.prototype.writeByte = function(c) { return this.$val.writeByte(c); };
	BaseRenderer.ptr.prototype.writeBytes = function(bytes$1) {
		var bytes$1, length, r, x;
		r = this;
		length = bytes$1.$length;
		if (0 < length) {
			r.writer.Write(bytes$1);
			r.lastOut = (x = length - 1 >> 0, ((x < 0 || x >= bytes$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : bytes$1.$array[bytes$1.$offset + x]));
		}
	};
	BaseRenderer.prototype.writeBytes = function(bytes$1) { return this.$val.writeBytes(bytes$1); };
	BaseRenderer.ptr.prototype.write = function(content) {
		var content, length, r, x;
		r = this;
		length = content.$length;
		if (0 < length) {
			r.writer.Write(content);
			r.lastOut = (x = length - 1 >> 0, ((x < 0 || x >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + x]));
		}
	};
	BaseRenderer.prototype.write = function(content) { return this.$val.write(content); };
	BaseRenderer.ptr.prototype.writeString = function(content) {
		var content, length, r;
		r = this;
		length = content.length;
		if (0 < length) {
			r.writer.WriteString(content);
			r.lastOut = content.charCodeAt((length - 1 >> 0));
		}
	};
	BaseRenderer.prototype.writeString = function(content) { return this.$val.writeString(content); };
	BaseRenderer.ptr.prototype.newline = function() {
		var r;
		r = this;
		if (!((10 === r.lastOut))) {
			r.writer.WriteByte(10);
			r.lastOut = 10;
		}
	};
	BaseRenderer.prototype.newline = function() { return this.$val.newline(); };
	BaseRenderer.ptr.prototype.space = function(textNode) {
		var r, text, textNode;
		r = this;
		text = bytesToStr(textNode.tokens);
		text = space0(text);
		textNode.tokens = strToBytes(text);
	};
	BaseRenderer.prototype.space = function(textNode) { return this.$val.space(textNode); };
	space0 = function(text) {
		var _i, _ref, _rune, r, ret, text;
		ret = "";
		_ref = text;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			r = _rune[0];
			ret = addSpaceAtBoundary(ret, r);
			_i += _rune[1];
		}
		return ret;
	};
	addSpaceAtBoundary = function(prefix, nextChar) {
		var _tuple, currentChar, nextChar, prefix;
		if (0 === prefix.length) {
			return ($encodeRune(nextChar));
		}
		if (unicode.IsSpace(nextChar) || !unicode.IsPrint(nextChar)) {
			return prefix + ($encodeRune(nextChar));
		}
		_tuple = utf8.DecodeLastRuneInString(prefix);
		currentChar = _tuple[0];
		if (isAllowSpace(currentChar, nextChar)) {
			return prefix + " " + ($encodeRune(nextChar));
		}
		return prefix + ($encodeRune(nextChar));
	};
	isAllowSpace = function(currentChar, nextChar) {
		var currentChar, currentIsASCII, currentIsDigit, currentIsLetter, currentIsPunct, currentIsSymbol, nextChar, nextIsASCII, nextIsDigit, nextIsLetter, nextIsPunct, nextIsSymbol;
		if (unicode.IsSpace(currentChar) || !unicode.IsPrint(currentChar)) {
			return false;
		}
		currentIsASCII = 128 > currentChar;
		nextIsASCII = 128 > nextChar;
		currentIsLetter = unicode.IsLetter(currentChar);
		nextIsLetter = unicode.IsLetter(nextChar);
		if (currentIsASCII === nextIsASCII && currentIsLetter && nextIsLetter) {
			return false;
		}
		if ((currentIsLetter && ((65509 === nextChar) || (8451 === nextChar))) || (((65509 === currentChar) || (8451 === currentChar)) && nextIsLetter)) {
			return true;
		}
		if (((37 === currentChar) && nextIsLetter) || (currentIsLetter && (37 === nextChar))) {
			return true;
		}
		currentIsDigit = 48 <= currentChar && 57 >= currentChar;
		nextIsDigit = 48 <= nextChar && 57 >= nextChar;
		nextIsSymbol = unicode.IsSymbol(nextChar);
		currentIsPunct = unicode.IsPunct(currentChar);
		nextIsPunct = unicode.IsPunct(nextChar);
		if (currentIsASCII) {
			if (currentIsDigit && nextIsSymbol) {
				return false;
			}
			if (currentIsPunct && nextIsLetter) {
				return false;
			}
			if (nextIsPunct || nextIsSymbol) {
				return false;
			}
			return !nextIsASCII;
		} else {
			if (currentIsPunct) {
				return false;
			}
			if (nextIsSymbol) {
				return true;
			}
			currentIsSymbol = unicode.IsSymbol(currentChar);
			if (currentIsSymbol && (nextIsDigit || nextIsPunct || !nextIsASCII)) {
				return false;
			}
			if (currentIsLetter && nextIsPunct) {
				return false;
			}
			return true;
		}
	};
	Context.ptr.prototype.parseTable = function(paragraph) {
		var aligns, context, headRow, i, length, lines, paragraph, ret, tableRow;
		ret = ptrType.nil;
		context = this;
		lines = split(paragraph.tokens, 10);
		length = lines.$length;
		if (2 > length) {
			return ret;
		}
		aligns = context.parseTableDelimRow(trimWhitespace((1 >= lines.$length ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + 1])));
		if (sliceType$3.nil === aligns) {
			return ret;
		}
		headRow = context.parseTableRow(trimWhitespace((0 >= lines.$length ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + 0])), aligns, true);
		if (ptrType.nil === headRow) {
			return ret;
		}
		ret = new Node.ptr(106, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, aligns, 0, 0, 0, 0, false, "", "");
		ret.tableAligns = aligns;
		ret.AppendChild(context.newTableHead(headRow));
		i = 2;
		while (true) {
			if (!(i < length)) { break; }
			tableRow = context.parseTableRow(trimWhitespace(((i < 0 || i >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + i])), aligns, false);
			if (ptrType.nil === tableRow) {
				return ret;
			}
			ret.AppendChild(tableRow);
			i = i + (1) >> 0;
		}
		return ret;
	};
	Context.prototype.parseTable = function(paragraph) { return this.$val.parseTable(paragraph); };
	Context.ptr.prototype.newTableHead = function(headRow) {
		var c, context, headRow, next, ret, tr;
		context = this;
		ret = new Node.ptr(107, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		tr = new Node.ptr(108, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		ret.AppendChild(tr);
		c = headRow.firstChild;
		while (true) {
			if (!(!(ptrType.nil === c))) { break; }
			next = c.next;
			tr.AppendChild(c);
			c = next;
		}
		return ret;
	};
	Context.prototype.newTableHead = function(headRow) { return this.$val.newTableHead(headRow); };
	Context.ptr.prototype.parseTableRow = function(line, aligns, isHead) {
		var aligns, alignsLen, cell, cell$1, col, cols, colsLen, context, i, i$1, isHead, length, line, ret, token, x, x$1;
		ret = ptrType.nil;
		context = this;
		ret = new Node.ptr(108, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, aligns, 0, 0, 0, 0, false, "", "");
		cols = splitWithoutBackslashEscape(line, 124);
		if (1 > cols.$length) {
			ret = ptrType.nil;
			return ret;
		}
		if (isBlank((0 >= cols.$length ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + 0]))) {
			cols = $subslice(cols, 1);
		}
		if (cols.$length > 0 && isBlank((x = cols.$length - 1 >> 0, ((x < 0 || x >= cols.$length) ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + x])))) {
			cols = $subslice(cols, 0, (cols.$length - 1 >> 0));
		}
		colsLen = cols.$length;
		alignsLen = aligns.$length;
		if (isHead && colsLen > alignsLen) {
			ret = ptrType.nil;
			return ret;
		}
		i = 0;
		col = sliceType.nil;
		while (true) {
			if (!(i < colsLen && i < alignsLen)) { break; }
			col = trimWhitespace(((i < 0 || i >= cols.$length) ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + i]));
			cell = new Node.ptr(109, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, ((i < 0 || i >= aligns.$length) ? ($throwRuntimeError("index out of range"), undefined) : aligns.$array[aligns.$offset + i]), 0, 0, 0, false, "", "");
			if (!context.option.VditorWYSIWYG) {
				length = col.$length;
				token = 0;
				i$1 = 0;
				while (true) {
					if (!(i$1 < length)) { break; }
					token = ((i$1 < 0 || i$1 >= col.$length) ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + i$1]);
					if ((token === 92) && i$1 < (length - 1 >> 0) && ((x$1 = i$1 + 1 >> 0, ((x$1 < 0 || x$1 >= col.$length) ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + x$1])) === 124)) {
						col = $appendSlice($subslice(col, 0, i$1), $subslice(col, (i$1 + 1 >> 0)));
						length = length - (1) >> 0;
					}
					i$1 = i$1 + (1) >> 0;
				}
			}
			cell.tokens = col;
			ret.AppendChild(cell);
			i = i + (1) >> 0;
		}
		while (true) {
			if (!(i < alignsLen)) { break; }
			cell$1 = new Node.ptr(109, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, ((i < 0 || i >= aligns.$length) ? ($throwRuntimeError("index out of range"), undefined) : aligns.$array[aligns.$offset + i]), 0, 0, 0, false, "", "");
			ret.AppendChild(cell$1);
			i = i + (1) >> 0;
		}
		return ret;
	};
	Context.prototype.parseTableRow = function(line, aligns, isHead) { return this.$val.parseTableRow(line, aligns, isHead); };
	Context.ptr.prototype.parseTableDelimRow = function(line) {
		var _i, _ref, align, alignments, aligns, col, cols, context, i, length, line, token, x;
		aligns = sliceType$3.nil;
		context = this;
		length = line.$length;
		if (1 > length) {
			aligns = sliceType$3.nil;
			return aligns;
		}
		token = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + i]);
			if (!((124 === token)) && !((45 === token)) && !((58 === token)) && !((32 === token))) {
				aligns = sliceType$3.nil;
				return aligns;
			}
			i = i + (1) >> 0;
		}
		cols = splitWithoutBackslashEscape(line, 124);
		if (isBlank((0 >= cols.$length ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + 0]))) {
			cols = $subslice(cols, 1);
		}
		if (cols.$length > 0 && isBlank((x = cols.$length - 1 >> 0, ((x < 0 || x >= cols.$length) ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + x])))) {
			cols = $subslice(cols, 0, (cols.$length - 1 >> 0));
		}
		alignments = sliceType$3.nil;
		_ref = cols;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			col = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			col = trimWhitespace(col);
			if (1 > length || sliceType.nil === col) {
				aligns = sliceType$3.nil;
				return aligns;
			}
			align = context.tableDelimAlign(col);
			if (-1 === align) {
				aligns = sliceType$3.nil;
				return aligns;
			}
			alignments = $append(alignments, align);
			_i++;
		}
		aligns = alignments;
		return aligns;
	};
	Context.prototype.parseTableDelimRow = function(line) { return this.$val.parseTableDelimRow(line); };
	Context.ptr.prototype.tableDelimAlign = function(col) {
		var _tmp, _tmp$1, col, context, first, i, last, left, length, right, token, x;
		context = this;
		length = col.$length;
		if (1 > length) {
			return -1;
		}
		_tmp = false;
		_tmp$1 = false;
		left = _tmp;
		right = _tmp$1;
		first = (0 >= col.$length ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + 0]);
		left = 58 === first;
		last = (x = length - 1 >> 0, ((x < 0 || x >= col.$length) ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + x]));
		right = 58 === last;
		i = 1;
		token = 0;
		while (true) {
			if (!(i < (length - 1 >> 0))) { break; }
			token = ((i < 0 || i >= col.$length) ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + i]);
			if (!((45 === token))) {
				return -1;
			}
			i = i + (1) >> 0;
		}
		if (left && right) {
			return 2;
		}
		if (left) {
			return 1;
		}
		if (right) {
			return 3;
		}
		return 0;
	};
	Context.prototype.tableDelimAlign = function(col) { return this.$val.tableDelimAlign(col); };
	BaseRenderer.ptr.prototype.fixTermTypo = function(textNode) {
		var _r, r, textNode, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; textNode = $f.textNode; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.fixTermTypo0(textNode.tokens); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		textNode.tokens = _r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: BaseRenderer.ptr.prototype.fixTermTypo }; } $f._r = _r; $f.r = r; $f.textNode = textNode; $f.$s = $s; $f.$r = $r; return $f;
	};
	BaseRenderer.prototype.fixTermTypo = function(textNode) { return this.$val.fixTermTypo(textNode); };
	BaseRenderer.ptr.prototype.fixTermTypo0 = function(tokens) {
		var _entry, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, after, before, i, j, k, l, length, ok, originalTerm, r, to, token, tokens, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; after = $f.after; before = $f.before; i = $f.i; j = $f.j; k = $f.k; l = $f.l; length = $f.length; ok = $f.ok; originalTerm = $f.originalTerm; r = $f.r; to = $f.to; token = $f.token; tokens = $f.tokens; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		length = tokens.$length;
		token = 0;
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		_tmp$3 = 0;
		i = _tmp;
		j = _tmp$1;
		k = _tmp$2;
		l = _tmp$3;
		_tmp$4 = 0;
		_tmp$5 = 0;
		before = _tmp$4;
		after = _tmp$5;
		originalTerm = sliceType.nil;
		/* while (true) { */ case 1:
			/* if (!(i < length)) { break; } */ if(!(i < length)) { $s = 2; continue; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			/* */ if (isNotTerm(token)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (isNotTerm(token)) { */ case 3:
				i = i + (1) >> 0;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			/* */ if (1 <= i) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (1 <= i) { */ case 5:
				before = (x = i - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]));
				if (!isNotTerm(before)) {
					i = i + (1) >> 0;
					/* continue; */ $s = 1; continue;
				}
			/* } */ case 6:
			/* */ if (isASCIIPunct(before)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (isASCIIPunct(before)) { */ case 7:
				i = i + (1) >> 0;
				/* continue; */ $s = 1; continue;
			/* } */ case 8:
			j = i;
			while (true) {
				if (!(j < length)) { break; }
				after = ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]);
				if (isNotTerm(after) || (46 === after)) {
					break;
				}
				j = j + (1) >> 0;
			}
			/* */ if (isASCIIPunct(after)) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (isASCIIPunct(after)) { */ case 9:
				i = i + (1) >> 0;
				/* continue; */ $s = 1; continue;
			/* } */ case 10:
			_r = bytes.ToLower($subslice(tokens, i, j)); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			originalTerm = _r;
			_tuple = (_entry = r.option.Terms[$String.keyFor(bytesToStr(originalTerm))], _entry !== undefined ? [_entry.v, true] : ["", false]);
			to = _tuple[0];
			ok = _tuple[1];
			if (ok) {
				l = 0;
				k = i;
				while (true) {
					if (!(k < j)) { break; }
					((k < 0 || k >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + k] = to.charCodeAt(l));
					l = l + (1) >> 0;
					k = k + (1) >> 0;
				}
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return tokens;
		/* */ } return; } if ($f === undefined) { $f = { $blk: BaseRenderer.ptr.prototype.fixTermTypo0 }; } $f._entry = _entry; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.after = after; $f.before = before; $f.i = i; $f.j = j; $f.k = k; $f.l = l; $f.length = length; $f.ok = ok; $f.originalTerm = originalTerm; $f.r = r; $f.to = to; $f.token = token; $f.tokens = tokens; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	BaseRenderer.prototype.fixTermTypo0 = function(tokens) { return this.$val.fixTermTypo0(tokens); };
	isNotTerm = function(token) {
		var token;
		return token >= 128 || isWhitespace(token) || isASCIIPunct(token);
	};
	newTerms = function() {
		var _entry, _i, _key, _keys, _ref, k, ret, v, x;
		ret = false;
		ret = (x = $keys(terms).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = terms;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (ret || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_i++;
		}
		return ret;
	};
	Tree.ptr.prototype.mergeText = function(node) {
		var child, next, node, t;
		t = this;
		child = node.firstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.next;
			if (16 === child.typ) {
				while (true) {
					if (!(!(ptrType.nil === next) && (16 === next.typ))) { break; }
					child.AppendTokens(next.tokens);
					next.Unlink();
					next = child.next;
				}
			} else {
				t.mergeText(child);
			}
			child = next;
		}
	};
	Tree.prototype.mergeText = function(node) { return this.$val.mergeText(node); };
	Tree.ptr.prototype.parseThematicBreak = function() {
		var _tmp, _tmp$1, i, marker, markerCnt, markers$1, ok, t, term, token, x, x$1;
		ok = false;
		markers$1 = sliceType.nil;
		t = this;
		markerCnt = 0;
		marker = 0;
		i = t.context.nextNonspace;
		while (true) {
			if (!(i < (t.context.currentLineLen - 1 >> 0))) { break; }
			token = (x = t.context.currentLine, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			term = token;
			markers$1 = $append(markers$1, (x$1 = t.context.currentLine, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])));
			if ((32 === term) || (9 === term)) {
				i = i + (1) >> 0;
				continue;
			}
			if (!((45 === term)) && !((95 === term)) && !((42 === term))) {
				return [ok, markers$1];
			}
			if (!((0 === marker))) {
				if (!((marker === term))) {
					return [ok, markers$1];
				}
			} else {
				marker = term;
			}
			markerCnt = markerCnt + (1) >> 0;
			i = i + (1) >> 0;
		}
		_tmp = 3 <= markerCnt;
		_tmp$1 = markers$1;
		ok = _tmp;
		markers$1 = _tmp$1;
		return [ok, markers$1];
	};
	Tree.prototype.parseThematicBreak = function() { return this.$val.parseThematicBreak(); };
	isWhitespace = function(token) {
		var token;
		return (32 === token) || (10 === token) || (9 === token) || (11 === token) || (12 === token) || (13 === token);
	};
	isUnicodeWhitespace = function(r) {
		var r;
		return unicode.IsSpace(r) || unicode.Is(unicode.Zs, r);
	};
	isDigit = function(token) {
		var token;
		return 48 <= token && 57 >= token;
	};
	isHexDigit = function(token) {
		var token;
		return isDigit(token) || token >= 97 && token <= 102 || token >= 65 && token <= 70;
	};
	tokenToUpper = function(token) {
		var token;
		if (token >= 97 && token <= 122) {
			return (token - 97 << 24 >>> 24) + 65 << 24 >>> 24;
		}
		return token;
	};
	isASCIIPunct = function(token) {
		var token;
		return (33 <= token && 47 >= token) || (58 <= token && 64 >= token) || (91 <= token && 96 >= token) || (123 <= token && 126 >= token);
	};
	isASCIILetter = function(token) {
		var token;
		return (65 <= token && 90 >= token) || (97 <= token && 122 >= token);
	};
	isASCIILetterNum = function(token) {
		var token;
		return (65 <= token && 90 >= token) || (97 <= token && 122 >= token) || (48 <= token && 57 >= token);
	};
	isASCIILetterNumHyphen = function(token) {
		var token;
		return (65 <= token && 90 >= token) || (97 <= token && 122 >= token) || (48 <= token && 57 >= token) || (45 === token);
	};
	isControl = function(token) {
		var token;
		return unicode.IsControl(((token >> 0)));
	};
	isBlank = function(tokens) {
		var _i, _ref, token, tokens;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((32 === token))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	split = function(tokens, separator) {
		var i, length, line, ret, separator, token, tokens;
		ret = sliceType$1.nil;
		length = tokens.$length;
		i = 0;
		token = 0;
		line = sliceType.nil;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!((separator === token))) {
				line = $append(line, token);
				i = i + (1) >> 0;
				continue;
			}
			ret = $append(ret, line);
			line = new sliceType([]);
			i = i + (1) >> 0;
		}
		if (0 < line.$length) {
			ret = $append(ret, line);
		}
		return ret;
	};
	splitWithoutBackslashEscape = function(tokens, separator) {
		var i, length, line, ret, separator, token, tokens;
		ret = sliceType$1.nil;
		length = tokens.$length;
		i = 0;
		token = 0;
		line = sliceType.nil;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!((separator === token)) || isBackslashEscapePunct(tokens, i)) {
				line = $append(line, token);
				i = i + (1) >> 0;
				continue;
			}
			ret = $append(ret, line);
			line = new sliceType([]);
			i = i + (1) >> 0;
		}
		if (0 < line.$length) {
			ret = $append(ret, line);
		}
		return ret;
	};
	replaceNewlineSpace = function(tokens) {
		var i, length, token, tokens, x;
		length = tokens.$length;
		token = 0;
		i = length - 1 >> 0;
		while (true) {
			if (!(0 <= i)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!((10 === token)) && !((32 === token))) {
				break;
			}
			if ((10 === (x = i - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) && ((32 === token) || (10 === token))) {
				tokens = $subslice(tokens, 0, i);
			}
			i = i - (1) >> 0;
		}
		return tokens;
	};
	trimWhitespace = function(tokens) {
		var _tuple, ret, tokens;
		ret = sliceType.nil;
		_tuple = trim(tokens);
		ret = _tuple[2];
		return ret;
	};
	trim = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, end, leftWhitespaces, length, remains, rightWhitespaces, start, tokens;
		leftWhitespaces = sliceType.nil;
		rightWhitespaces = sliceType.nil;
		remains = sliceType.nil;
		length = tokens.$length;
		if (0 === length) {
			_tmp = sliceType.nil;
			_tmp$1 = sliceType.nil;
			_tmp$2 = tokens;
			leftWhitespaces = _tmp;
			rightWhitespaces = _tmp$1;
			remains = _tmp$2;
			return [leftWhitespaces, rightWhitespaces, remains];
		}
		_tmp$3 = 0;
		_tmp$4 = length - 1 >> 0;
		start = _tmp$3;
		end = _tmp$4;
		while (true) {
			if (!(start < length)) { break; }
			if (!isWhitespace(((start < 0 || start >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + start]))) {
				break;
			}
			start = start + (1) >> 0;
		}
		leftWhitespaces = $subslice(tokens, 0, start);
		if (start === length) {
			start = start - (1) >> 0;
		}
		while (true) {
			if (!(0 <= end)) { break; }
			if (!isWhitespace(((end < 0 || end >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + end]))) {
				break;
			}
			end = end - (1) >> 0;
		}
		if (end < start) {
			end = start - 1 >> 0;
		}
		if (0 < end) {
			rightWhitespaces = $subslice(tokens, (end + 1 >> 0), length);
		}
		remains = $subslice(tokens, start, (end + 1 >> 0));
		return [leftWhitespaces, rightWhitespaces, remains];
	};
	trimRight = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, length, remains, tokens, whitespaces;
		whitespaces = sliceType.nil;
		remains = sliceType.nil;
		length = tokens.$length;
		if (1 > length) {
			_tmp = sliceType.nil;
			_tmp$1 = tokens;
			whitespaces = _tmp;
			remains = _tmp$1;
			return [whitespaces, remains];
		}
		i = length - 1 >> 0;
		while (true) {
			if (!(0 <= i)) { break; }
			if (!isWhitespace(((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]))) {
				break;
			}
			whitespaces = $append(whitespaces, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			i = i - (1) >> 0;
		}
		_tmp$2 = whitespaces;
		_tmp$3 = $subslice(tokens, 0, (i + 1 >> 0));
		whitespaces = _tmp$2;
		remains = _tmp$3;
		return [whitespaces, remains];
	};
	trimLeft = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, length, remains, tokens, whitespaces;
		whitespaces = sliceType.nil;
		remains = sliceType.nil;
		length = tokens.$length;
		if (1 > length) {
			_tmp = sliceType.nil;
			_tmp$1 = tokens;
			whitespaces = _tmp;
			remains = _tmp$1;
			return [whitespaces, remains];
		}
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			if (!isWhitespace(((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]))) {
				break;
			}
			whitespaces = $append(whitespaces, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			i = i + (1) >> 0;
		}
		_tmp$2 = whitespaces;
		_tmp$3 = $subslice(tokens, i);
		whitespaces = _tmp$2;
		remains = _tmp$3;
		return [whitespaces, remains];
	};
	accept = function(tokens, token) {
		var length, pos, token, tokens;
		pos = 0;
		length = tokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			if (!((token === ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos])))) {
				break;
			}
			pos = pos + (1) >> 0;
		}
		return pos;
	};
	acceptTokenss = function(tokens, someTokenss) {
		var i, j, length, length2, pos, remains, someTokens, someTokenss, tokens;
		pos = 0;
		length = tokens.$length;
		length2 = someTokenss.$length;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			remains = $subslice(tokens, i);
			j = 0;
			while (true) {
				if (!(j < length2)) { break; }
				someTokens = ((j < 0 || j >= someTokenss.$length) ? ($throwRuntimeError("index out of range"), undefined) : someTokenss.$array[someTokenss.$offset + j]);
				pos = acceptTokens(remains, someTokens);
				if (0 <= pos) {
					return pos;
				}
				j = j + (1) >> 0;
			}
			i = i + (1) >> 0;
		}
		pos = -1;
		return pos;
	};
	acceptTokens = function(remains, someTokens) {
		var length, pos, remains, someTokens;
		pos = 0;
		length = someTokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			if (!((((pos < 0 || pos >= someTokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : someTokens.$array[someTokens.$offset + pos]) === ((pos < 0 || pos >= remains.$length) ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + pos])))) {
				pos = -1;
				return pos;
			}
			pos = pos + (1) >> 0;
		}
		return pos;
	};
	isBlankLine = function(tokens) {
		var _i, _ref, token, tokens;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((32 === token)) && !((9 === token)) && !((10 === token))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	splitWhitespace = function(tokens) {
		var _i, _ref, i, lastIsWhitespace, ret, token, tokens;
		ret = sliceType$1.nil;
		i = 0;
		ret = $append(ret, new sliceType([]));
		lastIsWhitespace = false;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (isWhitespace(token)) {
				if (!lastIsWhitespace) {
					i = i + (1) >> 0;
					ret = $append(ret, new sliceType([]));
				}
				lastIsWhitespace = true;
			} else {
				((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i] = $append(((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i]), token));
				lastIsWhitespace = false;
			}
			_i++;
		}
		return ret;
	};
	isBackslashEscapePunct = function(tokens, pos) {
		var _r, backslashes, i, pos, tokens;
		if (!isASCIIPunct(((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]))) {
			return false;
		}
		backslashes = 0;
		i = pos - 1 >> 0;
		while (true) {
			if (!(0 <= i)) { break; }
			if (!((92 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])))) {
				break;
			}
			backslashes = backslashes + (1) >> 0;
			i = i - (1) >> 0;
		}
		return !((0 === (_r = backslashes % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))));
	};
	statWhitespace = function(tokens) {
		var _i, _ref, newlines, spaces, tabs, token, tokens;
		newlines = 0;
		spaces = 0;
		tabs = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (10 === token) {
				newlines = newlines + (1) >> 0;
			} else if (32 === token) {
				spaces = spaces + (1) >> 0;
			} else if (9 === token) {
				tabs = tabs + (1) >> 0;
			}
			_i++;
		}
		return [newlines, spaces, tabs];
	};
	spnl = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tuple, _tuple$1, newlines, passed, remains, ret, tokens;
		ret = false;
		passed = sliceType.nil;
		remains = sliceType.nil;
		_tuple = trimLeft(tokens);
		passed = _tuple[0];
		remains = _tuple[1];
		_tuple$1 = statWhitespace(passed);
		newlines = _tuple$1[0];
		if (1 < newlines) {
			_tmp = false;
			_tmp$1 = sliceType.nil;
			_tmp$2 = tokens;
			ret = _tmp;
			passed = _tmp$1;
			remains = _tmp$2;
			return [ret, passed, remains];
		}
		ret = true;
		return [ret, passed, remains];
	};
	peek = function(tokens, pos) {
		var pos, tokens;
		if (pos < tokens.$length) {
			return ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]);
		}
		return 0;
	};
	unescapeString = function(tokens) {
		var i, length, ret, tokens;
		ret = sliceType.nil;
		if (sliceType.nil === tokens) {
			return ret;
		}
		tokens = strToBytes(htmlUnescapeString(bytesToStr(tokens)));
		length = tokens.$length;
		ret = $makeSlice(sliceType, 0, length);
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			if (isBackslashEscapePunct(tokens, i)) {
				ret = $subslice(ret, 0, (ret.$length - 1 >> 0));
			}
			ret = $append(ret, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			i = i + (1) >> 0;
		}
		return ret;
	};
	htmlUnescapeString = function(s) {
		var _tuple, _tuple$1, anyChanges, b, buf, entityLen, entityStr, i, j, n, s;
		i = strings.IndexByte(s, 38);
		if (i < 0) {
			return s;
		}
		anyChanges = false;
		entityStr = "";
		entityLen = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			if (s.charCodeAt(i) === 38) {
				_tuple = parseEntity($substring(s, i));
				entityStr = _tuple[0];
				entityLen = _tuple[1];
				if (entityLen > 0) {
					anyChanges = true;
					break;
				}
			}
			i = i + (1) >> 0;
		}
		if (!anyChanges) {
			return s;
		}
		buf = $makeSlice(sliceType, ((s.length - entityLen >> 0) + entityStr.length >> 0));
		$copyString($subslice(buf, 0, i), s);
		n = $copyString($subslice(buf, i), entityStr);
		j = i + n >> 0;
		i = i + (entityLen) >> 0;
		while (true) {
			if (!(i < s.length)) { break; }
			b = s.charCodeAt(i);
			if (b === 38) {
				_tuple$1 = parseEntity($substring(s, i));
				entityStr = _tuple$1[0];
				entityLen = _tuple$1[1];
				if (entityLen > 0) {
					n = $copyString($subslice(buf, j), entityStr);
					j = j + (n) >> 0;
					i = i + (entityLen) >> 0;
					continue;
				}
			}
			((j < 0 || j >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + j] = b);
			j = j + (1) >> 0;
			i = i + (1) >> 0;
		}
		return ($bytesToString($subslice(buf, 0, j)));
	};
	parseEntity = function(s) {
		var _1, _entry, _tuple, _tuple$1, _tuple$2, b, c, c$1, e, err, i, n, ok, s, st;
		st = 0;
		n = 0;
		i = 1;
		while (true) {
			if (!(i < s.length)) { break; }
			b = s.charCodeAt(i);
			_1 = st;
			if (_1 === (0)) {
				if ((b === 35)) {
					st = 1;
				} else if (isASCIILetter(b)) {
					n = 1;
					st = 2;
				} else {
					return ["", 0];
				}
			} else if (_1 === (1)) {
				if ((b === 120) || (b === 88)) {
					st = 3;
				} else if (isDigit(b)) {
					n = 1;
					st = 4;
				} else {
					return ["", 0];
				}
			} else if (_1 === (2)) {
				if (isASCIILetterNum(b)) {
					n = n + (1) >> 0;
					if (n > 31) {
						return ["", 0];
					}
				} else if ((b === 59)) {
					_tuple = (_entry = html.Entities[$String.keyFor($substring(s, (i - n >> 0), i))], _entry !== undefined ? [_entry.v, true] : ["", false]);
					e = _tuple[0];
					ok = _tuple[1];
					if (ok) {
						return [e, i + 1 >> 0];
					}
					return ["", 0];
				} else {
					return ["", 0];
				}
			} else if (_1 === (3)) {
				if (isHexDigit(b)) {
					n = 1;
					st = 5;
				} else {
					return ["", 0];
				}
			} else if (_1 === (4)) {
				if (isDigit(b)) {
					n = n + (1) >> 0;
					if (n > 8) {
						return ["", 0];
					}
				} else if ((b === 59)) {
					_tuple$1 = strconv.ParseInt($substring(s, (i - n >> 0), i), 10, 32);
					c = _tuple$1[0];
					if (!isValidEntityCode(c)) {
						return ["\xEF\xBF\xBD", i + 1 >> 0];
					}
					return [($encodeRune((((c.$low + ((c.$high >> 31) * 4294967296)) >> 0)))), i + 1 >> 0];
				} else {
					return ["", 0];
				}
			} else if (_1 === (5)) {
				if (isHexDigit(b)) {
					n = n + (1) >> 0;
					if (n > 8) {
						return ["", 0];
					}
				} else if ((b === 59)) {
					_tuple$2 = strconv.ParseInt($substring(s, (i - n >> 0), i), 16, 32);
					c$1 = _tuple$2[0];
					err = _tuple$2[1];
					if (!($interfaceIsEqual($ifaceNil, err))) {
						return ["\xEF\xBF\xBD", i + 1 >> 0];
					}
					if (!isValidEntityCode(c$1)) {
						return ["\xEF\xBF\xBD", i + 1 >> 0];
					}
					return [($encodeRune((((c$1.$low + ((c$1.$high >> 31) * 4294967296)) >> 0)))), i + 1 >> 0];
				} else {
					return ["", 0];
				}
			}
			i = i + (1) >> 0;
		}
		return ["", 0];
	};
	isValidEntityCode = function(c) {
		var c, x, x$1;
		if (!utf8.ValidRune((((c.$low + ((c.$high >> 31) * 4294967296)) >> 0)))) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 64976)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 65007))) {
			return false;
		} else if ((x = new $Int64(c.$high & 0, (c.$low & 65535) >>> 0), (x.$high === 0 && x.$low === 65535)) || (x$1 = new $Int64(c.$high & 0, (c.$low & 65535) >>> 0), (x$1.$high === 0 && x$1.$low === 65534))) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 0)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 8))) {
			return false;
		} else if ((c.$high === 0 && c.$low === 11)) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 14)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 31))) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 127)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 159))) {
			return false;
		}
		return true;
	};
	Lute.ptr.prototype.RenderVditorDOM = function(htmlStr) {
		var _r, _r$1, _r$2, _tuple, _tuple$1, _tuple$2, err, html$1, htmlStr, lute, md, output, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; html$1 = $f.html$1; htmlStr = $f.htmlStr; lute = $f.lute; md = $f.md; output = $f.output; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		html$1 = "";
		err = $ifaceNil;
		lute = this;
		lute.options.VditorWYSIWYG = true;
		md = "";
		_r = lute.VditorDOM2Md(htmlStr); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		md = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [html$1, err];
		}
		tree = ptrType$11.nil;
		_r$1 = lute.parse("", (new sliceType($stringToBytes(md)))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		tree = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [html$1, err];
		}
		renderer = lute.newVditorRenderer(tree);
		output = sliceType.nil;
		_r$2 = renderer.Render(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple$2 = _r$2;
		output = _tuple$2[0];
		err = _tuple$2[1];
		html$1 = strings.ReplaceAll(($bytesToString(output)), "\xE2\x80\xB8", "<wbr>");
		$s = -1; return [html$1, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.RenderVditorDOM }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.html$1 = html$1; $f.htmlStr = htmlStr; $f.lute = lute; $f.md = md; $f.output = output; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.RenderVditorDOM = function(htmlStr) { return this.$val.RenderVditorDOM(htmlStr); };
	Lute.ptr.prototype.VditorDOM2Md = function(htmlStr) {
		var _i, _r, _r$1, _ref, _tuple, _tuple$1, err, formatted, htmlNode, htmlNodes, htmlRoot, htmlStr, lute, md, reader, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; err = $f.err; formatted = $f.formatted; htmlNode = $f.htmlNode; htmlNodes = $f.htmlNodes; htmlRoot = $f.htmlRoot; htmlStr = $f.htmlStr; lute = $f.lute; md = $f.md; reader = $f.reader; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		md = "";
		err = $ifaceNil;
		lute = this;
		htmlStr = strings.ReplaceAll(htmlStr, "<wbr>", "\xE2\x80\xB8");
		reader = strings.NewReader(htmlStr);
		htmlRoot = new html.Node.ptr(ptrType$12.nil, ptrType$12.nil, ptrType$12.nil, ptrType$12.nil, ptrType$12.nil, 3, 0, "", "", sliceType$7.nil);
		_r = html.ParseFragment(reader, htmlRoot); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		htmlNodes = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [md, err];
		}
		tree = new Tree.ptr("", new Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""), ptrType$8.nil, new Context.ptr(ptrType$11.nil, lute.options, false, ptrType.nil, ptrType.nil, sliceType.nil, 0, 0, 0, 0, 0, 0, 0, false, false, false, false, ptrType.nil), ptrType$14.nil);
		tree.context.tip = tree.Root;
		_ref = htmlNodes;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			htmlNode = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			lute.genASTByVditorDOM(htmlNode, tree);
			_i++;
		}
		formatted = sliceType.nil;
		renderer = lute.newFormatRenderer(tree);
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		formatted = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [md, err];
		}
		md = bytesToStr(formatted);
		$s = -1; return [md, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.VditorDOM2Md }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.err = err; $f.formatted = formatted; $f.htmlNode = htmlNode; $f.htmlNodes = htmlNodes; $f.htmlRoot = htmlRoot; $f.htmlStr = htmlStr; $f.lute = lute; $f.md = md; $f.reader = reader; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.VditorDOM2Md = function(htmlStr) { return this.$val.VditorDOM2Md(htmlStr); };
	Lute.ptr.prototype.genASTByVditorDOM = function(n, tree) {
		var _1, _2, _3, _4, _5, c, c$1, class$1, emojiImg, imgAlt, imgClass, language, lastc, linkTitle, lute, marker, marker$1, marker$2, marker$3, marker$4, marker$5, marker$6, marker$7, marker$8, n, node, start, tableAligns, tight, tree, x, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		lute = this;
		node = new Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(n.Data), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
		_1 = n.DataAtom;
		if (_1 === (0)) {
			if (!(ptrType$12.nil === n.Parent)) {
				_2 = n.Parent.DataAtom;
				if (_2 === (378116)) {
					if (ptrType$12.nil === n.Parent.Parent) {
						node.typ = 29;
					} else {
						node.typ = 15;
						class$1 = lute.domAttrValue(n.Parent, "class");
						if (strings.Contains(class$1, "language-")) {
							language = $substring(class$1, 9);
							tree.context.tip.lastChild.codeBlockInfo = strToBytes(language);
						}
					}
				} else if (_2 === (1)) {
					node.typ = 40;
				}
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (359427)) {
			node.typ = 16;
			node.tokens = strToBytes("<wbr>");
			lastc = tree.context.tip.lastDeepestChild();
			if (1 === lastc.typ) {
				lastc.AppendChild(node);
			} else {
				lastc.AppendTokens(node.tokens);
			}
			return;
		} else if ((_1 === (3073)) || (_1 === (92931))) {
			node.typ = 1;
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if ((_1 === (89090)) || (_1 === (187906)) || (_1 === (199938)) || (_1 === (214274)) || (_1 === (216834)) || (_1 === (412930))) {
			node.typ = 2;
			node.headingLevel = ((((x = node.tokens, (1 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 1])) - 48 << 24 >>> 24) >> 0));
			node.AppendChild(new Node.ptr(3, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(strings.Repeat("#", node.headingLevel)), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (87810)) {
			node.typ = 4;
			tree.context.tip.AppendChild(node);
		} else if (_1 === (100106)) {
			node.typ = 5;
			node.AppendChild(new Node.ptr(6, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(">"), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if ((_1 === (79618)) || (_1 === (42754))) {
			node.typ = 7;
			node.listData = new listData.ptr(0, false, sliceType.nil, 0, 0, 0, 0, false, sliceType.nil, 0);
			if (79618 === n.DataAtom) {
				node.listData.typ = 1;
			}
			tight = lute.domAttrValue(n, "data-tight");
			if ("true" === tight || "" === tight) {
				node.listData.tight = true;
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (45570)) {
			node.typ = 8;
			marker = lute.domAttrValue(n, "data-marker");
			if ("" === marker) {
				if (79618 === n.Parent.DataAtom) {
					start = lute.domAttrValue(n.Parent, "start");
					if ("" === start) {
						marker = "1.";
					} else {
						marker = start + ".";
					}
				} else {
					marker = "*";
				}
			}
			node.listData = new listData.ptr(0, false, sliceType.nil, 0, 0, 0, 0, false, strToBytes(marker), 0);
			if (lute.firstChildIsText(n)) {
				tree.context.tip.AppendChild(node);
				tree.context.tip = node;
				node = new Node.ptr(1, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (290819)) {
			node.typ = 11;
			node.isFencedCodeBlock = true;
			node.AppendChild(new Node.ptr(12, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes("```"), false, false, false, 0, false, 0, 3, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			node.AppendChild(new Node.ptr(14, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if ((_1 === (28162)) || (_1 === (1537))) {
			node.typ = 17;
			marker$1 = lute.domAttrValue(n, "data-marker");
			if ("" === marker$1) {
				marker$1 = "_";
			}
			if ("_" === marker$1) {
				node.AppendChild(new Node.ptr(20, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$1), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			} else {
				node.AppendChild(new Node.ptr(18, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$1), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if ((_1 === (449798)) || (_1 === (257))) {
			node.typ = 22;
			marker$2 = lute.domAttrValue(n, "data-marker");
			if ("" === marker$2) {
				marker$2 = "**";
			}
			if ("__" === marker$2) {
				node.AppendChild(new Node.ptr(25, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$2), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			} else {
				node.AppendChild(new Node.ptr(23, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$2), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (378116)) {
			if (ptrType$12.nil === n.Parent || !((290819 === n.Parent.DataAtom))) {
				node.typ = 27;
				node.AppendChild(new Node.ptr(28, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes("`"), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				tree.context.tip.AppendChild(node);
				tree.context.tip = node;
				$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
			}
		} else if (_1 === (514)) {
			node.typ = 10;
			node.tokens = strToBytes("<br />");
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (1)) {
			node.typ = 33;
			node.AppendChild(new Node.ptr(36, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (198403)) {
			imgClass = lute.domAttrValue(n, "class");
			imgAlt = lute.domAttrValue(n, "alt");
			if ("emoji" === imgClass) {
				node.typ = 200;
				emojiImg = new Node.ptr(202, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", tree.emojiImgTokens(imgAlt, lute.domAttrValue(n, "src")), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
				emojiImg.AppendChild(new Node.ptr(203, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(":" + imgAlt + ":"), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				node.AppendChild(emojiImg);
			} else {
				node.typ = 34;
				node.AppendChild(new Node.ptr(35, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				node.AppendChild(new Node.ptr(36, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				if (!("" === imgAlt)) {
					node.AppendChild(new Node.ptr(40, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(imgAlt), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				}
				node.AppendChild(new Node.ptr(37, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				node.AppendChild(new Node.ptr(38, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				node.AppendChild(new Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(lute.domAttrValue(n, "src")), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				node.AppendChild(new Node.ptr(39, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (281349)) {
			node.typ = 100;
			if (lute.hasAttr(n, "checked")) {
				node.taskListItemChecked = true;
				node.tokens = strToBytes("[X]");
			} else {
				node.tokens = strToBytes("[ ]");
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
			if (!(ptrType.nil === node.parent.parent)) {
				node.parent.parent.listData.typ = 3;
			}
		} else if ((_1 === (283139)) || (_1 === (9473))) {
			node.typ = 101;
			marker$3 = lute.domAttrValue(n, "data-marker");
			if ("~" === marker$3) {
				node.AppendChild(new Node.ptr(102, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$3), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			} else {
				node.AppendChild(new Node.ptr(104, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$3), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (365829)) {
			node.typ = 106;
			tableAligns = sliceType$3.nil;
			c = n.FirstChild.FirstChild.FirstChild;
			while (true) {
				if (!(!(ptrType$12.nil === c))) { break; }
				tableAligns = $append(tableAligns, 0);
				c = c.NextSibling;
			}
			node.tableAligns = tableAligns;
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (208901)) {
			node.typ = 107;
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (52226)) {
			node.typ = 108;
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if ((_1 === (87554)) || (_1 === (37378))) {
			node.typ = 109;
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		} else if (_1 === (40708)) {
			marker$4 = lute.domAttrValue(n, "data-marker");
			if (!("" === marker$4)) {
				_3 = marker$4;
				if (_3 === ("*") || _3 === ("_")) {
					node.typ = 17;
					if ("_" === marker$4) {
						node.AppendChild(new Node.ptr(20, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$4), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					} else {
						node.AppendChild(new Node.ptr(18, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$4), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					}
				} else if (_3 === ("**") || _3 === ("__")) {
					if ("__" === marker$4) {
						node.AppendChild(new Node.ptr(25, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$4), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					} else {
						node.AppendChild(new Node.ptr(23, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$4), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					}
				}
			} else {
				node.tokens = strToBytes("");
			}
			tree.context.tip.AppendChild(node);
			tree.context.tip = node;
			$deferred.push([$methodVal(tree.context, "parentTip"), [n]]);
		}
		c$1 = n.FirstChild;
		while (true) {
			if (!(!(c$1 === ptrType$12.nil))) { break; }
			lute.genASTByVditorDOM(c$1, tree);
			c$1 = c$1.NextSibling;
		}
		_4 = n.DataAtom;
		if ((_4 === (28162)) || (_4 === (1537))) {
			marker$5 = lute.domAttrValue(n, "data-marker");
			if ("" === marker$5) {
				marker$5 = "_";
			}
			if ("_" === marker$5) {
				node.AppendChild(new Node.ptr(21, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$5), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			} else {
				node.AppendChild(new Node.ptr(19, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$5), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
		} else if ((_4 === (449798)) || (_4 === (257))) {
			marker$6 = lute.domAttrValue(n, "data-marker");
			if ("" === marker$6) {
				marker$6 = "**";
			}
			if ("__" === marker$6) {
				node.AppendChild(new Node.ptr(26, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$6), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			} else {
				node.AppendChild(new Node.ptr(24, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$6), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
		} else if (_4 === (290819)) {
			node.AppendChild(new Node.ptr(13, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes("```"), false, false, false, 0, false, 0, 3, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		} else if (_4 === (378116)) {
			if (ptrType$12.nil === n.Parent || !((290819 === n.Parent.DataAtom))) {
				node.AppendChild(new Node.ptr(30, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes("`"), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
		} else if (_4 === (1)) {
			node.AppendChild(new Node.ptr(37, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			node.AppendChild(new Node.ptr(38, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			node.AppendChild(new Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(lute.domAttrValue(n, "href")), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			linkTitle = lute.domAttrValue(n, "title");
			if (!("" === linkTitle)) {
				node.AppendChild(new Node.ptr(43, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
				node.AppendChild(new Node.ptr(42, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(linkTitle), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
			node.AppendChild(new Node.ptr(39, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
		} else if ((_4 === (283139)) || (_4 === (9473))) {
			marker$7 = lute.domAttrValue(n, "data-marker");
			if ("~" === marker$7) {
				node.AppendChild(new Node.ptr(103, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$7), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			} else {
				node.AppendChild(new Node.ptr(105, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$7), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
			}
		} else if (_4 === (40708)) {
			marker$8 = lute.domAttrValue(n, "data-marker");
			if (!("" === marker$8)) {
				_5 = marker$8;
				if (_5 === ("*") || _5 === ("_")) {
					node.typ = 17;
					if ("_" === marker$8) {
						node.AppendChild(new Node.ptr(21, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$8), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					} else {
						node.AppendChild(new Node.ptr(19, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$8), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					}
				} else if (_5 === ("**") || _5 === ("__")) {
					if ("__" === marker$8) {
						node.AppendChild(new Node.ptr(26, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$8), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					} else {
						node.AppendChild(new Node.ptr(24, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", strToBytes(marker$8), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", ""));
					}
				}
			}
		}
		/* */ } catch(err) { $err = err; } finally { $callDeferred($deferred, $err); }
	};
	Lute.prototype.genASTByVditorDOM = function(n, tree) { return this.$val.genASTByVditorDOM(n, tree); };
	Context.ptr.prototype.parentTip = function(n) {
		var context, n, nextType, tip;
		context = this;
		tip = context.tip.parent;
		while (true) {
			if (!(!(ptrType.nil === tip))) { break; }
			if (1 === tip.typ) {
				if (ptrType$12.nil === n.NextSibling) {
					tip = tip.parent;
					continue;
				}
				nextType = n.NextSibling.DataAtom;
				if ((42754 === nextType) || (79618 === nextType)) {
					tip = tip.parent;
					continue;
				}
			}
			context.tip = tip;
			break;
		}
	};
	Context.prototype.parentTip = function(n) { return this.$val.parentTip(n); };
	Lute.ptr.prototype.firstChildIsText = function(n) {
		var c, lute, n;
		lute = this;
		c = n.FirstChild;
		while (true) {
			if (!(!(ptrType$12.nil === c))) { break; }
			if ("\xE2\x80\xB8" === c.Data) {
				c = c.NextSibling;
				continue;
			}
			return (0 === c.DataAtom) || (28162 === c.DataAtom);
		}
		return false;
	};
	Lute.prototype.firstChildIsText = function(n) { return this.$val.firstChildIsText(n); };
	Lute.ptr.prototype.hasAttr = function(n, attrName) {
		var _i, _ref, attr, attrName, lute, n;
		lute = this;
		_ref = n.Attr;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), html.Attribute);
			if (attr.Key === attrName) {
				return true;
			}
			_i++;
		}
		return false;
	};
	Lute.prototype.hasAttr = function(n, attrName) { return this.$val.hasAttr(n, attrName); };
	Lute.ptr.prototype.domAttrValue = function(n, attrName) {
		var _i, _ref, attr, attrName, lute, n;
		lute = this;
		_ref = n.Attr;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), html.Attribute);
			if (attr.Key === attrName) {
				return attr.Val;
			}
			_i++;
		}
		return "";
	};
	Lute.prototype.domAttrValue = function(n, attrName) { return this.$val.domAttrValue(n, attrName); };
	Lute.ptr.prototype.newVditorRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$35, _key$36, _key$37, _key$38, _key$39, _key$4, _key$40, _key$41, _key$42, _key$43, _key$44, _key$45, _key$46, _key$47, _key$48, _key$49, _key$5, _key$50, _key$51, _key$52, _key$53, _key$54, _key$55, _key$56, _key$57, _key$58, _key$59, _key$6, _key$7, _key$8, _key$9, lute, ret, tree;
		lute = this;
		ret = new VditorRenderer.ptr(lute.newBaseRenderer(tree));
		_key = 0; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 28; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeSpanOpenMarker") };
		_key$5 = 29; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderCodeSpanContent") };
		_key$6 = 30; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderCodeSpanCloseMarker") };
		_key$7 = 11; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderCodeBlock") };
		_key$8 = 12; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderCodeBlockOpenMarker") };
		_key$9 = 14; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderCodeBlockInfoMarker") };
		_key$10 = 15; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderCodeBlockCode") };
		_key$11 = 13; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderCodeBlockCloseMarker") };
		_key$12 = 300; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderMathBlock") };
		_key$13 = 301; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderInlineMath") };
		_key$14 = 17; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderEmphasis") };
		_key$15 = 18; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderEmAsteriskOpenMarker") };
		_key$16 = 19; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderEmAsteriskCloseMarker") };
		_key$17 = 20; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderEmUnderscoreOpenMarker") };
		_key$18 = 21; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderEmUnderscoreCloseMarker") };
		_key$19 = 22; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderStrong") };
		_key$20 = 23; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderStrongA6kOpenMarker") };
		_key$21 = 24; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderStrongA6kCloseMarker") };
		_key$22 = 25; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderStrongU8eOpenMarker") };
		_key$23 = 26; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderStrongU8eCloseMarker") };
		_key$24 = 5; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderBlockquote") };
		_key$25 = 6; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderBlockquoteMarker") };
		_key$26 = 2; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderHeading") };
		_key$27 = 3; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderHeadingC8hMarker") };
		_key$28 = 7; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderList") };
		_key$29 = 8; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderListItem") };
		_key$30 = 4; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderThematicBreak") };
		_key$31 = 31; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderHardBreak") };
		_key$32 = 32; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderSoftBreak") };
		_key$33 = 9; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderHTML") };
		_key$34 = 10; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderInlineHTML") };
		_key$35 = 33; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$35)] = { k: _key$35, v: $methodVal(ret, "renderLink") };
		_key$36 = 34; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$36)] = { k: _key$36, v: $methodVal(ret, "renderImage") };
		_key$37 = 35; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$37)] = { k: _key$37, v: $methodVal(ret, "renderBang") };
		_key$38 = 36; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$38)] = { k: _key$38, v: $methodVal(ret, "renderOpenBracket") };
		_key$39 = 37; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$39)] = { k: _key$39, v: $methodVal(ret, "renderCloseBracket") };
		_key$40 = 38; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$40)] = { k: _key$40, v: $methodVal(ret, "renderOpenParen") };
		_key$41 = 39; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$41)] = { k: _key$41, v: $methodVal(ret, "renderCloseParen") };
		_key$42 = 40; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$42)] = { k: _key$42, v: $methodVal(ret, "renderLinkText") };
		_key$43 = 43; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$43)] = { k: _key$43, v: $methodVal(ret, "renderLinkSpace") };
		_key$44 = 41; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$44)] = { k: _key$44, v: $methodVal(ret, "renderLinkDest") };
		_key$45 = 42; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$45)] = { k: _key$45, v: $methodVal(ret, "renderLinkTitle") };
		_key$46 = 101; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$46)] = { k: _key$46, v: $methodVal(ret, "renderStrikethrough") };
		_key$47 = 102; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$47)] = { k: _key$47, v: $methodVal(ret, "renderStrikethrough1OpenMarker") };
		_key$48 = 103; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$48)] = { k: _key$48, v: $methodVal(ret, "renderStrikethrough1CloseMarker") };
		_key$49 = 104; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$49)] = { k: _key$49, v: $methodVal(ret, "renderStrikethrough2OpenMarker") };
		_key$50 = 105; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$50)] = { k: _key$50, v: $methodVal(ret, "renderStrikethrough2CloseMarker") };
		_key$51 = 100; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$51)] = { k: _key$51, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$52 = 106; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$52)] = { k: _key$52, v: $methodVal(ret, "renderTable") };
		_key$53 = 107; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$53)] = { k: _key$53, v: $methodVal(ret, "renderTableHead") };
		_key$54 = 108; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$54)] = { k: _key$54, v: $methodVal(ret, "renderTableRow") };
		_key$55 = 109; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$55)] = { k: _key$55, v: $methodVal(ret, "renderTableCell") };
		_key$56 = 200; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$56)] = { k: _key$56, v: $methodVal(ret, "renderEmoji") };
		_key$57 = 201; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$57)] = { k: _key$57, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$58 = 202; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$58)] = { k: _key$58, v: $methodVal(ret, "renderEmojiImg") };
		_key$59 = 203; (ret.BaseRenderer.rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[nodeType.keyFor(_key$59)] = { k: _key$59, v: $methodVal(ret, "renderEmojiAlias") };
		return ret;
	};
	Lute.prototype.newVditorRenderer = function(tree) { return this.$val.newVditorRenderer(tree); };
	VditorRenderer.ptr.prototype.renderCodeBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeBlockCloseMarker = function(node, entering) { return this.$val.renderCodeBlockCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeBlockInfoMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeBlockInfoMarker = function(node, entering) { return this.$val.renderCodeBlockInfoMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeBlockOpenMarker = function(node, entering) { return this.$val.renderCodeBlockOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	VditorRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	VditorRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	VditorRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	VditorRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		attrs = new sliceType$6([new sliceType$5(["class", "vditor-math"])]);
		r.tag("span", attrs, false);
		r.BaseRenderer.write(node.tokens);
		r.tag("/span", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	VditorRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		attrs = new sliceType$6([new sliceType$5(["class", "vditor-math"])]);
		r.tag("div", attrs, false);
		r.BaseRenderer.write(node.tokens);
		r.tag("/div", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	VditorRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var _1, attrs, entering, node, r, tag;
		r = this;
		tag = "td";
		if (107 === node.parent.parent.typ) {
			tag = "th";
		}
		if (entering) {
			attrs = sliceType$6.nil;
			_1 = node.tableCellAlign;
			if (_1 === (1)) {
				attrs = $append(attrs, new sliceType$5(["align", "left"]));
			} else if (_1 === (2)) {
				attrs = $append(attrs, new sliceType$5(["align", "center"]));
			} else if (_1 === (3)) {
				attrs = $append(attrs, new sliceType$5(["align", "right"]));
			}
			r.tag(tag, attrs, false);
		} else {
			r.tag("/" + tag, sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	VditorRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("tr", sliceType$6.nil, false);
		} else {
			r.tag("/tr", sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	VditorRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("thead", sliceType$6.nil, false);
		} else {
			r.tag("/thead", sliceType$6.nil, false);
			if (!(ptrType.nil === node.next)) {
				r.tag("tbody", sliceType$6.nil, false);
			}
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	VditorRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("table", sliceType$6.nil, false);
		} else {
			if (!(ptrType.nil === node.firstChild.next)) {
				r.tag("/tbody", sliceType$6.nil, false);
			}
			r.tag("/table", sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough1OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("s", new sliceType$6([new sliceType$5(["data-marker", "~"])]), false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrikethrough1OpenMarker = function(node, entering) { return this.$val.renderStrikethrough1OpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough1CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/s", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrikethrough1CloseMarker = function(node, entering) { return this.$val.renderStrikethrough1CloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough2OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("s", new sliceType$6([new sliceType$5(["data-marker", "~~"])]), false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrikethrough2OpenMarker = function(node, entering) { return this.$val.renderStrikethrough2OpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough2CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/s", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrikethrough2CloseMarker = function(node, entering) { return this.$val.renderStrikethrough2CloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkTitle = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderLinkTitle = function(node, entering) { return this.$val.renderLinkTitle(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkDest = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderLinkDest = function(node, entering) { return this.$val.renderLinkDest(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkSpace = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderLinkSpace = function(node, entering) { return this.$val.renderLinkSpace(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkText = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.write(node.tokens);
		}
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderLinkText = function(node, entering) { return this.$val.renderLinkText(node, entering); };
	VditorRenderer.ptr.prototype.renderCloseParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCloseParen = function(node, entering) { return this.$val.renderCloseParen(node, entering); };
	VditorRenderer.ptr.prototype.renderOpenParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderOpenParen = function(node, entering) { return this.$val.renderOpenParen(node, entering); };
	VditorRenderer.ptr.prototype.renderCloseBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCloseBracket = function(node, entering) { return this.$val.renderCloseBracket(node, entering); };
	VditorRenderer.ptr.prototype.renderOpenBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderOpenBracket = function(node, entering) { return this.$val.renderOpenBracket(node, entering); };
	VditorRenderer.ptr.prototype.renderBang = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderBang = function(node, entering) { return this.$val.renderBang(node, entering); };
	VditorRenderer.ptr.prototype.renderImage = function(node, entering) {
		var entering, node, r, title;
		r = this;
		if (entering) {
			if (0 === r.BaseRenderer.disableTags) {
				r.BaseRenderer.writeString("<img src=\"");
				r.BaseRenderer.write(node.ChildByType(41).tokens);
				r.BaseRenderer.writeString("\" alt=\"");
			}
			r.BaseRenderer.disableTags = r.BaseRenderer.disableTags + (1) >> 0;
			return [2, $ifaceNil];
		}
		r.BaseRenderer.disableTags = r.BaseRenderer.disableTags - (1) >> 0;
		if (0 === r.BaseRenderer.disableTags) {
			r.BaseRenderer.writeString("\"");
			title = node.ChildByType(42);
			if (!(ptrType.nil === title) && !(sliceType.nil === title.tokens)) {
				r.BaseRenderer.writeString(" title=\"");
				r.BaseRenderer.write(title.tokens);
				r.BaseRenderer.writeString("\"");
			}
			r.BaseRenderer.writeString(" />");
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	VditorRenderer.ptr.prototype.renderLink = function(node, entering) {
		var attrs, dest, entering, node, r, title;
		r = this;
		if (entering) {
			dest = node.ChildByType(41);
			attrs = new sliceType$6([new sliceType$5(["href", bytesToStr(dest.tokens)])]);
			title = node.ChildByType(42);
			if (!(ptrType.nil === title) && !(sliceType.nil === title.tokens)) {
				attrs = $append(attrs, new sliceType$5(["title", bytesToStr(title.tokens)]));
			}
			r.tag("a", attrs, false);
		} else {
			r.tag("/a", sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	VditorRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	VditorRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	VditorRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	VditorRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, grandparent, node, r;
		r = this;
		grandparent = node.parent.parent;
		if (!(ptrType.nil === grandparent)) {
			if (7 === grandparent.typ) {
				if (grandparent.listData.tight) {
					return [2, $ifaceNil];
				}
			}
		}
		if (entering) {
			r.tag("p", sliceType$6.nil, false);
		} else {
			r.tag("/p", sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	VditorRenderer.ptr.prototype.renderText = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (r.BaseRenderer.option.AutoSpace) {
			r.BaseRenderer.space(node);
		}
		/* */ if (r.BaseRenderer.option.FixTermTypo) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.option.FixTermTypo) { */ case 1:
			$r = r.BaseRenderer.fixTermTypo(node); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		r.BaseRenderer.write(node.tokens);
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderText }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpanOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("<code>");
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeSpanOpenMarker = function(node, entering) { return this.$val.renderCodeSpanOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpanContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.write(node.tokens);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeSpanContent = function(node, entering) { return this.$val.renderCodeSpanContent(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpanCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.writeString("</code>");
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeSpanCloseMarker = function(node, entering) { return this.$val.renderCodeSpanCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	VditorRenderer.ptr.prototype.renderEmAsteriskOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", new sliceType$6([new sliceType$5(["data-marker", "*"])]), false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmAsteriskOpenMarker = function(node, entering) { return this.$val.renderEmAsteriskOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmAsteriskCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmAsteriskCloseMarker = function(node, entering) { return this.$val.renderEmAsteriskCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmUnderscoreOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", new sliceType$6([new sliceType$5(["data-marker", "_"])]), false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmUnderscoreOpenMarker = function(node, entering) { return this.$val.renderEmUnderscoreOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmUnderscoreCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderEmUnderscoreCloseMarker = function(node, entering) { return this.$val.renderEmUnderscoreCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r;
		r = this;
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongA6kOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", new sliceType$6([new sliceType$5(["data-marker", "**"])]), false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrongA6kOpenMarker = function(node, entering) { return this.$val.renderStrongA6kOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongA6kCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrongA6kCloseMarker = function(node, entering) { return this.$val.renderStrongA6kCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongU8eOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", new sliceType$6([new sliceType$5(["data-marker", "__"])]), false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrongU8eOpenMarker = function(node, entering) { return this.$val.renderStrongU8eOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongU8eCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$6.nil, false);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderStrongU8eCloseMarker = function(node, entering) { return this.$val.renderStrongU8eCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.writeString("<blockquote>");
		} else {
			r.BaseRenderer.writeString("</blockquote>");
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	VditorRenderer.ptr.prototype.renderBlockquoteMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderBlockquoteMarker = function(node, entering) { return this.$val.renderBlockquoteMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var _r, anchor, entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; anchor = $f.anchor; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.writeString("<h" + $substring(" 123456", node.headingLevel, (node.headingLevel + 1 >> 0)) + ">");
			/* */ if (r.BaseRenderer.option.HeadingAnchor) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (r.BaseRenderer.option.HeadingAnchor) { */ case 4:
				_r = node.Text(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				anchor = _r;
				anchor = strings.ReplaceAll(anchor, " ", "-");
				r.tag("a", new sliceType$6([new sliceType$5(["id", "vditorAnchor-" + anchor]), new sliceType$5(["class", "vditor-anchor"]), new sliceType$5(["href", "#" + anchor])]), false);
				r.BaseRenderer.writeString("<svg viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>");
				r.tag("/a", sliceType$6.nil, false);
			/* } */ case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.writeString("</h" + $substring(" 123456", node.headingLevel, (node.headingLevel + 1 >> 0)) + ">");
		/* } */ case 3:
		$s = -1; return [2, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderHeading }; } $f._r = _r; $f.anchor = anchor; $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	VditorRenderer.ptr.prototype.renderHeadingC8hMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderHeadingC8hMarker = function(node, entering) { return this.$val.renderHeadingC8hMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderList = function(node, entering) {
		var attrs, entering, node, r, tag;
		r = this;
		tag = "ul";
		if (1 === node.listData.typ) {
			tag = "ol";
		}
		if (entering) {
			attrs = sliceType$6.nil;
			if (node.listData.tight) {
				attrs = $append(attrs, new sliceType$5(["data-tight", "true"]));
			}
			if (sliceType.nil === node.listData.bulletChar && !((1 === node.listData.start))) {
				attrs = $append(attrs, new sliceType$5(["start", strconv.Itoa(node.listData.start)]));
			}
			r.tag(tag, attrs, false);
		} else {
			r.tag("/" + tag, sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	VditorRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var _1, attrs, entering, node, r;
		r = this;
		if (entering) {
			attrs = sliceType$6.nil;
			_1 = node.listData.typ;
			if (_1 === (0)) {
				attrs = $append(attrs, new sliceType$5(["data-marker", bytesToStr(node.listData.marker)]));
			} else if (_1 === (1)) {
				attrs = $append(attrs, new sliceType$5(["data-marker", strconv.Itoa(node.listData.num) + "."]));
			} else if (_1 === (3)) {
				attrs = $append(attrs, new sliceType$5(["data-marker", bytesToStr(node.listData.marker)]));
				attrs = $append(attrs, new sliceType$5(["class", r.BaseRenderer.option.GFMTaskListItemClass]));
			}
			r.tag("li", attrs, false);
		} else {
			r.tag("/li", sliceType$6.nil, false);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	VditorRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		if (entering) {
			attrs = sliceType$6.nil;
			if (node.taskListItemChecked) {
				attrs = $append(attrs, new sliceType$5(["checked", ""]));
			}
			attrs = $append(attrs, new sliceType$5(["type", "checkbox"]));
			r.tag("input", attrs, true);
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("hr", sliceType$6.nil, true);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	VditorRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("br", sliceType$6.nil, true);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	VditorRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("br", sliceType$6.nil, true);
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	VditorRenderer.ptr.prototype.tag = function(name, attrs, selfclosing) {
		var _i, _ref, attr, attrs, name, r, selfclosing;
		r = this;
		if (r.BaseRenderer.disableTags > 0) {
			return;
		}
		r.BaseRenderer.writeString("<");
		r.BaseRenderer.writeString(name);
		if (0 < attrs.$length) {
			_ref = attrs;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				attr = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				r.BaseRenderer.writeString(" " + (0 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 0]) + "=\"" + (1 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 1]) + "\"");
				_i++;
			}
		}
		if (selfclosing) {
			r.BaseRenderer.writeString(" /");
		}
		r.BaseRenderer.writeString(">");
	};
	VditorRenderer.prototype.tag = function(name, attrs, selfclosing) { return this.$val.tag(name, attrs, selfclosing); };
	VditorRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!node.isFencedCodeBlock) {
			r.BaseRenderer.writeString("<pre><code>");
			r.BaseRenderer.write(node.tokens);
			r.BaseRenderer.writeString("</code></pre>");
			return [0, $ifaceNil];
		}
		return [2, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeBlockCode = function(node, entering) {
		var entering, infoWords, language, node, r, tokens;
		r = this;
		if (entering) {
			tokens = node.tokens;
			if (0 < node.codeBlockInfo.$length) {
				infoWords = split(node.codeBlockInfo, 32);
				language = bytesToStr((0 >= infoWords.$length ? ($throwRuntimeError("index out of range"), undefined) : infoWords.$array[infoWords.$offset + 0]));
				r.BaseRenderer.writeString("<pre><code class=\"language-" + language + "\">");
			} else {
				r.BaseRenderer.writeString("<pre><code>");
			}
			if ("\n\xE2\x80\xB8<br />\n" === bytesToStr(tokens)) {
				tokens = strToBytes("\xE2\x80\xB8\n");
			}
			r.BaseRenderer.write(tokens);
			return [1, $ifaceNil];
		}
		r.BaseRenderer.writeString("</code></pre>");
		return [0, $ifaceNil];
	};
	VditorRenderer.prototype.renderCodeBlockCode = function(node, entering) { return this.$val.renderCodeBlockCode(node, entering); };
	Walk = function(n, walker) {
		var _r, _r$1, _r$2, _tuple, _tuple$1, c, err, err$1, n, status, walker, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; c = $f.c; err = $f.err; err$1 = $f.err$1; n = $f.n; status = $f.status; walker = $f.walker; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		err = $ifaceNil;
		status = 0;
		_r = walker(n, true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		status = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err)) || (status === 0)) {
			$s = -1; return err;
		}
		/* */ if (!((status === 1))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((status === 1))) { */ case 2:
			c = n.firstChild;
			/* while (true) { */ case 4:
				/* if (!(!(ptrType.nil === c))) { break; } */ if(!(!(ptrType.nil === c))) { $s = 5; continue; }
				_r$1 = Walk(c, walker); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				err$1 = _r$1;
				if (!($interfaceIsEqual($ifaceNil, err$1))) {
					err = err$1;
					$s = -1; return err;
				}
				c = c.next;
			/* } */ $s = 4; continue; case 5:
		/* } */ case 3:
		_r$2 = walker(n, false); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple$1 = _r$2;
		status = _tuple$1[0];
		err = _tuple$1[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Walk }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.c = c; $f.err = err; $f.err$1 = err$1; $f.n = n; $f.status = status; $f.walker = walker; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Walk = Walk;
	ptrType$15.methods = [{prop: "renderDefault", name: "renderDefault", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineMathEChartsJSON", name: "renderInlineMathEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderMathBlockEChartsJSON", name: "renderMathBlockEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiImgEChartsJSON", name: "renderEmojiImgEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiUnicodeEChartsJSON", name: "renderEmojiUnicodeEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableCellEChartsJSON", name: "renderTableCellEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableRowEChartsJSON", name: "renderTableRowEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableHeadEChartsJSON", name: "renderTableHeadEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableEChartsJSON", name: "renderTableEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethroughEChartsJSON", name: "renderStrikethroughEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderImageEChartsJSON", name: "renderImageEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkEChartsJSON", name: "renderLinkEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHTMLEChartsJSON", name: "renderHTMLEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineHTMLEChartsJSON", name: "renderInlineHTMLEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderDocumentEChartsJSON", name: "renderDocumentEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderParagraphEChartsJSON", name: "renderParagraphEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTextEChartsJSON", name: "renderTextEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanEChartsJSON", name: "renderCodeSpanEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmphasisEChartsJSON", name: "renderEmphasisEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongEChartsJSON", name: "renderStrongEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBlockquoteEChartsJSON", name: "renderBlockquoteEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHeadingEChartsJSON", name: "renderHeadingEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderListEChartsJSON", name: "renderListEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderListItemEChartsJSON", name: "renderListItemEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTaskListItemMarkerEChartsJSON", name: "renderTaskListItemMarkerEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderThematicBreakEChartsJSON", name: "renderThematicBreakEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHardBreakEChartsJSON", name: "renderHardBreakEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderSoftBreakEChartsJSON", name: "renderSoftBreakEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockEChartsJSON", name: "renderCodeBlockEChartsJSON", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "leaf", name: "leaf", pkg: "github.com/b3log/lute", typ: $funcType([$String, ptrType], [], false)}, {prop: "val", name: "val", pkg: "github.com/b3log/lute", typ: $funcType([$String, ptrType], [], false)}, {prop: "openObj", name: "openObj", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "closeObj", name: "closeObj", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "openChildren", name: "openChildren", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "closeChildren", name: "closeChildren", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "comma", name: "comma", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "ignore", name: "ignore", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [$Bool], false)}];
	ptrType$16.methods = [{prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTable", name: "renderTable", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough1OpenMarker", name: "renderStrikethrough1OpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough1CloseMarker", name: "renderStrikethrough1CloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough2OpenMarker", name: "renderStrikethrough2OpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough2CloseMarker", name: "renderStrikethrough2CloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkTitle", name: "renderLinkTitle", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkDest", name: "renderLinkDest", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkSpace", name: "renderLinkSpace", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkText", name: "renderLinkText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCloseParen", name: "renderCloseParen", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderOpenParen", name: "renderOpenParen", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCloseBracket", name: "renderCloseBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderOpenBracket", name: "renderOpenBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBang", name: "renderBang", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderImage", name: "renderImage", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLink", name: "renderLink", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderText", name: "renderText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanOpenMarker", name: "renderCodeSpanOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanContent", name: "renderCodeSpanContent", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanCloseMarker", name: "renderCodeSpanCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockCloseMarker", name: "renderCodeBlockCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockCode", name: "renderCodeBlockCode", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockInfoMarker", name: "renderCodeBlockInfoMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockOpenMarker", name: "renderCodeBlockOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmAsteriskOpenMarker", name: "renderEmAsteriskOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmAsteriskCloseMarker", name: "renderEmAsteriskCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmUnderscoreOpenMarker", name: "renderEmUnderscoreOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmUnderscoreCloseMarker", name: "renderEmUnderscoreCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongA6kOpenMarker", name: "renderStrongA6kOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongA6kCloseMarker", name: "renderStrongA6kCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongU8eOpenMarker", name: "renderStrongU8eOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongU8eCloseMarker", name: "renderStrongU8eCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBlockquoteMarker", name: "renderBlockquoteMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHeadingC8hMarker", name: "renderHeadingC8hMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderList", name: "renderList", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "isLastNode", name: "isLastNode", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, ptrType], [$Bool], false)}];
	ptrType$17.methods = [{prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockCode", name: "renderCodeBlockCode", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockCloseMarker", name: "renderCodeBlockCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockInfoMarker", name: "renderCodeBlockInfoMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockOpenMarker", name: "renderCodeBlockOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTable", name: "renderTable", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough1OpenMarker", name: "renderStrikethrough1OpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough1CloseMarker", name: "renderStrikethrough1CloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough2OpenMarker", name: "renderStrikethrough2OpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough2CloseMarker", name: "renderStrikethrough2CloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkTitle", name: "renderLinkTitle", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkDest", name: "renderLinkDest", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkSpace", name: "renderLinkSpace", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkText", name: "renderLinkText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCloseParen", name: "renderCloseParen", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderOpenParen", name: "renderOpenParen", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCloseBracket", name: "renderCloseBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderOpenBracket", name: "renderOpenBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBang", name: "renderBang", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderImage", name: "renderImage", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLink", name: "renderLink", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderText", name: "renderText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanOpenMarker", name: "renderCodeSpanOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanContent", name: "renderCodeSpanContent", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanCloseMarker", name: "renderCodeSpanCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmAsteriskOpenMarker", name: "renderEmAsteriskOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmAsteriskCloseMarker", name: "renderEmAsteriskCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmUnderscoreOpenMarker", name: "renderEmUnderscoreOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmUnderscoreCloseMarker", name: "renderEmUnderscoreCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongA6kOpenMarker", name: "renderStrongA6kOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongA6kCloseMarker", name: "renderStrongA6kCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongU8eOpenMarker", name: "renderStrongU8eOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongU8eCloseMarker", name: "renderStrongU8eCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBlockquoteMarker", name: "renderBlockquoteMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHeadingC8hMarker", name: "renderHeadingC8hMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderList", name: "renderList", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "tag", name: "tag", pkg: "github.com/b3log/lute", typ: $funcType([$String, sliceType$6, $Bool], [], false)}];
	ptrType$8.methods = [{prop: "nextLine", name: "nextLine", pkg: "github.com/b3log/lute", typ: $funcType([], [sliceType], false)}];
	ptrType$9.methods = [{prop: "AddAutoLinkDomainSuffix", name: "AddAutoLinkDomainSuffix", pkg: "", typ: $funcType([$String], [], false)}, {prop: "newEChartsJSONRenderer", name: "newEChartsJSONRenderer", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$11], [Renderer], false)}, {prop: "newFormatRenderer", name: "newFormatRenderer", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$11], [Renderer], false)}, {prop: "newHTMLRenderer", name: "newHTMLRenderer", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$11], [Renderer], false)}, {prop: "Markdown", name: "Markdown", pkg: "", typ: $funcType([$String, sliceType], [sliceType, $error], false)}, {prop: "MarkdownStr", name: "MarkdownStr", pkg: "", typ: $funcType([$String, $String], [$String, $error], false)}, {prop: "Format", name: "Format", pkg: "", typ: $funcType([$String, sliceType], [sliceType, $error], false)}, {prop: "FormatStr", name: "FormatStr", pkg: "", typ: $funcType([$String, $String], [$String, $error], false)}, {prop: "Html2Md", name: "Html2Md", pkg: "", typ: $funcType([$String], [$String, $error], false)}, {prop: "Space", name: "Space", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "GetEmojis", name: "GetEmojis", pkg: "", typ: $funcType([], [mapType], false)}, {prop: "PutEmojis", name: "PutEmojis", pkg: "", typ: $funcType([mapType], [], false)}, {prop: "GetTerms", name: "GetTerms", pkg: "", typ: $funcType([], [mapType], false)}, {prop: "PutTerms", name: "PutTerms", pkg: "", typ: $funcType([mapType], [], false)}, {prop: "RenderEChartsJSON", name: "RenderEChartsJSON", pkg: "", typ: $funcType([$String], [$String, $error], false)}, {prop: "SetGFMTable", name: "SetGFMTable", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetGFMTaskListItem", name: "SetGFMTaskListItem", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetGFMTaskListItemClass", name: "SetGFMTaskListItemClass", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetGFMStrikethrough", name: "SetGFMStrikethrough", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetGFMAutoLink", name: "SetGFMAutoLink", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetSoftBreak2HardBreak", name: "SetSoftBreak2HardBreak", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlight", name: "SetCodeSyntaxHighlight", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlightInlineStyle", name: "SetCodeSyntaxHighlightInlineStyle", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlightLineNum", name: "SetCodeSyntaxHighlightLineNum", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlightStyleName", name: "SetCodeSyntaxHighlightStyleName", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetAutoSpace", name: "SetAutoSpace", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetFixTermTypo", name: "SetFixTermTypo", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetEmoji", name: "SetEmoji", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetEmojis", name: "SetEmojis", pkg: "", typ: $funcType([mapType], [], false)}, {prop: "SetEmojiSite", name: "SetEmojiSite", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetHeadingAnchor", name: "SetHeadingAnchor", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetTerms", name: "SetTerms", pkg: "", typ: $funcType([mapType], [], false)}, {prop: "SetVditorWYSIWYG", name: "SetVditorWYSIWYG", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetParallelParsing", name: "SetParallelParsing", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "parse", name: "parse", pkg: "github.com/b3log/lute", typ: $funcType([$String, sliceType], [ptrType$11, $error], false)}, {prop: "newBaseRenderer", name: "newBaseRenderer", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$11], [ptrType$3], false)}, {prop: "RenderVditorDOM", name: "RenderVditorDOM", pkg: "", typ: $funcType([$String], [$String, $error], false)}, {prop: "VditorDOM2Md", name: "VditorDOM2Md", pkg: "", typ: $funcType([$String], [$String, $error], false)}, {prop: "genASTByVditorDOM", name: "genASTByVditorDOM", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$12, ptrType$11], [], false)}, {prop: "firstChildIsText", name: "firstChildIsText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$12], [$Bool], false)}, {prop: "hasAttr", name: "hasAttr", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$12, $String], [$Bool], false)}, {prop: "domAttrValue", name: "domAttrValue", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$12, $String], [$String], false)}, {prop: "domText", name: "domText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$12], [$String], false)}, {prop: "domText0", name: "domText0", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$12, ptrType$4], [], false)}, {prop: "newVditorRenderer", name: "newVditorRenderer", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$11], [Renderer], false)}];
	ptrType.methods = [{prop: "blockquoteContinue", name: "blockquoteContinue", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [$Int], false)}, {prop: "codeBlockContinue", name: "codeBlockContinue", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [$Int], false)}, {prop: "codeBlockFinalize", name: "codeBlockFinalize", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [], false)}, {prop: "isFencedCodeClose", name: "isFencedCodeClose", pkg: "github.com/b3log/lute", typ: $funcType([sliceType, $Uint8, $Int], [$Bool, sliceType], false)}, {prop: "htmlBlockContinue", name: "htmlBlockContinue", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [$Int], false)}, {prop: "htmlBlockFinalize", name: "htmlBlockFinalize", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [], false)}, {prop: "listFinalize", name: "listFinalize", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [], false)}, {prop: "endsWithBlankLine", name: "endsWithBlankLine", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [$Bool], false)}, {prop: "listItemContinue", name: "listItemContinue", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [$Int], false)}, {prop: "mathBlockContinue", name: "mathBlockContinue", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [$Int], false)}, {prop: "mathBlockFinalize", name: "mathBlockFinalize", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [], false)}, {prop: "isMathBlockClose", name: "isMathBlockClose", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool], false)}, {prop: "lastDeepestChild", name: "lastDeepestChild", pkg: "github.com/b3log/lute", typ: $funcType([], [ptrType], false)}, {prop: "firstDeepestChild", name: "firstDeepestChild", pkg: "github.com/b3log/lute", typ: $funcType([], [ptrType], false)}, {prop: "ChildByType", name: "ChildByType", pkg: "", typ: $funcType([nodeType], [ptrType], false)}, {prop: "Text", name: "Text", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Finalize", name: "Finalize", pkg: "", typ: $funcType([ptrType$13], [], false)}, {prop: "Continue", name: "Continue", pkg: "", typ: $funcType([ptrType$13], [$Int], false)}, {prop: "AcceptLines", name: "AcceptLines", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "CanContain", name: "CanContain", pkg: "", typ: $funcType([nodeType], [$Bool], false)}, {prop: "Unlink", name: "Unlink", pkg: "", typ: $funcType([], [], false)}, {prop: "RawText", name: "RawText", pkg: "", typ: $funcType([], [$String], false)}, {prop: "SetRawText", name: "SetRawText", pkg: "", typ: $funcType([$String], [], false)}, {prop: "AppendRawText", name: "AppendRawText", pkg: "", typ: $funcType([$String], [], false)}, {prop: "AppendTokens", name: "AppendTokens", pkg: "", typ: $funcType([sliceType], [], false)}, {prop: "InsertAfter", name: "InsertAfter", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "InsertBefore", name: "InsertBefore", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "AppendChild", name: "AppendChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "PrependChild", name: "PrependChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "List", name: "List", pkg: "", typ: $funcType([], [sliceType$8], false)}, {prop: "isMarker", name: "isMarker", pkg: "github.com/b3log/lute", typ: $funcType([], [$Bool], false)}, {prop: "paragraphContinue", name: "paragraphContinue", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [$Int], false)}, {prop: "paragraphFinalize", name: "paragraphFinalize", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$13], [], false)}];
	nodeType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$13.methods = [{prop: "parseInlineLinkDest", name: "parseInlineLinkDest", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "parseLinkRefDef", name: "parseLinkRefDef", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType], false)}, {prop: "parseLinkTitle", name: "parseLinkTitle", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool, sliceType, sliceType, sliceType], false)}, {prop: "parseLinkTitleMatch", name: "parseLinkTitleMatch", pkg: "github.com/b3log/lute", typ: $funcType([$Uint8, $Uint8, sliceType], [$Bool, sliceType, sliceType, sliceType], false)}, {prop: "parseLinkDest", name: "parseLinkDest", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "parseLinkDest2", name: "parseLinkDest2", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "parseLinkDest1", name: "parseLinkDest1", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "parseLinkLabel", name: "parseLinkLabel", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Int, sliceType, sliceType], false)}, {prop: "advanceOffset", name: "advanceOffset", pkg: "github.com/b3log/lute", typ: $funcType([$Int, $Bool], [], false)}, {prop: "advanceNextNonspace", name: "advanceNextNonspace", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "findNextNonspace", name: "findNextNonspace", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "closeUnmatchedBlocks", name: "closeUnmatchedBlocks", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "finalize", name: "finalize", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Int], [], false)}, {prop: "addChildMarker", name: "addChildMarker", pkg: "github.com/b3log/lute", typ: $funcType([nodeType, sliceType], [ptrType], false)}, {prop: "addChild", name: "addChild", pkg: "github.com/b3log/lute", typ: $funcType([nodeType, $Int], [ptrType], false)}, {prop: "listsMatch", name: "listsMatch", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$1, ptrType$1], [$Bool], false)}, {prop: "parseTable", name: "parseTable", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [ptrType], false)}, {prop: "newTableHead", name: "newTableHead", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [ptrType], false)}, {prop: "parseTableRow", name: "parseTableRow", pkg: "github.com/b3log/lute", typ: $funcType([sliceType, sliceType$3, $Bool], [ptrType], false)}, {prop: "parseTableDelimRow", name: "parseTableDelimRow", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType$3], false)}, {prop: "tableDelimAlign", name: "tableDelimAlign", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Int], false)}, {prop: "parentTip", name: "parentTip", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$12], [], false)}];
	ptrType$11.methods = [{prop: "parseGFMAutoEmailLink", name: "parseGFMAutoEmailLink", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "parseGFMAutoLink", name: "parseGFMAutoLink", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "parseGFMAutoEmailLink0", name: "parseGFMAutoEmailLink0", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "isValidEmailSegment1", name: "isValidEmailSegment1", pkg: "github.com/b3log/lute", typ: $funcType([$Uint8], [$Bool], false)}, {prop: "isValidEmailSegment2", name: "isValidEmailSegment2", pkg: "github.com/b3log/lute", typ: $funcType([$Uint8], [$Bool], false)}, {prop: "parseGFMAutoLink0", name: "parseGFMAutoLink0", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "isValidDomain", name: "isValidDomain", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool], false)}, {prop: "parseAutoEmailLink", name: "parseAutoEmailLink", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "newLink", name: "newLink", pkg: "github.com/b3log/lute", typ: $funcType([nodeType, sliceType, sliceType, sliceType, $Int], [ptrType], false)}, {prop: "parseAutolink", name: "parseAutolink", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "parseBlocks", name: "parseBlocks", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "incorporateLine", name: "incorporateLine", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [], false)}, {prop: "addLine", name: "addLine", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "parseFencedCode", name: "parseFencedCode", pkg: "github.com/b3log/lute", typ: $funcType([], [$Bool, $Uint8, $Int, $Int, sliceType, sliceType], false)}, {prop: "parseCodeSpan", name: "parseCodeSpan", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "matchCodeSpanEnd", name: "matchCodeSpanEnd", pkg: "github.com/b3log/lute", typ: $funcType([sliceType, $Int], [$Int], false)}, {prop: "handleDelim", name: "handleDelim", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, ptrType$14], [], false)}, {prop: "processEmphasis", name: "processEmphasis", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$2, ptrType$14], [], false)}, {prop: "scanDelims", name: "scanDelims", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType$2], false)}, {prop: "removeDelimiter", name: "removeDelimiter", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$2, ptrType$14], [ptrType$2], false)}, {prop: "emoji", name: "emoji", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "emoji0", name: "emoji0", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "emojiImgTokens", name: "emojiImgTokens", pkg: "github.com/b3log/lute", typ: $funcType([$String, $String], [sliceType], false)}, {prop: "parseATXHeading", name: "parseATXHeading", pkg: "github.com/b3log/lute", typ: $funcType([], [$Bool, sliceType, sliceType, $Int], false)}, {prop: "parseSetextHeading", name: "parseSetextHeading", pkg: "github.com/b3log/lute", typ: $funcType([], [$Int], false)}, {prop: "isHTMLBlockClose", name: "isHTMLBlockClose", pkg: "github.com/b3log/lute", typ: $funcType([sliceType, $Int], [$Bool], false)}, {prop: "parseHTML", name: "parseHTML", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Int], false)}, {prop: "isOpenTag", name: "isOpenTag", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool], false)}, {prop: "isCloseTag", name: "isCloseTag", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool], false)}, {prop: "parseBang", name: "parseBang", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "parseInline", name: "parseInline", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, ptrType$14], [], false)}, {prop: "parseEntity", name: "parseEntity", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "parseCloseBracket", name: "parseCloseBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "parseOpenBracket", name: "parseOpenBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "addBracket", name: "addBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Int, $Bool, ptrType$14], [], false)}, {prop: "removeBracket", name: "removeBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [], false)}, {prop: "parseBackslash", name: "parseBackslash", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "parseText", name: "parseText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "isMarker", name: "isMarker", pkg: "github.com/b3log/lute", typ: $funcType([$Uint8], [$Bool], false)}, {prop: "parseNewline", name: "parseNewline", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, ptrType$14], [ptrType], false)}, {prop: "parseInlineHTML", name: "parseInlineHTML", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "parseCDATA", name: "parseCDATA", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseDeclaration", name: "parseDeclaration", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseProcessingInstruction", name: "parseProcessingInstruction", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseHTMLComment", name: "parseHTMLComment", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseTagAttr", name: "parseTagAttr", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseAttrValSpec", name: "parseAttrValSpec", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseAttrName", name: "parseAttrName", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType, sliceType], false)}, {prop: "parseTagName", name: "parseTagName", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType, sliceType], false)}, {prop: "parseInlineMath", name: "parseInlineMath", pkg: "github.com/b3log/lute", typ: $funcType([ptrType$14], [ptrType], false)}, {prop: "matchInlineMathEnd", name: "matchInlineMathEnd", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [$Int], false)}, {prop: "parseInlines", name: "parseInlines", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "walkParseInline", name: "walkParseInline", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, ptrType$5], [], false)}, {prop: "parseListMarker", name: "parseListMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [ptrType$1], false)}, {prop: "parseOrderedListMarker", name: "parseOrderedListMarker", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType, $Uint8], false)}, {prop: "parseMathBlock", name: "parseMathBlock", pkg: "github.com/b3log/lute", typ: $funcType([], [$Bool, $Int], false)}, {prop: "unidim2Bidim", name: "unidim2Bidim", pkg: "github.com/b3log/lute", typ: $funcType([sliceType, $Int], [$Int, $Int], false)}, {prop: "unidim2BidimTxt", name: "unidim2BidimTxt", pkg: "github.com/b3log/lute", typ: $funcType([$String, $Int], [$Int, $Int], false)}, {prop: "mergeText", name: "mergeText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "parseThematicBreak", name: "parseThematicBreak", pkg: "github.com/b3log/lute", typ: $funcType([], [$Bool, sliceType], false)}];
	ptrType$3.methods = [{prop: "Render", name: "Render", pkg: "", typ: $funcType([], [sliceType, $error], false)}, {prop: "renderDefault", name: "renderDefault", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "writeByte", name: "writeByte", pkg: "github.com/b3log/lute", typ: $funcType([$Uint8], [], false)}, {prop: "writeBytes", name: "writeBytes", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [], false)}, {prop: "write", name: "write", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [], false)}, {prop: "writeString", name: "writeString", pkg: "github.com/b3log/lute", typ: $funcType([$String], [], false)}, {prop: "newline", name: "newline", pkg: "github.com/b3log/lute", typ: $funcType([], [], false)}, {prop: "space", name: "space", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "fixTermTypo", name: "fixTermTypo", pkg: "github.com/b3log/lute", typ: $funcType([ptrType], [], false)}, {prop: "fixTermTypo0", name: "fixTermTypo0", pkg: "github.com/b3log/lute", typ: $funcType([sliceType], [sliceType], false)}];
	ptrType$18.methods = [{prop: "renderCodeBlockCloseMarker", name: "renderCodeBlockCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockInfoMarker", name: "renderCodeBlockInfoMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockOpenMarker", name: "renderCodeBlockOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTable", name: "renderTable", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough1OpenMarker", name: "renderStrikethrough1OpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough1CloseMarker", name: "renderStrikethrough1CloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough2OpenMarker", name: "renderStrikethrough2OpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrikethrough2CloseMarker", name: "renderStrikethrough2CloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkTitle", name: "renderLinkTitle", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkDest", name: "renderLinkDest", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkSpace", name: "renderLinkSpace", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLinkText", name: "renderLinkText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCloseParen", name: "renderCloseParen", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderOpenParen", name: "renderOpenParen", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCloseBracket", name: "renderCloseBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderOpenBracket", name: "renderOpenBracket", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBang", name: "renderBang", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderImage", name: "renderImage", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderLink", name: "renderLink", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderText", name: "renderText", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanOpenMarker", name: "renderCodeSpanOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanContent", name: "renderCodeSpanContent", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeSpanCloseMarker", name: "renderCodeSpanCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmAsteriskOpenMarker", name: "renderEmAsteriskOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmAsteriskCloseMarker", name: "renderEmAsteriskCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmUnderscoreOpenMarker", name: "renderEmUnderscoreOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderEmUnderscoreCloseMarker", name: "renderEmUnderscoreCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongA6kOpenMarker", name: "renderStrongA6kOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongA6kCloseMarker", name: "renderStrongA6kCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongU8eOpenMarker", name: "renderStrongU8eOpenMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderStrongU8eCloseMarker", name: "renderStrongU8eCloseMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderBlockquoteMarker", name: "renderBlockquoteMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHeadingC8hMarker", name: "renderHeadingC8hMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderList", name: "renderList", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "tag", name: "tag", pkg: "github.com/b3log/lute", typ: $funcType([$String, sliceType$6, $Bool], [], false)}, {prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}, {prop: "renderCodeBlockCode", name: "renderCodeBlockCode", pkg: "github.com/b3log/lute", typ: $funcType([ptrType, $Bool], [WalkStatus, $error], false)}];
	blockStartFunc.init([ptrType$11, ptrType], [$Int], false);
	delimiter.init("github.com/b3log/lute", [{prop: "node", name: "node", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "typ", name: "typ", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "num", name: "num", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "originalNum", name: "originalNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "canOpen", name: "canOpen", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "canClose", name: "canClose", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "previous", name: "previous", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "next", name: "next", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "active", name: "active", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "image", name: "image", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "bracketAfter", name: "bracketAfter", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "index", name: "index", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "previousDelimiter", name: "previousDelimiter", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	EChartsJSONRenderer.init("", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$3, tag: ""}]);
	FormatRenderer.init("github.com/b3log/lute", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$3, tag: ""}, {prop: "nodeWriterStack", name: "nodeWriterStack", embedded: false, exported: false, typ: sliceType$4, tag: ""}]);
	HTMLRenderer.init("", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$3, tag: ""}]);
	lexer.init("github.com/b3log/lute", [{prop: "input", name: "input", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "length", name: "length", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "offset", name: "offset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "ln", name: "ln", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "col", name: "col", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}]);
	listData.init("github.com/b3log/lute", [{prop: "typ", name: "typ", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "tight", name: "tight", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "bulletChar", name: "bulletChar", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "start", name: "start", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "delimiter", name: "delimiter", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "padding", name: "padding", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "markerOffset", name: "markerOffset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "checked", name: "checked", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "marker", name: "marker", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "num", name: "num", embedded: false, exported: false, typ: $Int, tag: ""}]);
	Lute.init("github.com/b3log/lute", [{prop: "options", name: "options", embedded: true, exported: false, typ: ptrType$10, tag: ""}]);
	options.init("", [{prop: "GFMTable", name: "GFMTable", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "GFMTaskListItem", name: "GFMTaskListItem", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "GFMTaskListItemClass", name: "GFMTaskListItemClass", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "GFMStrikethrough", name: "GFMStrikethrough", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "GFMAutoLink", name: "GFMAutoLink", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "SoftBreak2HardBreak", name: "SoftBreak2HardBreak", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlight", name: "CodeSyntaxHighlight", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlightInlineStyle", name: "CodeSyntaxHighlightInlineStyle", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlightLineNum", name: "CodeSyntaxHighlightLineNum", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlightStyleName", name: "CodeSyntaxHighlightStyleName", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "AutoSpace", name: "AutoSpace", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "FixTermTypo", name: "FixTermTypo", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "Emoji", name: "Emoji", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "AliasEmoji", name: "AliasEmoji", embedded: false, exported: true, typ: mapType, tag: ""}, {prop: "EmojiAlias", name: "EmojiAlias", embedded: false, exported: true, typ: mapType, tag: ""}, {prop: "EmojiSite", name: "EmojiSite", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "HeadingAnchor", name: "HeadingAnchor", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "Terms", name: "Terms", embedded: false, exported: true, typ: mapType, tag: ""}, {prop: "VditorWYSIWYG", name: "VditorWYSIWYG", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "ParallelParsing", name: "ParallelParsing", embedded: false, exported: true, typ: $Bool, tag: ""}]);
	option.init([ptrType$9], [], false);
	Node.init("github.com/b3log/lute", [{prop: "typ", name: "typ", embedded: false, exported: false, typ: nodeType, tag: ""}, {prop: "parent", name: "parent", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "previous", name: "previous", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "next", name: "next", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "firstChild", name: "firstChild", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "lastChild", name: "lastChild", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "rawText", name: "rawText", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "tokens", name: "tokens", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "close", name: "close", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "lastLineBlank", name: "lastLineBlank", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "lastLineChecked", name: "lastLineChecked", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "codeMarkerLen", name: "codeMarkerLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "isFencedCodeBlock", name: "isFencedCodeBlock", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "codeBlockFenceChar", name: "codeBlockFenceChar", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "codeBlockFenceLen", name: "codeBlockFenceLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "codeBlockFenceOffset", name: "codeBlockFenceOffset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "codeBlockOpenFence", name: "codeBlockOpenFence", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "codeBlockInfo", name: "codeBlockInfo", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "codeBlockCloseFence", name: "codeBlockCloseFence", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "htmlBlockType", name: "htmlBlockType", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "listData", name: "listData", embedded: true, exported: false, typ: ptrType$1, tag: ""}, {prop: "taskListItemChecked", name: "taskListItemChecked", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "tableAligns", name: "tableAligns", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "tableCellAlign", name: "tableCellAlign", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "linkType", name: "linkType", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "headingLevel", name: "headingLevel", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "mathBlockDollarOffset", name: "mathBlockDollarOffset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "expand", name: "expand", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "caretStartOffset", name: "caretStartOffset", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "caretEndOffset", name: "caretEndOffset", embedded: false, exported: false, typ: $String, tag: ""}]);
	Context.init("github.com/b3log/lute", [{prop: "tree", name: "tree", embedded: false, exported: false, typ: ptrType$11, tag: ""}, {prop: "option", name: "option", embedded: false, exported: false, typ: ptrType$10, tag: ""}, {prop: "linkRefDef", name: "linkRefDef", embedded: false, exported: false, typ: mapType$1, tag: ""}, {prop: "tip", name: "tip", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "oldtip", name: "oldtip", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "currentLine", name: "currentLine", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "currentLineLen", name: "currentLineLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lineNum", name: "lineNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "offset", name: "offset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "column", name: "column", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "nextNonspace", name: "nextNonspace", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "nextNonspaceColumn", name: "nextNonspaceColumn", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "indent", name: "indent", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "indented", name: "indented", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "blank", name: "blank", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "partiallyConsumedTab", name: "partiallyConsumedTab", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "allClosed", name: "allClosed", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "lastMatchedContainer", name: "lastMatchedContainer", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	InlineContext.init("github.com/b3log/lute", [{prop: "tokens", name: "tokens", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "tokensLen", name: "tokensLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "pos", name: "pos", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lineNum", name: "lineNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "columnNum", name: "columnNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "delimiters", name: "delimiters", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "brackets", name: "brackets", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	Tree.init("github.com/b3log/lute", [{prop: "Name", name: "Name", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Root", name: "Root", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "lexer", name: "lexer", embedded: false, exported: false, typ: ptrType$8, tag: ""}, {prop: "context", name: "context", embedded: false, exported: false, typ: ptrType$13, tag: ""}, {prop: "inlineContext", name: "inlineContext", embedded: false, exported: false, typ: ptrType$14, tag: ""}]);
	RendererFunc.init([ptrType, $Bool], [WalkStatus, $error], false);
	Renderer.init([{prop: "Render", name: "Render", pkg: "", typ: $funcType([], [sliceType, $error], false)}]);
	BaseRenderer.init("github.com/b3log/lute", [{prop: "writer", name: "writer", embedded: false, exported: false, typ: ptrType$4, tag: ""}, {prop: "lastOut", name: "lastOut", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "rendererFuncs", name: "rendererFuncs", embedded: false, exported: false, typ: mapType$2, tag: ""}, {prop: "defaultRendererFunc", name: "defaultRendererFunc", embedded: false, exported: false, typ: RendererFunc, tag: ""}, {prop: "disableTags", name: "disableTags", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "option", name: "option", embedded: false, exported: false, typ: ptrType$10, tag: ""}, {prop: "tree", name: "tree", embedded: false, exported: false, typ: ptrType$11, tag: ""}]);
	VditorRenderer.init("", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$3, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = html.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atom.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		unicodeAliasEmojiMap = false;
		mailto = strToBytes("mailto:");
		httpProto = strToBytes("http://");
		validAutoLinkDomainSuffix = new sliceType$1([strToBytes("top"), strToBytes("com"), strToBytes("net"), strToBytes("org"), strToBytes("edu"), strToBytes("gov"), strToBytes("cn"), strToBytes("io"), strToBytes("me"), strToBytes("biz"), strToBytes("co"), strToBytes("live"), strToBytes("pro"), strToBytes("xyz"), strToBytes("win"), strToBytes("club"), strToBytes("tv"), strToBytes("wiki"), strToBytes("site"), strToBytes("tech"), strToBytes("space"), strToBytes("cc"), strToBytes("name"), strToBytes("social"), strToBytes("band"), strToBytes("pub"), strToBytes("info")]);
		markers = strToBytes(".!#$%&'*+/=?^_`{|}~");
		codeBlockBacktick = strToBytes("`");
		emojiSitePlaceholder = strToBytes("${emojiSite}");
		emojiDot = strToBytes(".");
		aliasUnicodeEmojiMap = $makeMap($String.keyFor, [{ k: "+1", v: "\xF0\x9F\x91\x8D" }, { k: "-1", v: "\xF0\x9F\x91\x8E" }, { k: "100", v: "\xF0\x9F\x92\xAF" }, { k: "1234", v: "\xF0\x9F\x94\xA2" }, { k: "1st_place_medal", v: "\xF0\x9F\xA5\x87" }, { k: "2nd_place_medal", v: "\xF0\x9F\xA5\x88" }, { k: "3rd_place_medal", v: "\xF0\x9F\xA5\x89" }, { k: "8ball", v: "\xF0\x9F\x8E\xB1" }, { k: "a", v: "\xF0\x9F\x85\xB0\xEF\xB8\x8F" }, { k: "ab", v: "\xF0\x9F\x86\x8E" }, { k: "abc", v: "\xF0\x9F\x94\xA4" }, { k: "abcd", v: "\xF0\x9F\x94\xA1" }, { k: "accept", v: "\xF0\x9F\x89\x91" }, { k: "aerial_tramway", v: "\xF0\x9F\x9A\xA1" }, { k: "afghanistan", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAB" }, { k: "airplane", v: "\xE2\x9C\x88\xEF\xB8\x8F" }, { k: "aland_islands", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBD" }, { k: "alarm_clock", v: "\xE2\x8F\xB0" }, { k: "albania", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB1" }, { k: "alembic", v: "\xE2\x9A\x97\xEF\xB8\x8F" }, { k: "algeria", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xBF" }, { k: "alien", v: "\xF0\x9F\x91\xBD" }, { k: "ambulance", v: "\xF0\x9F\x9A\x91" }, { k: "american_samoa", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB8" }, { k: "amphora", v: "\xF0\x9F\x8F\xBA" }, { k: "anchor", v: "\xE2\x9A\x93\xEF\xB8\x8F" }, { k: "andorra", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xA9" }, { k: "angel", v: "\xF0\x9F\x91\xBC" }, { k: "anger", v: "\xF0\x9F\x92\xA2" }, { k: "angola", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB4" }, { k: "angry", v: "\xF0\x9F\x98\xA0" }, { k: "anguilla", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAE" }, { k: "anguished", v: "\xF0\x9F\x98\xA7" }, { k: "ant", v: "\xF0\x9F\x90\x9C" }, { k: "antarctica", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB6" }, { k: "antigua_barbuda", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAC" }, { k: "apple", v: "\xF0\x9F\x8D\x8E" }, { k: "aquarius", v: "\xE2\x99\x92\xEF\xB8\x8F" }, { k: "argentina", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB7" }, { k: "aries", v: "\xE2\x99\x88\xEF\xB8\x8F" }, { k: "armenia", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB2" }, { k: "arrow_backward", v: "\xE2\x97\x80\xEF\xB8\x8F" }, { k: "arrow_double_down", v: "\xE2\x8F\xAC" }, { k: "arrow_double_up", v: "\xE2\x8F\xAB" }, { k: "arrow_down", v: "\xE2\xAC\x87\xEF\xB8\x8F" }, { k: "arrow_down_small", v: "\xF0\x9F\x94\xBD" }, { k: "arrow_forward", v: "\xE2\x96\xB6\xEF\xB8\x8F" }, { k: "arrow_heading_down", v: "\xE2\xA4\xB5\xEF\xB8\x8F" }, { k: "arrow_heading_up", v: "\xE2\xA4\xB4\xEF\xB8\x8F" }, { k: "arrow_left", v: "\xE2\xAC\x85\xEF\xB8\x8F" }, { k: "arrow_lower_left", v: "\xE2\x86\x99\xEF\xB8\x8F" }, { k: "arrow_lower_right", v: "\xE2\x86\x98\xEF\xB8\x8F" }, { k: "arrow_right", v: "\xE2\x9E\xA1\xEF\xB8\x8F" }, { k: "arrow_right_hook", v: "\xE2\x86\xAA\xEF\xB8\x8F" }, { k: "arrow_up", v: "\xE2\xAC\x86\xEF\xB8\x8F" }, { k: "arrow_up_down", v: "\xE2\x86\x95\xEF\xB8\x8F" }, { k: "arrow_up_small", v: "\xF0\x9F\x94\xBC" }, { k: "arrow_upper_left", v: "\xE2\x86\x96\xEF\xB8\x8F" }, { k: "arrow_upper_right", v: "\xE2\x86\x97\xEF\xB8\x8F" }, { k: "arrows_clockwise", v: "\xF0\x9F\x94\x83" }, { k: "arrows_counterclockwise", v: "\xF0\x9F\x94\x84" }, { k: "art", v: "\xF0\x9F\x8E\xA8" }, { k: "articulated_lorry", v: "\xF0\x9F\x9A\x9B" }, { k: "artificial_satellite", v: "\xF0\x9F\x9B\xB0" }, { k: "aruba", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBC" }, { k: "asterisk", v: "*\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "astonished", v: "\xF0\x9F\x98\xB2" }, { k: "athletic_shoe", v: "\xF0\x9F\x91\x9F" }, { k: "atm", v: "\xF0\x9F\x8F\xA7" }, { k: "atom_symbol", v: "\xE2\x9A\x9B\xEF\xB8\x8F" }, { k: "australia", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBA" }, { k: "austria", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB9" }, { k: "avocado", v: "\xF0\x9F\xA5\x91" }, { k: "azerbaijan", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBF" }, { k: "b", v: "\xF0\x9F\x85\xB1\xEF\xB8\x8F" }, { k: "b3log", v: "${emojiSite}/b3log.png" }, { k: "baby", v: "\xF0\x9F\x91\xB6" }, { k: "baby_bottle", v: "\xF0\x9F\x8D\xBC" }, { k: "baby_chick", v: "\xF0\x9F\x90\xA4" }, { k: "baby_symbol", v: "\xF0\x9F\x9A\xBC" }, { k: "back", v: "\xF0\x9F\x94\x99" }, { k: "bacon", v: "\xF0\x9F\xA5\x93" }, { k: "badminton", v: "\xF0\x9F\x8F\xB8" }, { k: "baggage_claim", v: "\xF0\x9F\x9B\x84" }, { k: "baguette_bread", v: "\xF0\x9F\xA5\x96" }, { k: "bahamas", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB8" }, { k: "bahrain", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAD" }, { k: "balance_scale", v: "\xE2\x9A\x96\xEF\xB8\x8F" }, { k: "balloon", v: "\xF0\x9F\x8E\x88" }, { k: "ballot_box", v: "\xF0\x9F\x97\xB3" }, { k: "ballot_box_with_check", v: "\xE2\x98\x91\xEF\xB8\x8F" }, { k: "bamboo", v: "\xF0\x9F\x8E\x8D" }, { k: "banana", v: "\xF0\x9F\x8D\x8C" }, { k: "bangbang", v: "\xE2\x80\xBC\xEF\xB8\x8F" }, { k: "bangladesh", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xA9" }, { k: "bank", v: "\xF0\x9F\x8F\xA6" }, { k: "bar_chart", v: "\xF0\x9F\x93\x8A" }, { k: "barbados", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xA7" }, { k: "barber", v: "\xF0\x9F\x92\x88" }, { k: "baseball", v: "\xE2\x9A\xBE\xEF\xB8\x8F" }, { k: "basketball", v: "\xF0\x9F\x8F\x80" }, { k: "basketball_man", v: "\xE2\x9B\xB9" }, { k: "basketball_woman", v: "\xE2\x9B\xB9\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "bat", v: "\xF0\x9F\xA6\x87" }, { k: "bath", v: "\xF0\x9F\x9B\x80" }, { k: "bathtub", v: "\xF0\x9F\x9B\x81" }, { k: "battery", v: "\xF0\x9F\x94\x8B" }, { k: "beach_umbrella", v: "\xF0\x9F\x8F\x96" }, { k: "bear", v: "\xF0\x9F\x90\xBB" }, { k: "bed", v: "\xF0\x9F\x9B\x8F" }, { k: "bee", v: "\xF0\x9F\x90\x9D" }, { k: "beer", v: "\xF0\x9F\x8D\xBA" }, { k: "beers", v: "\xF0\x9F\x8D\xBB" }, { k: "beetle", v: "\xF0\x9F\x90\x9E" }, { k: "beginner", v: "\xF0\x9F\x94\xB0" }, { k: "belarus", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xBE" }, { k: "belgium", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAA" }, { k: "belize", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xBF" }, { k: "bell", v: "\xF0\x9F\x94\x94" }, { k: "bellhop_bell", v: "\xF0\x9F\x9B\x8E" }, { k: "benin", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAF" }, { k: "bento", v: "\xF0\x9F\x8D\xB1" }, { k: "bermuda", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB2" }, { k: "bhutan", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB9" }, { k: "bicyclist", v: "\xF0\x9F\x9A\xB4" }, { k: "bike", v: "\xF0\x9F\x9A\xB2" }, { k: "biking_man", v: "\xF0\x9F\x9A\xB4" }, { k: "biking_woman", v: "\xF0\x9F\x9A\xB4\xE2\x80\x8D\xE2\x99\x80" }, { k: "bikini", v: "\xF0\x9F\x91\x99" }, { k: "biohazard", v: "\xE2\x98\xA3\xEF\xB8\x8F" }, { k: "bird", v: "\xF0\x9F\x90\xA6" }, { k: "birthday", v: "\xF0\x9F\x8E\x82" }, { k: "black_circle", v: "\xE2\x9A\xAB\xEF\xB8\x8F" }, { k: "black_flag", v: "\xF0\x9F\x8F\xB4" }, { k: "black_heart", v: "\xF0\x9F\x96\xA4" }, { k: "black_joker", v: "\xF0\x9F\x83\x8F" }, { k: "black_large_square", v: "\xE2\xAC\x9B\xEF\xB8\x8F" }, { k: "black_medium_small_square", v: "\xE2\x97\xBE\xEF\xB8\x8F" }, { k: "black_medium_square", v: "\xE2\x97\xBC\xEF\xB8\x8F" }, { k: "black_nib", v: "\xE2\x9C\x92\xEF\xB8\x8F" }, { k: "black_small_square", v: "\xE2\x96\xAA\xEF\xB8\x8F" }, { k: "black_square_button", v: "\xF0\x9F\x94\xB2" }, { k: "blonde_man", v: "\xF0\x9F\x91\xB1" }, { k: "blonde_woman", v: "\xF0\x9F\x91\xB1\xE2\x80\x8D\xE2\x99\x80" }, { k: "blossom", v: "\xF0\x9F\x8C\xBC" }, { k: "blowfish", v: "\xF0\x9F\x90\xA1" }, { k: "blue_book", v: "\xF0\x9F\x93\x98" }, { k: "blue_car", v: "\xF0\x9F\x9A\x99" }, { k: "blue_heart", v: "\xF0\x9F\x92\x99" }, { k: "blush", v: "\xF0\x9F\x98\x8A" }, { k: "boar", v: "\xF0\x9F\x90\x97" }, { k: "boat", v: "\xE2\x9B\xB5\xEF\xB8\x8F" }, { k: "bolivia", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB4" }, { k: "bomb", v: "\xF0\x9F\x92\xA3" }, { k: "book", v: "\xF0\x9F\x93\x96" }, { k: "bookmark", v: "\xF0\x9F\x94\x96" }, { k: "bookmark_tabs", v: "\xF0\x9F\x93\x91" }, { k: "books", v: "\xF0\x9F\x93\x9A" }, { k: "boom", v: "\xF0\x9F\x92\xA5" }, { k: "boot", v: "\xF0\x9F\x91\xA2" }, { k: "bosnia_herzegovina", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xA6" }, { k: "botswana", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xBC" }, { k: "bouquet", v: "\xF0\x9F\x92\x90" }, { k: "bow", v: "\xF0\x9F\x99\x87" }, { k: "bow_and_arrow", v: "\xF0\x9F\x8F\xB9" }, { k: "bowing_man", v: "\xF0\x9F\x99\x87" }, { k: "bowing_woman", v: "\xF0\x9F\x99\x87\xE2\x80\x8D\xE2\x99\x80" }, { k: "bowling", v: "\xF0\x9F\x8E\xB3" }, { k: "boxing_glove", v: "\xF0\x9F\xA5\x8A" }, { k: "boy", v: "\xF0\x9F\x91\xA6" }, { k: "brazil", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB7" }, { k: "bread", v: "\xF0\x9F\x8D\x9E" }, { k: "bride_with_veil", v: "\xF0\x9F\x91\xB0" }, { k: "bridge_at_night", v: "\xF0\x9F\x8C\x89" }, { k: "briefcase", v: "\xF0\x9F\x92\xBC" }, { k: "british_indian_ocean_territory", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB4" }, { k: "british_virgin_islands", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xAC" }, { k: "broken_heart", v: "\xF0\x9F\x92\x94" }, { k: "brunei", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB3" }, { k: "bug", v: "\xF0\x9F\x90\x9B" }, { k: "building_construction", v: "\xF0\x9F\x8F\x97" }, { k: "bulb", v: "\xF0\x9F\x92\xA1" }, { k: "bulgaria", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAC" }, { k: "bullettrain_front", v: "\xF0\x9F\x9A\x85" }, { k: "bullettrain_side", v: "\xF0\x9F\x9A\x84" }, { k: "burkina_faso", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAB" }, { k: "burrito", v: "\xF0\x9F\x8C\xAF" }, { k: "burundi", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAE" }, { k: "bus", v: "\xF0\x9F\x9A\x8C" }, { k: "business_suit_levitating", v: "\xF0\x9F\x95\xB4" }, { k: "busstop", v: "\xF0\x9F\x9A\x8F" }, { k: "bust_in_silhouette", v: "\xF0\x9F\x91\xA4" }, { k: "busts_in_silhouette", v: "\xF0\x9F\x91\xA5" }, { k: "butterfly", v: "\xF0\x9F\xA6\x8B" }, { k: "cactus", v: "\xF0\x9F\x8C\xB5" }, { k: "cake", v: "\xF0\x9F\x8D\xB0" }, { k: "calendar", v: "\xF0\x9F\x93\x86" }, { k: "call_me_hand", v: "\xF0\x9F\xA4\x99" }, { k: "calling", v: "\xF0\x9F\x93\xB2" }, { k: "cambodia", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAD" }, { k: "camel", v: "\xF0\x9F\x90\xAB" }, { k: "camera", v: "\xF0\x9F\x93\xB7" }, { k: "camera_flash", v: "\xF0\x9F\x93\xB8" }, { k: "cameroon", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB2" }, { k: "camping", v: "\xF0\x9F\x8F\x95" }, { k: "canada", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xA6" }, { k: "canary_islands", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xA8" }, { k: "cancer", v: "\xE2\x99\x8B\xEF\xB8\x8F" }, { k: "candle", v: "\xF0\x9F\x95\xAF" }, { k: "candy", v: "\xF0\x9F\x8D\xAC" }, { k: "canoe", v: "\xF0\x9F\x9B\xB6" }, { k: "cape_verde", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBB" }, { k: "capital_abcd", v: "\xF0\x9F\x94\xA0" }, { k: "capricorn", v: "\xE2\x99\x91\xEF\xB8\x8F" }, { k: "car", v: "\xF0\x9F\x9A\x97" }, { k: "card_file_box", v: "\xF0\x9F\x97\x83" }, { k: "card_index", v: "\xF0\x9F\x93\x87" }, { k: "card_index_dividers", v: "\xF0\x9F\x97\x82" }, { k: "caribbean_netherlands", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB6" }, { k: "carousel_horse", v: "\xF0\x9F\x8E\xA0" }, { k: "carrot", v: "\xF0\x9F\xA5\x95" }, { k: "cat", v: "\xF0\x9F\x90\xB1" }, { k: "cat2", v: "\xF0\x9F\x90\x88" }, { k: "cayman_islands", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xBE" }, { k: "cd", v: "\xF0\x9F\x92\xBF" }, { k: "central_african_republic", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAB" }, { k: "chad", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xA9" }, { k: "chainbook", v: "${emojiSite}/chainbook.png" }, { k: "chains", v: "\xE2\x9B\x93" }, { k: "champagne", v: "\xF0\x9F\x8D\xBE" }, { k: "chart", v: "\xF0\x9F\x92\xB9" }, { k: "chart_with_downwards_trend", v: "\xF0\x9F\x93\x89" }, { k: "chart_with_upwards_trend", v: "\xF0\x9F\x93\x88" }, { k: "checkered_flag", v: "\xF0\x9F\x8F\x81" }, { k: "cheese", v: "\xF0\x9F\xA7\x80" }, { k: "cherries", v: "\xF0\x9F\x8D\x92" }, { k: "cherry_blossom", v: "\xF0\x9F\x8C\xB8" }, { k: "chestnut", v: "\xF0\x9F\x8C\xB0" }, { k: "chicken", v: "\xF0\x9F\x90\x94" }, { k: "children_crossing", v: "\xF0\x9F\x9A\xB8" }, { k: "chile", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB1" }, { k: "chipmunk", v: "\xF0\x9F\x90\xBF" }, { k: "chocolate_bar", v: "\xF0\x9F\x8D\xAB" }, { k: "christmas_island", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBD" }, { k: "christmas_tree", v: "\xF0\x9F\x8E\x84" }, { k: "church", v: "\xE2\x9B\xAA\xEF\xB8\x8F" }, { k: "cinema", v: "\xF0\x9F\x8E\xA6" }, { k: "circus_tent", v: "\xF0\x9F\x8E\xAA" }, { k: "city_sunrise", v: "\xF0\x9F\x8C\x87" }, { k: "city_sunset", v: "\xF0\x9F\x8C\x86" }, { k: "cityscape", v: "\xF0\x9F\x8F\x99" }, { k: "cl", v: "\xF0\x9F\x86\x91" }, { k: "clamp", v: "\xF0\x9F\x97\x9C" }, { k: "clap", v: "\xF0\x9F\x91\x8F" }, { k: "clapper", v: "\xF0\x9F\x8E\xAC" }, { k: "classical_building", v: "\xF0\x9F\x8F\x9B" }, { k: "clinking_glasses", v: "\xF0\x9F\xA5\x82" }, { k: "clipboard", v: "\xF0\x9F\x93\x8B" }, { k: "clock1", v: "\xF0\x9F\x95\x90" }, { k: "clock10", v: "\xF0\x9F\x95\x99" }, { k: "clock1030", v: "\xF0\x9F\x95\xA5" }, { k: "clock11", v: "\xF0\x9F\x95\x9A" }, { k: "clock1130", v: "\xF0\x9F\x95\xA6" }, { k: "clock12", v: "\xF0\x9F\x95\x9B" }, { k: "clock1230", v: "\xF0\x9F\x95\xA7" }, { k: "clock130", v: "\xF0\x9F\x95\x9C" }, { k: "clock2", v: "\xF0\x9F\x95\x91" }, { k: "clock230", v: "\xF0\x9F\x95\x9D" }, { k: "clock3", v: "\xF0\x9F\x95\x92" }, { k: "clock330", v: "\xF0\x9F\x95\x9E" }, { k: "clock4", v: "\xF0\x9F\x95\x93" }, { k: "clock430", v: "\xF0\x9F\x95\x9F" }, { k: "clock5", v: "\xF0\x9F\x95\x94" }, { k: "clock530", v: "\xF0\x9F\x95\xA0" }, { k: "clock6", v: "\xF0\x9F\x95\x95" }, { k: "clock630", v: "\xF0\x9F\x95\xA1" }, { k: "clock7", v: "\xF0\x9F\x95\x96" }, { k: "clock730", v: "\xF0\x9F\x95\xA2" }, { k: "clock8", v: "\xF0\x9F\x95\x97" }, { k: "clock830", v: "\xF0\x9F\x95\xA3" }, { k: "clock9", v: "\xF0\x9F\x95\x98" }, { k: "clock930", v: "\xF0\x9F\x95\xA4" }, { k: "closed_book", v: "\xF0\x9F\x93\x95" }, { k: "closed_lock_with_key", v: "\xF0\x9F\x94\x90" }, { k: "closed_umbrella", v: "\xF0\x9F\x8C\x82" }, { k: "cloud", v: "\xE2\x98\x81\xEF\xB8\x8F" }, { k: "cloud_with_lightning", v: "\xF0\x9F\x8C\xA9" }, { k: "cloud_with_lightning_and_rain", v: "\xE2\x9B\x88" }, { k: "cloud_with_rain", v: "\xF0\x9F\x8C\xA7" }, { k: "cloud_with_snow", v: "\xF0\x9F\x8C\xA8" }, { k: "clown_face", v: "\xF0\x9F\xA4\xA1" }, { k: "clubs", v: "\xE2\x99\xA3\xEF\xB8\x8F" }, { k: "cn", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB3" }, { k: "cocktail", v: "\xF0\x9F\x8D\xB8" }, { k: "cocos_islands", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xA8" }, { k: "coffee", v: "\xE2\x98\x95\xEF\xB8\x8F" }, { k: "coffin", v: "\xE2\x9A\xB0\xEF\xB8\x8F" }, { k: "cold_sweat", v: "\xF0\x9F\x98\xB0" }, { k: "collision", v: "\xF0\x9F\x92\xA5" }, { k: "colombia", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB4" }, { k: "comet", v: "\xE2\x98\x84" }, { k: "comoros", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB2" }, { k: "computer", v: "\xF0\x9F\x92\xBB" }, { k: "computer_mouse", v: "\xF0\x9F\x96\xB1" }, { k: "confetti_ball", v: "\xF0\x9F\x8E\x8A" }, { k: "confounded", v: "\xF0\x9F\x98\x96" }, { k: "confused", v: "\xF0\x9F\x98\x95" }, { k: "congo_brazzaville", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAC" }, { k: "congo_kinshasa", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xA9" }, { k: "congratulations", v: "\xE3\x8A\x97\xEF\xB8\x8F" }, { k: "construction", v: "\xF0\x9F\x9A\xA7" }, { k: "construction_worker", v: "\xF0\x9F\x91\xB7" }, { k: "construction_worker_man", v: "\xF0\x9F\x91\xB7" }, { k: "construction_worker_woman", v: "\xF0\x9F\x91\xB7\xE2\x80\x8D\xE2\x99\x80" }, { k: "control_knobs", v: "\xF0\x9F\x8E\x9B" }, { k: "convenience_store", v: "\xF0\x9F\x8F\xAA" }, { k: "cook_islands", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB0" }, { k: "cookie", v: "\xF0\x9F\x8D\xAA" }, { k: "cool", v: "\xF0\x9F\x86\x92" }, { k: "cop", v: "\xF0\x9F\x91\xAE" }, { k: "copyright", v: "\xC2\xA9\xEF\xB8\x8F" }, { k: "corn", v: "\xF0\x9F\x8C\xBD" }, { k: "costa_rica", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB7" }, { k: "cote_divoire", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAE" }, { k: "couch_and_lamp", v: "\xF0\x9F\x9B\x8B" }, { k: "couple", v: "\xF0\x9F\x91\xAB" }, { k: "couple_with_heart", v: "\xF0\x9F\x92\x91" }, { k: "couple_with_heart_man_man", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x91\xA8" }, { k: "couple_with_heart_woman_man", v: "\xF0\x9F\x92\x91" }, { k: "couple_with_heart_woman_woman", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x91\xA9" }, { k: "couplekiss_man_man", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x92\x8B\xE2\x80\x8D\xF0\x9F\x91\xA8" }, { k: "couplekiss_man_woman", v: "\xF0\x9F\x92\x8F" }, { k: "couplekiss_woman_woman", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x92\x8B\xE2\x80\x8D\xF0\x9F\x91\xA9" }, { k: "cow", v: "\xF0\x9F\x90\xAE" }, { k: "cow2", v: "\xF0\x9F\x90\x84" }, { k: "cowboy_hat_face", v: "\xF0\x9F\xA4\xA0" }, { k: "crab", v: "\xF0\x9F\xA6\x80" }, { k: "crayon", v: "\xF0\x9F\x96\x8D" }, { k: "credit_card", v: "\xF0\x9F\x92\xB3" }, { k: "crescent_moon", v: "\xF0\x9F\x8C\x99" }, { k: "cricket", v: "\xF0\x9F\x8F\x8F" }, { k: "croatia", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB7" }, { k: "crocodile", v: "\xF0\x9F\x90\x8A" }, { k: "croissant", v: "\xF0\x9F\xA5\x90" }, { k: "crossed_fingers", v: "\xF0\x9F\xA4\x9E" }, { k: "crossed_flags", v: "\xF0\x9F\x8E\x8C" }, { k: "crossed_swords", v: "\xE2\x9A\x94\xEF\xB8\x8F" }, { k: "crown", v: "\xF0\x9F\x91\x91" }, { k: "cry", v: "\xF0\x9F\x98\xA2" }, { k: "crying_cat_face", v: "\xF0\x9F\x98\xBF" }, { k: "crystal_ball", v: "\xF0\x9F\x94\xAE" }, { k: "cuba", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBA" }, { k: "cucumber", v: "\xF0\x9F\xA5\x92" }, { k: "cupid", v: "\xF0\x9F\x92\x98" }, { k: "curacao", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBC" }, { k: "curly_loop", v: "\xE2\x9E\xB0" }, { k: "currency_exchange", v: "\xF0\x9F\x92\xB1" }, { k: "curry", v: "\xF0\x9F\x8D\x9B" }, { k: "custard", v: "\xF0\x9F\x8D\xAE" }, { k: "customs", v: "\xF0\x9F\x9B\x83" }, { k: "cyclone", v: "\xF0\x9F\x8C\x80" }, { k: "cyprus", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBE" }, { k: "czech_republic", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBF" }, { k: "dagger", v: "\xF0\x9F\x97\xA1" }, { k: "dancer", v: "\xF0\x9F\x92\x83" }, { k: "dancers", v: "\xF0\x9F\x91\xAF" }, { k: "dancing_men", v: "\xF0\x9F\x91\xAF\xE2\x80\x8D\xE2\x99\x82" }, { k: "dancing_women", v: "\xF0\x9F\x91\xAF" }, { k: "dango", v: "\xF0\x9F\x8D\xA1" }, { k: "dark_sunglasses", v: "\xF0\x9F\x95\xB6" }, { k: "dart", v: "\xF0\x9F\x8E\xAF" }, { k: "dash", v: "\xF0\x9F\x92\xA8" }, { k: "date", v: "\xF0\x9F\x93\x85" }, { k: "de", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xAA" }, { k: "deciduous_tree", v: "\xF0\x9F\x8C\xB3" }, { k: "deer", v: "\xF0\x9F\xA6\x8C" }, { k: "denmark", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xB0" }, { k: "department_store", v: "\xF0\x9F\x8F\xAC" }, { k: "derelict_house", v: "\xF0\x9F\x8F\x9A" }, { k: "desert", v: "\xF0\x9F\x8F\x9C" }, { k: "desert_island", v: "\xF0\x9F\x8F\x9D" }, { k: "desktop_computer", v: "\xF0\x9F\x96\xA5" }, { k: "detective", v: "\xF0\x9F\x95\xB5" }, { k: "diamond_shape_with_a_dot_inside", v: "\xF0\x9F\x92\xA0" }, { k: "diamonds", v: "\xE2\x99\xA6\xEF\xB8\x8F" }, { k: "disappointed", v: "\xF0\x9F\x98\x9E" }, { k: "disappointed_relieved", v: "\xF0\x9F\x98\xA5" }, { k: "dizzy", v: "\xF0\x9F\x92\xAB" }, { k: "dizzy_face", v: "\xF0\x9F\x98\xB5" }, { k: "djibouti", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xAF" }, { k: "do_not_litter", v: "\xF0\x9F\x9A\xAF" }, { k: "dog", v: "\xF0\x9F\x90\xB6" }, { k: "dog2", v: "\xF0\x9F\x90\x95" }, { k: "doge", v: "${emojiSite}/doge.png" }, { k: "dollar", v: "\xF0\x9F\x92\xB5" }, { k: "dolls", v: "\xF0\x9F\x8E\x8E" }, { k: "dolphin", v: "\xF0\x9F\x90\xAC" }, { k: "dominica", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xB2" }, { k: "dominican_republic", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xB4" }, { k: "door", v: "\xF0\x9F\x9A\xAA" }, { k: "doughnut", v: "\xF0\x9F\x8D\xA9" }, { k: "dove", v: "\xF0\x9F\x95\x8A" }, { k: "dragon", v: "\xF0\x9F\x90\x89" }, { k: "dragon_face", v: "\xF0\x9F\x90\xB2" }, { k: "dress", v: "\xF0\x9F\x91\x97" }, { k: "dromedary_camel", v: "\xF0\x9F\x90\xAA" }, { k: "drooling_face", v: "\xF0\x9F\xA4\xA4" }, { k: "droplet", v: "\xF0\x9F\x92\xA7" }, { k: "drum", v: "\xF0\x9F\xA5\x81" }, { k: "duck", v: "\xF0\x9F\xA6\x86" }, { k: "dvd", v: "\xF0\x9F\x93\x80" }, { k: "e-mail", v: "\xF0\x9F\x93\xA7" }, { k: "eagle", v: "\xF0\x9F\xA6\x85" }, { k: "ear", v: "\xF0\x9F\x91\x82" }, { k: "ear_of_rice", v: "\xF0\x9F\x8C\xBE" }, { k: "earth_africa", v: "\xF0\x9F\x8C\x8D" }, { k: "earth_americas", v: "\xF0\x9F\x8C\x8E" }, { k: "earth_asia", v: "\xF0\x9F\x8C\x8F" }, { k: "ecuador", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xA8" }, { k: "egg", v: "\xF0\x9F\xA5\x9A" }, { k: "eggplant", v: "\xF0\x9F\x8D\x86" }, { k: "egypt", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xAC" }, { k: "eight", v: "8\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "eight_pointed_black_star", v: "\xE2\x9C\xB4\xEF\xB8\x8F" }, { k: "eight_spoked_asterisk", v: "\xE2\x9C\xB3\xEF\xB8\x8F" }, { k: "el_salvador", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBB" }, { k: "electric_plug", v: "\xF0\x9F\x94\x8C" }, { k: "elephant", v: "\xF0\x9F\x90\x98" }, { k: "email", v: "\xE2\x9C\x89\xEF\xB8\x8F" }, { k: "end", v: "\xF0\x9F\x94\x9A" }, { k: "envelope", v: "\xE2\x9C\x89\xEF\xB8\x8F" }, { k: "envelope_with_arrow", v: "\xF0\x9F\x93\xA9" }, { k: "equatorial_guinea", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB6" }, { k: "eritrea", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xB7" }, { k: "es", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xB8" }, { k: "estonia", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xAA" }, { k: "ethiopia", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xB9" }, { k: "eu", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xBA" }, { k: "euro", v: "\xF0\x9F\x92\xB6" }, { k: "european_castle", v: "\xF0\x9F\x8F\xB0" }, { k: "european_post_office", v: "\xF0\x9F\x8F\xA4" }, { k: "european_union", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xBA" }, { k: "evergreen_tree", v: "\xF0\x9F\x8C\xB2" }, { k: "exclamation", v: "\xE2\x9D\x97\xEF\xB8\x8F" }, { k: "expressionless", v: "\xF0\x9F\x98\x91" }, { k: "eye", v: "\xF0\x9F\x91\x81" }, { k: "eye_speech_bubble", v: "\xF0\x9F\x91\x81\xE2\x80\x8D\xF0\x9F\x97\xA8" }, { k: "eyeglasses", v: "\xF0\x9F\x91\x93" }, { k: "eyes", v: "\xF0\x9F\x91\x80" }, { k: "face_with_head_bandage", v: "\xF0\x9F\xA4\x95" }, { k: "face_with_thermometer", v: "\xF0\x9F\xA4\x92" }, { k: "facepunch", v: "\xF0\x9F\x91\x8A" }, { k: "factory", v: "\xF0\x9F\x8F\xAD" }, { k: "falkland_islands", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB0" }, { k: "fallen_leaf", v: "\xF0\x9F\x8D\x82" }, { k: "family", v: "\xF0\x9F\x91\xAA" }, { k: "family_man_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_boy_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_girl_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_girl_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_man_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_man_boy_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_man_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_man_girl_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_man_girl_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_woman_boy", v: "\xF0\x9F\x91\xAA" }, { k: "family_man_woman_boy_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_woman_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_woman_girl_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_woman_girl_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_boy_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_girl_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_girl_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_woman_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_woman_boy_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_woman_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_woman_girl_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_woman_girl_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "faroe_islands", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB4" }, { k: "fast_forward", v: "\xE2\x8F\xA9" }, { k: "fax", v: "\xF0\x9F\x93\xA0" }, { k: "fearful", v: "\xF0\x9F\x98\xA8" }, { k: "feet", v: "\xF0\x9F\x90\xBE" }, { k: "female_detective", v: "\xF0\x9F\x95\xB5\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "ferris_wheel", v: "\xF0\x9F\x8E\xA1" }, { k: "ferry", v: "\xE2\x9B\xB4" }, { k: "field_hockey", v: "\xF0\x9F\x8F\x91" }, { k: "fiji", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xAF" }, { k: "file_cabinet", v: "\xF0\x9F\x97\x84" }, { k: "file_folder", v: "\xF0\x9F\x93\x81" }, { k: "film_projector", v: "\xF0\x9F\x93\xBD" }, { k: "film_strip", v: "\xF0\x9F\x8E\x9E" }, { k: "finland", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xAE" }, { k: "fire", v: "\xF0\x9F\x94\xA5" }, { k: "fire_engine", v: "\xF0\x9F\x9A\x92" }, { k: "fireworks", v: "\xF0\x9F\x8E\x86" }, { k: "first_quarter_moon", v: "\xF0\x9F\x8C\x93" }, { k: "first_quarter_moon_with_face", v: "\xF0\x9F\x8C\x9B" }, { k: "fish", v: "\xF0\x9F\x90\x9F" }, { k: "fish_cake", v: "\xF0\x9F\x8D\xA5" }, { k: "fishing_pole_and_fish", v: "\xF0\x9F\x8E\xA3" }, { k: "fist", v: "\xE2\x9C\x8A" }, { k: "fist_left", v: "\xF0\x9F\xA4\x9B" }, { k: "fist_oncoming", v: "\xF0\x9F\x91\x8A" }, { k: "fist_raised", v: "\xE2\x9C\x8A" }, { k: "fist_right", v: "\xF0\x9F\xA4\x9C" }, { k: "five", v: "5\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "flags", v: "\xF0\x9F\x8E\x8F" }, { k: "flashlight", v: "\xF0\x9F\x94\xA6" }, { k: "fleur_de_lis", v: "\xE2\x9A\x9C\xEF\xB8\x8F" }, { k: "flight_arrival", v: "\xF0\x9F\x9B\xAC" }, { k: "flight_departure", v: "\xF0\x9F\x9B\xAB" }, { k: "flipper", v: "\xF0\x9F\x90\xAC" }, { k: "floppy_disk", v: "\xF0\x9F\x92\xBE" }, { k: "flower_playing_cards", v: "\xF0\x9F\x8E\xB4" }, { k: "flushed", v: "\xF0\x9F\x98\xB3" }, { k: "fog", v: "\xF0\x9F\x8C\xAB" }, { k: "foggy", v: "\xF0\x9F\x8C\x81" }, { k: "football", v: "\xF0\x9F\x8F\x88" }, { k: "footprints", v: "\xF0\x9F\x91\xA3" }, { k: "fork_and_knife", v: "\xF0\x9F\x8D\xB4" }, { k: "fountain", v: "\xE2\x9B\xB2\xEF\xB8\x8F" }, { k: "fountain_pen", v: "\xF0\x9F\x96\x8B" }, { k: "four", v: "4\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "four_leaf_clover", v: "\xF0\x9F\x8D\x80" }, { k: "fox_face", v: "\xF0\x9F\xA6\x8A" }, { k: "fr", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB7" }, { k: "framed_picture", v: "\xF0\x9F\x96\xBC" }, { k: "free", v: "\xF0\x9F\x86\x93" }, { k: "french_guiana", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAB" }, { k: "french_polynesia", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAB" }, { k: "french_southern_territories", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAB" }, { k: "fried_egg", v: "\xF0\x9F\x8D\xB3" }, { k: "fried_shrimp", v: "\xF0\x9F\x8D\xA4" }, { k: "fries", v: "\xF0\x9F\x8D\x9F" }, { k: "frog", v: "\xF0\x9F\x90\xB8" }, { k: "frowning", v: "\xF0\x9F\x98\xA6" }, { k: "frowning_face", v: "\xE2\x98\xB9\xEF\xB8\x8F" }, { k: "frowning_man", v: "\xF0\x9F\x99\x8D\xE2\x80\x8D\xE2\x99\x82" }, { k: "frowning_woman", v: "\xF0\x9F\x99\x8D" }, { k: "fu", v: "\xF0\x9F\x96\x95" }, { k: "fuelpump", v: "\xE2\x9B\xBD\xEF\xB8\x8F" }, { k: "full_moon", v: "\xF0\x9F\x8C\x95" }, { k: "full_moon_with_face", v: "\xF0\x9F\x8C\x9D" }, { k: "funeral_urn", v: "\xE2\x9A\xB1\xEF\xB8\x8F" }, { k: "gabon", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA6" }, { k: "gambia", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB2" }, { k: "game_die", v: "\xF0\x9F\x8E\xB2" }, { k: "gb", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA7" }, { k: "gear", v: "\xE2\x9A\x99\xEF\xB8\x8F" }, { k: "gem", v: "\xF0\x9F\x92\x8E" }, { k: "gemini", v: "\xE2\x99\x8A\xEF\xB8\x8F" }, { k: "georgia", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAA" }, { k: "ghana", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAD" }, { k: "ghost", v: "\xF0\x9F\x91\xBB" }, { k: "gibraltar", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAE" }, { k: "gift", v: "\xF0\x9F\x8E\x81" }, { k: "gift_heart", v: "\xF0\x9F\x92\x9D" }, { k: "girl", v: "\xF0\x9F\x91\xA7" }, { k: "globe_with_meridians", v: "\xF0\x9F\x8C\x90" }, { k: "goal_net", v: "\xF0\x9F\xA5\x85" }, { k: "goat", v: "\xF0\x9F\x90\x90" }, { k: "golf", v: "\xE2\x9B\xB3\xEF\xB8\x8F" }, { k: "golfing_man", v: "\xF0\x9F\x8F\x8C" }, { k: "golfing_woman", v: "\xF0\x9F\x8F\x8C\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "gorilla", v: "\xF0\x9F\xA6\x8D" }, { k: "grapes", v: "\xF0\x9F\x8D\x87" }, { k: "greece", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB7" }, { k: "green_apple", v: "\xF0\x9F\x8D\x8F" }, { k: "green_book", v: "\xF0\x9F\x93\x97" }, { k: "green_heart", v: "\xF0\x9F\x92\x9A" }, { k: "green_salad", v: "\xF0\x9F\xA5\x97" }, { k: "greenland", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB1" }, { k: "grenada", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA9" }, { k: "grey_exclamation", v: "\xE2\x9D\x95" }, { k: "grey_question", v: "\xE2\x9D\x94" }, { k: "grimacing", v: "\xF0\x9F\x98\xAC" }, { k: "grin", v: "\xF0\x9F\x98\x81" }, { k: "grinning", v: "\xF0\x9F\x98\x80" }, { k: "guadeloupe", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB5" }, { k: "guam", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xBA" }, { k: "guardsman", v: "\xF0\x9F\x92\x82" }, { k: "guardswoman", v: "\xF0\x9F\x92\x82\xE2\x80\x8D\xE2\x99\x80" }, { k: "guatemala", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB9" }, { k: "guernsey", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAC" }, { k: "guinea", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB3" }, { k: "guinea_bissau", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xBC" }, { k: "guitar", v: "\xF0\x9F\x8E\xB8" }, { k: "gun", v: "\xF0\x9F\x94\xAB" }, { k: "guyana", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xBE" }, { k: "hacpai", v: "${emojiSite}/hacpai.png" }, { k: "haircut", v: "\xF0\x9F\x92\x87" }, { k: "haircut_man", v: "\xF0\x9F\x92\x87\xE2\x80\x8D\xE2\x99\x82" }, { k: "haircut_woman", v: "\xF0\x9F\x92\x87" }, { k: "haiti", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB9" }, { k: "hamburger", v: "\xF0\x9F\x8D\x94" }, { k: "hammer", v: "\xF0\x9F\x94\xA8" }, { k: "hammer_and_pick", v: "\xE2\x9A\x92" }, { k: "hammer_and_wrench", v: "\xF0\x9F\x9B\xA0" }, { k: "hamster", v: "\xF0\x9F\x90\xB9" }, { k: "hand", v: "\xE2\x9C\x8B" }, { k: "handbag", v: "\xF0\x9F\x91\x9C" }, { k: "handshake", v: "\xF0\x9F\xA4\x9D" }, { k: "hankey", v: "\xF0\x9F\x92\xA9" }, { k: "hash", v: "#\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "hatched_chick", v: "\xF0\x9F\x90\xA5" }, { k: "hatching_chick", v: "\xF0\x9F\x90\xA3" }, { k: "headphones", v: "\xF0\x9F\x8E\xA7" }, { k: "hear_no_evil", v: "\xF0\x9F\x99\x89" }, { k: "heart", v: "\xE2\x9D\xA4\xEF\xB8\x8F" }, { k: "heart_decoration", v: "\xF0\x9F\x92\x9F" }, { k: "heart_eyes", v: "\xF0\x9F\x98\x8D" }, { k: "heart_eyes_cat", v: "\xF0\x9F\x98\xBB" }, { k: "heartbeat", v: "\xF0\x9F\x92\x93" }, { k: "heartpulse", v: "\xF0\x9F\x92\x97" }, { k: "hearts", v: "\xE2\x99\xA5\xEF\xB8\x8F" }, { k: "heavy_check_mark", v: "\xE2\x9C\x94\xEF\xB8\x8F" }, { k: "heavy_division_sign", v: "\xE2\x9E\x97" }, { k: "heavy_dollar_sign", v: "\xF0\x9F\x92\xB2" }, { k: "heavy_exclamation_mark", v: "\xE2\x9D\x97\xEF\xB8\x8F" }, { k: "heavy_heart_exclamation", v: "\xE2\x9D\xA3\xEF\xB8\x8F" }, { k: "heavy_minus_sign", v: "\xE2\x9E\x96" }, { k: "heavy_multiplication_x", v: "\xE2\x9C\x96\xEF\xB8\x8F" }, { k: "heavy_plus_sign", v: "\xE2\x9E\x95" }, { k: "helicopter", v: "\xF0\x9F\x9A\x81" }, { k: "herb", v: "\xF0\x9F\x8C\xBF" }, { k: "hibiscus", v: "\xF0\x9F\x8C\xBA" }, { k: "high_brightness", v: "\xF0\x9F\x94\x86" }, { k: "high_heel", v: "\xF0\x9F\x91\xA0" }, { k: "hocho", v: "\xF0\x9F\x94\xAA" }, { k: "hole", v: "\xF0\x9F\x95\xB3" }, { k: "honduras", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB3" }, { k: "honey_pot", v: "\xF0\x9F\x8D\xAF" }, { k: "honeybee", v: "\xF0\x9F\x90\x9D" }, { k: "hong_kong", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB0" }, { k: "horse", v: "\xF0\x9F\x90\xB4" }, { k: "horse_racing", v: "\xF0\x9F\x8F\x87" }, { k: "hospital", v: "\xF0\x9F\x8F\xA5" }, { k: "hot_pepper", v: "\xF0\x9F\x8C\xB6" }, { k: "hotdog", v: "\xF0\x9F\x8C\xAD" }, { k: "hotel", v: "\xF0\x9F\x8F\xA8" }, { k: "hotsprings", v: "\xE2\x99\xA8\xEF\xB8\x8F" }, { k: "hourglass", v: "\xE2\x8C\x9B\xEF\xB8\x8F" }, { k: "hourglass_flowing_sand", v: "\xE2\x8F\xB3" }, { k: "house", v: "\xF0\x9F\x8F\xA0" }, { k: "house_with_garden", v: "\xF0\x9F\x8F\xA1" }, { k: "houses", v: "\xF0\x9F\x8F\x98" }, { k: "huaji", v: "${emojiSite}/huaji.gif" }, { k: "hugs", v: "\xF0\x9F\xA4\x97" }, { k: "hungary", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xBA" }, { k: "hushed", v: "\xF0\x9F\x98\xAF" }, { k: "ice_cream", v: "\xF0\x9F\x8D\xA8" }, { k: "ice_hockey", v: "\xF0\x9F\x8F\x92" }, { k: "ice_skate", v: "\xE2\x9B\xB8" }, { k: "icecream", v: "\xF0\x9F\x8D\xA6" }, { k: "iceland", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB8" }, { k: "id", v: "\xF0\x9F\x86\x94" }, { k: "ideograph_advantage", v: "\xF0\x9F\x89\x90" }, { k: "imp", v: "\xF0\x9F\x91\xBF" }, { k: "inbox_tray", v: "\xF0\x9F\x93\xA5" }, { k: "incoming_envelope", v: "\xF0\x9F\x93\xA8" }, { k: "india", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB3" }, { k: "indonesia", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xA9" }, { k: "information_desk_person", v: "\xF0\x9F\x92\x81" }, { k: "information_source", v: "\xE2\x84\xB9\xEF\xB8\x8F" }, { k: "innocent", v: "\xF0\x9F\x98\x87" }, { k: "interrobang", v: "\xE2\x81\x89\xEF\xB8\x8F" }, { k: "iphone", v: "\xF0\x9F\x93\xB1" }, { k: "iran", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB7" }, { k: "iraq", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB6" }, { k: "ireland", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xAA" }, { k: "isle_of_man", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB2" }, { k: "israel", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB1" }, { k: "it", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB9" }, { k: "izakaya_lantern", v: "\xF0\x9F\x8F\xAE" }, { k: "jack_o_lantern", v: "\xF0\x9F\x8E\x83" }, { k: "jamaica", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xB2" }, { k: "japan", v: "\xF0\x9F\x97\xBE" }, { k: "japanese_castle", v: "\xF0\x9F\x8F\xAF" }, { k: "japanese_goblin", v: "\xF0\x9F\x91\xBA" }, { k: "japanese_ogre", v: "\xF0\x9F\x91\xB9" }, { k: "jeans", v: "\xF0\x9F\x91\x96" }, { k: "jersey", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xAA" }, { k: "jordan", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xB4" }, { k: "joy", v: "\xF0\x9F\x98\x82" }, { k: "joy_cat", v: "\xF0\x9F\x98\xB9" }, { k: "joystick", v: "\xF0\x9F\x95\xB9" }, { k: "jp", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xB5" }, { k: "kaaba", v: "\xF0\x9F\x95\x8B" }, { k: "kazakhstan", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xBF" }, { k: "kenya", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAA" }, { k: "key", v: "\xF0\x9F\x94\x91" }, { k: "keyboard", v: "\xE2\x8C\xA8\xEF\xB8\x8F" }, { k: "keycap_ten", v: "\xF0\x9F\x94\x9F" }, { k: "kick_scooter", v: "\xF0\x9F\x9B\xB4" }, { k: "kimono", v: "\xF0\x9F\x91\x98" }, { k: "kiribati", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAE" }, { k: "kiss", v: "\xF0\x9F\x92\x8B" }, { k: "kissing", v: "\xF0\x9F\x98\x97" }, { k: "kissing_cat", v: "\xF0\x9F\x98\xBD" }, { k: "kissing_closed_eyes", v: "\xF0\x9F\x98\x9A" }, { k: "kissing_heart", v: "\xF0\x9F\x98\x98" }, { k: "kissing_smiling_eyes", v: "\xF0\x9F\x98\x99" }, { k: "kiwi_fruit", v: "\xF0\x9F\xA5\x9D" }, { k: "knife", v: "\xF0\x9F\x94\xAA" }, { k: "koala", v: "\xF0\x9F\x90\xA8" }, { k: "koko", v: "\xF0\x9F\x88\x81" }, { k: "kosovo", v: "\xF0\x9F\x87\xBD\xF0\x9F\x87\xB0" }, { k: "kr", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB7" }, { k: "kuwait", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xBC" }, { k: "kyrgyzstan", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAC" }, { k: "label", v: "\xF0\x9F\x8F\xB7" }, { k: "lantern", v: "\xF0\x9F\x8F\xAE" }, { k: "laos", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xA6" }, { k: "large_blue_circle", v: "\xF0\x9F\x94\xB5" }, { k: "large_blue_diamond", v: "\xF0\x9F\x94\xB7" }, { k: "large_orange_diamond", v: "\xF0\x9F\x94\xB6" }, { k: "last_quarter_moon", v: "\xF0\x9F\x8C\x97" }, { k: "last_quarter_moon_with_face", v: "\xF0\x9F\x8C\x9C" }, { k: "latin_cross", v: "\xE2\x9C\x9D\xEF\xB8\x8F" }, { k: "latke", v: "${emojiSite}/latke.png" }, { k: "latvia", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xBB" }, { k: "laughing", v: "\xF0\x9F\x98\x86" }, { k: "leaves", v: "\xF0\x9F\x8D\x83" }, { k: "lebanon", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xA7" }, { k: "ledger", v: "\xF0\x9F\x93\x92" }, { k: "left_luggage", v: "\xF0\x9F\x9B\x85" }, { k: "left_right_arrow", v: "\xE2\x86\x94\xEF\xB8\x8F" }, { k: "leftwards_arrow_with_hook", v: "\xE2\x86\xA9\xEF\xB8\x8F" }, { k: "lemon", v: "\xF0\x9F\x8D\x8B" }, { k: "leo", v: "\xE2\x99\x8C\xEF\xB8\x8F" }, { k: "leopard", v: "\xF0\x9F\x90\x86" }, { k: "lesotho", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB8" }, { k: "level_slider", v: "\xF0\x9F\x8E\x9A" }, { k: "liberia", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB7" }, { k: "libra", v: "\xE2\x99\x8E\xEF\xB8\x8F" }, { k: "libya", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xBE" }, { k: "liechtenstein", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xAE" }, { k: "light_rail", v: "\xF0\x9F\x9A\x88" }, { k: "link", v: "\xF0\x9F\x94\x97" }, { k: "lion", v: "\xF0\x9F\xA6\x81" }, { k: "lips", v: "\xF0\x9F\x91\x84" }, { k: "lipstick", v: "\xF0\x9F\x92\x84" }, { k: "lithuania", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB9" }, { k: "lizard", v: "\xF0\x9F\xA6\x8E" }, { k: "lock", v: "\xF0\x9F\x94\x92" }, { k: "lock_with_ink_pen", v: "\xF0\x9F\x94\x8F" }, { k: "lollipop", v: "\xF0\x9F\x8D\xAD" }, { k: "loop", v: "\xE2\x9E\xBF" }, { k: "loud_sound", v: "\xF0\x9F\x94\x8A" }, { k: "loudspeaker", v: "\xF0\x9F\x93\xA2" }, { k: "love_hotel", v: "\xF0\x9F\x8F\xA9" }, { k: "love_letter", v: "\xF0\x9F\x92\x8C" }, { k: "low_brightness", v: "\xF0\x9F\x94\x85" }, { k: "lute", v: "${emojiSite}/lute.png" }, { k: "luxembourg", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xBA" }, { k: "lying_face", v: "\xF0\x9F\xA4\xA5" }, { k: "m", v: "\xE2\x93\x82\xEF\xB8\x8F" }, { k: "macau", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB4" }, { k: "macedonia", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB0" }, { k: "madagascar", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xAC" }, { k: "mag", v: "\xF0\x9F\x94\x8D" }, { k: "mag_right", v: "\xF0\x9F\x94\x8E" }, { k: "mahjong", v: "\xF0\x9F\x80\x84\xEF\xB8\x8F" }, { k: "mailbox", v: "\xF0\x9F\x93\xAB" }, { k: "mailbox_closed", v: "\xF0\x9F\x93\xAA" }, { k: "mailbox_with_mail", v: "\xF0\x9F\x93\xAC" }, { k: "mailbox_with_no_mail", v: "\xF0\x9F\x93\xAD" }, { k: "malawi", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBC" }, { k: "malaysia", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBE" }, { k: "maldives", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBB" }, { k: "male_detective", v: "\xF0\x9F\x95\xB5" }, { k: "mali", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB1" }, { k: "malta", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB9" }, { k: "man", v: "\xF0\x9F\x91\xA8" }, { k: "man_artist", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8E\xA8" }, { k: "man_astronaut", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x9A\x80" }, { k: "man_cartwheeling", v: "\xF0\x9F\xA4\xB8\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_cook", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8D\xB3" }, { k: "man_dancing", v: "\xF0\x9F\x95\xBA" }, { k: "man_facepalming", v: "\xF0\x9F\xA4\xA6\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_factory_worker", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8F\xAD" }, { k: "man_farmer", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8C\xBE" }, { k: "man_firefighter", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x9A\x92" }, { k: "man_health_worker", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9A\x95" }, { k: "man_in_tuxedo", v: "\xF0\x9F\xA4\xB5" }, { k: "man_judge", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9A\x96" }, { k: "man_juggling", v: "\xF0\x9F\xA4\xB9\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_mechanic", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x94\xA7" }, { k: "man_office_worker", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x92\xBC" }, { k: "man_pilot", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9C\x88" }, { k: "man_playing_handball", v: "\xF0\x9F\xA4\xBE\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_playing_water_polo", v: "\xF0\x9F\xA4\xBD\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_scientist", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x94\xAC" }, { k: "man_shrugging", v: "\xF0\x9F\xA4\xB7\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_singer", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8E\xA4" }, { k: "man_student", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8E\x93" }, { k: "man_teacher", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8F\xAB" }, { k: "man_technologist", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x92\xBB" }, { k: "man_with_gua_pi_mao", v: "\xF0\x9F\x91\xB2" }, { k: "man_with_turban", v: "\xF0\x9F\x91\xB3" }, { k: "mandarin", v: "\xF0\x9F\x8D\x8A" }, { k: "mans_shoe", v: "\xF0\x9F\x91\x9E" }, { k: "mantelpiece_clock", v: "\xF0\x9F\x95\xB0" }, { k: "maple_leaf", v: "\xF0\x9F\x8D\x81" }, { k: "marshall_islands", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xAD" }, { k: "martial_arts_uniform", v: "\xF0\x9F\xA5\x8B" }, { k: "martinique", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB6" }, { k: "mask", v: "\xF0\x9F\x98\xB7" }, { k: "massage", v: "\xF0\x9F\x92\x86" }, { k: "massage_man", v: "\xF0\x9F\x92\x86\xE2\x80\x8D\xE2\x99\x82" }, { k: "massage_woman", v: "\xF0\x9F\x92\x86" }, { k: "mauritania", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB7" }, { k: "mauritius", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBA" }, { k: "mayotte", v: "\xF0\x9F\x87\xBE\xF0\x9F\x87\xB9" }, { k: "meat_on_bone", v: "\xF0\x9F\x8D\x96" }, { k: "medal_military", v: "\xF0\x9F\x8E\x96" }, { k: "medal_sports", v: "\xF0\x9F\x8F\x85" }, { k: "mega", v: "\xF0\x9F\x93\xA3" }, { k: "melon", v: "\xF0\x9F\x8D\x88" }, { k: "memo", v: "\xF0\x9F\x93\x9D" }, { k: "men_wrestling", v: "\xF0\x9F\xA4\xBC\xE2\x80\x8D\xE2\x99\x82" }, { k: "menorah", v: "\xF0\x9F\x95\x8E" }, { k: "mens", v: "\xF0\x9F\x9A\xB9" }, { k: "metal", v: "\xF0\x9F\xA4\x98" }, { k: "metro", v: "\xF0\x9F\x9A\x87" }, { k: "mexico", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBD" }, { k: "micronesia", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB2" }, { k: "microphone", v: "\xF0\x9F\x8E\xA4" }, { k: "microscope", v: "\xF0\x9F\x94\xAC" }, { k: "middle_finger", v: "\xF0\x9F\x96\x95" }, { k: "milk_glass", v: "\xF0\x9F\xA5\x9B" }, { k: "milky_way", v: "\xF0\x9F\x8C\x8C" }, { k: "minibus", v: "\xF0\x9F\x9A\x90" }, { k: "minidisc", v: "\xF0\x9F\x92\xBD" }, { k: "mobile_phone_off", v: "\xF0\x9F\x93\xB4" }, { k: "moldova", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xA9" }, { k: "monaco", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xA8" }, { k: "money_mouth_face", v: "\xF0\x9F\xA4\x91" }, { k: "money_with_wings", v: "\xF0\x9F\x92\xB8" }, { k: "moneybag", v: "\xF0\x9F\x92\xB0" }, { k: "mongolia", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB3" }, { k: "monkey", v: "\xF0\x9F\x90\x92" }, { k: "monkey_face", v: "\xF0\x9F\x90\xB5" }, { k: "monorail", v: "\xF0\x9F\x9A\x9D" }, { k: "montenegro", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xAA" }, { k: "montserrat", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB8" }, { k: "moon", v: "\xF0\x9F\x8C\x94" }, { k: "morocco", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xA6" }, { k: "mortar_board", v: "\xF0\x9F\x8E\x93" }, { k: "mosque", v: "\xF0\x9F\x95\x8C" }, { k: "motor_boat", v: "\xF0\x9F\x9B\xA5" }, { k: "motor_scooter", v: "\xF0\x9F\x9B\xB5" }, { k: "motorcycle", v: "\xF0\x9F\x8F\x8D" }, { k: "motorway", v: "\xF0\x9F\x9B\xA3" }, { k: "mount_fuji", v: "\xF0\x9F\x97\xBB" }, { k: "mountain", v: "\xE2\x9B\xB0" }, { k: "mountain_bicyclist", v: "\xF0\x9F\x9A\xB5" }, { k: "mountain_biking_man", v: "\xF0\x9F\x9A\xB5" }, { k: "mountain_biking_woman", v: "\xF0\x9F\x9A\xB5\xE2\x80\x8D\xE2\x99\x80" }, { k: "mountain_cableway", v: "\xF0\x9F\x9A\xA0" }, { k: "mountain_railway", v: "\xF0\x9F\x9A\x9E" }, { k: "mountain_snow", v: "\xF0\x9F\x8F\x94" }, { k: "mouse", v: "\xF0\x9F\x90\xAD" }, { k: "mouse2", v: "\xF0\x9F\x90\x81" }, { k: "movie_camera", v: "\xF0\x9F\x8E\xA5" }, { k: "moyai", v: "\xF0\x9F\x97\xBF" }, { k: "mozambique", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBF" }, { k: "mrs_claus", v: "\xF0\x9F\xA4\xB6" }, { k: "muscle", v: "\xF0\x9F\x92\xAA" }, { k: "mushroom", v: "\xF0\x9F\x8D\x84" }, { k: "musical_keyboard", v: "\xF0\x9F\x8E\xB9" }, { k: "musical_note", v: "\xF0\x9F\x8E\xB5" }, { k: "musical_score", v: "\xF0\x9F\x8E\xBC" }, { k: "mute", v: "\xF0\x9F\x94\x87" }, { k: "myanmar", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB2" }, { k: "nail_care", v: "\xF0\x9F\x92\x85" }, { k: "name_badge", v: "\xF0\x9F\x93\x9B" }, { k: "namibia", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xA6" }, { k: "national_park", v: "\xF0\x9F\x8F\x9E" }, { k: "nauru", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB7" }, { k: "nauseated_face", v: "\xF0\x9F\xA4\xA2" }, { k: "necktie", v: "\xF0\x9F\x91\x94" }, { k: "negative_squared_cross_mark", v: "\xE2\x9D\x8E" }, { k: "nepal", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB5" }, { k: "nerd_face", v: "\xF0\x9F\xA4\x93" }, { k: "netherlands", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB1" }, { k: "neutral_face", v: "\xF0\x9F\x98\x90" }, { k: "new", v: "\xF0\x9F\x86\x95" }, { k: "new_caledonia", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xA8" }, { k: "new_moon", v: "\xF0\x9F\x8C\x91" }, { k: "new_moon_with_face", v: "\xF0\x9F\x8C\x9A" }, { k: "new_zealand", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xBF" }, { k: "newspaper", v: "\xF0\x9F\x93\xB0" }, { k: "newspaper_roll", v: "\xF0\x9F\x97\x9E" }, { k: "next_track_button", v: "\xE2\x8F\xAD" }, { k: "ng", v: "\xF0\x9F\x86\x96" }, { k: "ng_man", v: "\xF0\x9F\x99\x85\xE2\x80\x8D\xE2\x99\x82" }, { k: "ng_woman", v: "\xF0\x9F\x99\x85" }, { k: "nicaragua", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAE" }, { k: "niger", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAA" }, { k: "nigeria", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAC" }, { k: "night_with_stars", v: "\xF0\x9F\x8C\x83" }, { k: "nine", v: "9\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "niue", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xBA" }, { k: "no_bell", v: "\xF0\x9F\x94\x95" }, { k: "no_bicycles", v: "\xF0\x9F\x9A\xB3" }, { k: "no_entry", v: "\xE2\x9B\x94\xEF\xB8\x8F" }, { k: "no_entry_sign", v: "\xF0\x9F\x9A\xAB" }, { k: "no_good", v: "\xF0\x9F\x99\x85" }, { k: "no_good_man", v: "\xF0\x9F\x99\x85\xE2\x80\x8D\xE2\x99\x82" }, { k: "no_good_woman", v: "\xF0\x9F\x99\x85" }, { k: "no_mobile_phones", v: "\xF0\x9F\x93\xB5" }, { k: "no_mouth", v: "\xF0\x9F\x98\xB6" }, { k: "no_pedestrians", v: "\xF0\x9F\x9A\xB7" }, { k: "no_smoking", v: "\xF0\x9F\x9A\xAD" }, { k: "non-potable_water", v: "\xF0\x9F\x9A\xB1" }, { k: "norfolk_island", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAB" }, { k: "north_korea", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB5" }, { k: "northern_mariana_islands", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB5" }, { k: "norway", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB4" }, { k: "nose", v: "\xF0\x9F\x91\x83" }, { k: "notebook", v: "\xF0\x9F\x93\x93" }, { k: "notebook_with_decorative_cover", v: "\xF0\x9F\x93\x94" }, { k: "notes", v: "\xF0\x9F\x8E\xB6" }, { k: "nut_and_bolt", v: "\xF0\x9F\x94\xA9" }, { k: "o", v: "\xE2\xAD\x95\xEF\xB8\x8F" }, { k: "o2", v: "\xF0\x9F\x85\xBE\xEF\xB8\x8F" }, { k: "ocean", v: "\xF0\x9F\x8C\x8A" }, { k: "octocat", v: "${emojiSite}/octocat.png" }, { k: "octopus", v: "\xF0\x9F\x90\x99" }, { k: "oden", v: "\xF0\x9F\x8D\xA2" }, { k: "office", v: "\xF0\x9F\x8F\xA2" }, { k: "oil_drum", v: "\xF0\x9F\x9B\xA2" }, { k: "ok", v: "\xF0\x9F\x86\x97" }, { k: "ok_hand", v: "\xF0\x9F\x91\x8C" }, { k: "ok_man", v: "\xF0\x9F\x99\x86\xE2\x80\x8D\xE2\x99\x82" }, { k: "ok_woman", v: "\xF0\x9F\x99\x86" }, { k: "old_key", v: "\xF0\x9F\x97\x9D" }, { k: "older_man", v: "\xF0\x9F\x91\xB4" }, { k: "older_woman", v: "\xF0\x9F\x91\xB5" }, { k: "om", v: "\xF0\x9F\x95\x89" }, { k: "oman", v: "\xF0\x9F\x87\xB4\xF0\x9F\x87\xB2" }, { k: "on", v: "\xF0\x9F\x94\x9B" }, { k: "oncoming_automobile", v: "\xF0\x9F\x9A\x98" }, { k: "oncoming_bus", v: "\xF0\x9F\x9A\x8D" }, { k: "oncoming_police_car", v: "\xF0\x9F\x9A\x94" }, { k: "oncoming_taxi", v: "\xF0\x9F\x9A\x96" }, { k: "one", v: "1\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "open_book", v: "\xF0\x9F\x93\x96" }, { k: "open_file_folder", v: "\xF0\x9F\x93\x82" }, { k: "open_hands", v: "\xF0\x9F\x91\x90" }, { k: "open_mouth", v: "\xF0\x9F\x98\xAE" }, { k: "open_umbrella", v: "\xE2\x98\x82\xEF\xB8\x8F" }, { k: "ophiuchus", v: "\xE2\x9B\x8E" }, { k: "orange", v: "\xF0\x9F\x8D\x8A" }, { k: "orange_book", v: "\xF0\x9F\x93\x99" }, { k: "orthodox_cross", v: "\xE2\x98\xA6\xEF\xB8\x8F" }, { k: "outbox_tray", v: "\xF0\x9F\x93\xA4" }, { k: "owl", v: "\xF0\x9F\xA6\x89" }, { k: "ox", v: "\xF0\x9F\x90\x82" }, { k: "package", v: "\xF0\x9F\x93\xA6" }, { k: "page_facing_up", v: "\xF0\x9F\x93\x84" }, { k: "page_with_curl", v: "\xF0\x9F\x93\x83" }, { k: "pager", v: "\xF0\x9F\x93\x9F" }, { k: "paintbrush", v: "\xF0\x9F\x96\x8C" }, { k: "pakistan", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB0" }, { k: "palau", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xBC" }, { k: "palestinian_territories", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB8" }, { k: "palm_tree", v: "\xF0\x9F\x8C\xB4" }, { k: "panama", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xA6" }, { k: "pancakes", v: "\xF0\x9F\xA5\x9E" }, { k: "panda_face", v: "\xF0\x9F\x90\xBC" }, { k: "paperclip", v: "\xF0\x9F\x93\x8E" }, { k: "paperclips", v: "\xF0\x9F\x96\x87" }, { k: "papua_new_guinea", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAC" }, { k: "paraguay", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xBE" }, { k: "parasol_on_ground", v: "\xE2\x9B\xB1" }, { k: "parking", v: "\xF0\x9F\x85\xBF\xEF\xB8\x8F" }, { k: "part_alternation_mark", v: "\xE3\x80\xBD\xEF\xB8\x8F" }, { k: "partly_sunny", v: "\xE2\x9B\x85\xEF\xB8\x8F" }, { k: "passenger_ship", v: "\xF0\x9F\x9B\xB3" }, { k: "passport_control", v: "\xF0\x9F\x9B\x82" }, { k: "pause_button", v: "\xE2\x8F\xB8" }, { k: "paw_prints", v: "\xF0\x9F\x90\xBE" }, { k: "peace_symbol", v: "\xE2\x98\xAE\xEF\xB8\x8F" }, { k: "peach", v: "\xF0\x9F\x8D\x91" }, { k: "peanuts", v: "\xF0\x9F\xA5\x9C" }, { k: "pear", v: "\xF0\x9F\x8D\x90" }, { k: "pen", v: "\xF0\x9F\x96\x8A" }, { k: "pencil", v: "\xF0\x9F\x93\x9D" }, { k: "pencil2", v: "\xE2\x9C\x8F\xEF\xB8\x8F" }, { k: "penguin", v: "\xF0\x9F\x90\xA7" }, { k: "pensive", v: "\xF0\x9F\x98\x94" }, { k: "performing_arts", v: "\xF0\x9F\x8E\xAD" }, { k: "persevere", v: "\xF0\x9F\x98\xA3" }, { k: "person_fencing", v: "\xF0\x9F\xA4\xBA" }, { k: "person_frowning", v: "\xF0\x9F\x99\x8D" }, { k: "person_with_blond_hair", v: "\xF0\x9F\x91\xB1" }, { k: "person_with_pouting_face", v: "\xF0\x9F\x99\x8E" }, { k: "peru", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAA" }, { k: "philippines", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAD" }, { k: "phone", v: "\xE2\x98\x8E\xEF\xB8\x8F" }, { k: "pick", v: "\xE2\x9B\x8F" }, { k: "pig", v: "\xF0\x9F\x90\xB7" }, { k: "pig2", v: "\xF0\x9F\x90\x96" }, { k: "pig_nose", v: "\xF0\x9F\x90\xBD" }, { k: "pill", v: "\xF0\x9F\x92\x8A" }, { k: "pineapple", v: "\xF0\x9F\x8D\x8D" }, { k: "ping_pong", v: "\xF0\x9F\x8F\x93" }, { k: "pipe", v: "${emojiSite}/pipe.png" }, { k: "pisces", v: "\xE2\x99\x93\xEF\xB8\x8F" }, { k: "pitcairn_islands", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB3" }, { k: "pizza", v: "\xF0\x9F\x8D\x95" }, { k: "place_of_worship", v: "\xF0\x9F\x9B\x90" }, { k: "plate_with_cutlery", v: "\xF0\x9F\x8D\xBD" }, { k: "play_or_pause_button", v: "\xE2\x8F\xAF" }, { k: "point_down", v: "\xF0\x9F\x91\x87" }, { k: "point_left", v: "\xF0\x9F\x91\x88" }, { k: "point_right", v: "\xF0\x9F\x91\x89" }, { k: "point_up", v: "\xE2\x98\x9D\xEF\xB8\x8F" }, { k: "point_up_2", v: "\xF0\x9F\x91\x86" }, { k: "poland", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB1" }, { k: "police_car", v: "\xF0\x9F\x9A\x93" }, { k: "policeman", v: "\xF0\x9F\x91\xAE" }, { k: "policewoman", v: "\xF0\x9F\x91\xAE\xE2\x80\x8D\xE2\x99\x80" }, { k: "poodle", v: "\xF0\x9F\x90\xA9" }, { k: "poop", v: "\xF0\x9F\x92\xA9" }, { k: "popcorn", v: "\xF0\x9F\x8D\xBF" }, { k: "portugal", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB9" }, { k: "post_office", v: "\xF0\x9F\x8F\xA3" }, { k: "postal_horn", v: "\xF0\x9F\x93\xAF" }, { k: "postbox", v: "\xF0\x9F\x93\xAE" }, { k: "potable_water", v: "\xF0\x9F\x9A\xB0" }, { k: "potato", v: "\xF0\x9F\xA5\x94" }, { k: "pouch", v: "\xF0\x9F\x91\x9D" }, { k: "poultry_leg", v: "\xF0\x9F\x8D\x97" }, { k: "pound", v: "\xF0\x9F\x92\xB7" }, { k: "pout", v: "\xF0\x9F\x98\xA1" }, { k: "pouting_cat", v: "\xF0\x9F\x98\xBE" }, { k: "pouting_man", v: "\xF0\x9F\x99\x8E\xE2\x80\x8D\xE2\x99\x82" }, { k: "pouting_woman", v: "\xF0\x9F\x99\x8E" }, { k: "pray", v: "\xF0\x9F\x99\x8F" }, { k: "prayer_beads", v: "\xF0\x9F\x93\xBF" }, { k: "pregnant_woman", v: "\xF0\x9F\xA4\xB0" }, { k: "previous_track_button", v: "\xE2\x8F\xAE" }, { k: "prince", v: "\xF0\x9F\xA4\xB4" }, { k: "princess", v: "\xF0\x9F\x91\xB8" }, { k: "printer", v: "\xF0\x9F\x96\xA8" }, { k: "puerto_rico", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB7" }, { k: "punch", v: "\xF0\x9F\x91\x8A" }, { k: "purple_heart", v: "\xF0\x9F\x92\x9C" }, { k: "purse", v: "\xF0\x9F\x91\x9B" }, { k: "pushpin", v: "\xF0\x9F\x93\x8C" }, { k: "put_litter_in_its_place", v: "\xF0\x9F\x9A\xAE" }, { k: "qatar", v: "\xF0\x9F\x87\xB6\xF0\x9F\x87\xA6" }, { k: "question", v: "\xE2\x9D\x93" }, { k: "rabbit", v: "\xF0\x9F\x90\xB0" }, { k: "rabbit2", v: "\xF0\x9F\x90\x87" }, { k: "racehorse", v: "\xF0\x9F\x90\x8E" }, { k: "racing_car", v: "\xF0\x9F\x8F\x8E" }, { k: "radio", v: "\xF0\x9F\x93\xBB" }, { k: "radio_button", v: "\xF0\x9F\x94\x98" }, { k: "radioactive", v: "\xE2\x98\xA2\xEF\xB8\x8F" }, { k: "rage", v: "\xF0\x9F\x98\xA1" }, { k: "railway_car", v: "\xF0\x9F\x9A\x83" }, { k: "railway_track", v: "\xF0\x9F\x9B\xA4" }, { k: "rainbow", v: "\xF0\x9F\x8C\x88" }, { k: "rainbow_flag", v: "\xF0\x9F\x8F\xB3\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x8C\x88" }, { k: "raised_back_of_hand", v: "\xF0\x9F\xA4\x9A" }, { k: "raised_hand", v: "\xE2\x9C\x8B" }, { k: "raised_hand_with_fingers_splayed", v: "\xF0\x9F\x96\x90" }, { k: "raised_hands", v: "\xF0\x9F\x99\x8C" }, { k: "raising_hand", v: "\xF0\x9F\x99\x8B" }, { k: "raising_hand_man", v: "\xF0\x9F\x99\x8B\xE2\x80\x8D\xE2\x99\x82" }, { k: "raising_hand_woman", v: "\xF0\x9F\x99\x8B" }, { k: "ram", v: "\xF0\x9F\x90\x8F" }, { k: "ramen", v: "\xF0\x9F\x8D\x9C" }, { k: "rat", v: "\xF0\x9F\x90\x80" }, { k: "record_button", v: "\xE2\x8F\xBA" }, { k: "recycle", v: "\xE2\x99\xBB\xEF\xB8\x8F" }, { k: "red_car", v: "\xF0\x9F\x9A\x97" }, { k: "red_circle", v: "\xF0\x9F\x94\xB4" }, { k: "registered", v: "\xC2\xAE\xEF\xB8\x8F" }, { k: "relaxed", v: "\xE2\x98\xBA\xEF\xB8\x8F" }, { k: "relieved", v: "\xF0\x9F\x98\x8C" }, { k: "reminder_ribbon", v: "\xF0\x9F\x8E\x97" }, { k: "repeat", v: "\xF0\x9F\x94\x81" }, { k: "repeat_one", v: "\xF0\x9F\x94\x82" }, { k: "rescue_worker_helmet", v: "\xE2\x9B\x91" }, { k: "restroom", v: "\xF0\x9F\x9A\xBB" }, { k: "reunion", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xAA" }, { k: "revolving_hearts", v: "\xF0\x9F\x92\x9E" }, { k: "rewind", v: "\xE2\x8F\xAA" }, { k: "rhinoceros", v: "\xF0\x9F\xA6\x8F" }, { k: "ribbon", v: "\xF0\x9F\x8E\x80" }, { k: "rice", v: "\xF0\x9F\x8D\x9A" }, { k: "rice_ball", v: "\xF0\x9F\x8D\x99" }, { k: "rice_cracker", v: "\xF0\x9F\x8D\x98" }, { k: "rice_scene", v: "\xF0\x9F\x8E\x91" }, { k: "right_anger_bubble", v: "\xF0\x9F\x97\xAF" }, { k: "ring", v: "\xF0\x9F\x92\x8D" }, { k: "robot", v: "\xF0\x9F\xA4\x96" }, { k: "rocket", v: "\xF0\x9F\x9A\x80" }, { k: "rofl", v: "\xF0\x9F\xA4\xA3" }, { k: "roll_eyes", v: "\xF0\x9F\x99\x84" }, { k: "roller_coaster", v: "\xF0\x9F\x8E\xA2" }, { k: "romania", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xB4" }, { k: "rooster", v: "\xF0\x9F\x90\x93" }, { k: "rose", v: "\xF0\x9F\x8C\xB9" }, { k: "rosette", v: "\xF0\x9F\x8F\xB5" }, { k: "rotating_light", v: "\xF0\x9F\x9A\xA8" }, { k: "round_pushpin", v: "\xF0\x9F\x93\x8D" }, { k: "rowboat", v: "\xF0\x9F\x9A\xA3" }, { k: "rowing_man", v: "\xF0\x9F\x9A\xA3" }, { k: "rowing_woman", v: "\xF0\x9F\x9A\xA3\xE2\x80\x8D\xE2\x99\x80" }, { k: "ru", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xBA" }, { k: "rugby_football", v: "\xF0\x9F\x8F\x89" }, { k: "runner", v: "\xF0\x9F\x8F\x83" }, { k: "running", v: "\xF0\x9F\x8F\x83" }, { k: "running_man", v: "\xF0\x9F\x8F\x83" }, { k: "running_shirt_with_sash", v: "\xF0\x9F\x8E\xBD" }, { k: "running_woman", v: "\xF0\x9F\x8F\x83\xE2\x80\x8D\xE2\x99\x80" }, { k: "rwanda", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xBC" }, { k: "sa", v: "\xF0\x9F\x88\x82\xEF\xB8\x8F" }, { k: "sagittarius", v: "\xE2\x99\x90\xEF\xB8\x8F" }, { k: "sailboat", v: "\xE2\x9B\xB5\xEF\xB8\x8F" }, { k: "sake", v: "\xF0\x9F\x8D\xB6" }, { k: "samoa", v: "\xF0\x9F\x87\xBC\xF0\x9F\x87\xB8" }, { k: "san_marino", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB2" }, { k: "sandal", v: "\xF0\x9F\x91\xA1" }, { k: "santa", v: "\xF0\x9F\x8E\x85" }, { k: "sao_tome_principe", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB9" }, { k: "sassy_man", v: "\xF0\x9F\x92\x81\xE2\x80\x8D\xE2\x99\x82" }, { k: "sassy_woman", v: "\xF0\x9F\x92\x81" }, { k: "satellite", v: "\xF0\x9F\x93\xA1" }, { k: "satisfied", v: "\xF0\x9F\x98\x86" }, { k: "saudi_arabia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA6" }, { k: "saxophone", v: "\xF0\x9F\x8E\xB7" }, { k: "school", v: "\xF0\x9F\x8F\xAB" }, { k: "school_satchel", v: "\xF0\x9F\x8E\x92" }, { k: "scissors", v: "\xE2\x9C\x82\xEF\xB8\x8F" }, { k: "scorpion", v: "\xF0\x9F\xA6\x82" }, { k: "scorpius", v: "\xE2\x99\x8F\xEF\xB8\x8F" }, { k: "scream", v: "\xF0\x9F\x98\xB1" }, { k: "scream_cat", v: "\xF0\x9F\x99\x80" }, { k: "scroll", v: "\xF0\x9F\x93\x9C" }, { k: "seat", v: "\xF0\x9F\x92\xBA" }, { k: "secret", v: "\xE3\x8A\x99\xEF\xB8\x8F" }, { k: "see_no_evil", v: "\xF0\x9F\x99\x88" }, { k: "seedling", v: "\xF0\x9F\x8C\xB1" }, { k: "selfie", v: "\xF0\x9F\xA4\xB3" }, { k: "senegal", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB3" }, { k: "serbia", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xB8" }, { k: "seven", v: "7\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "seychelles", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA8" }, { k: "shallow_pan_of_food", v: "\xF0\x9F\xA5\x98" }, { k: "shamrock", v: "\xE2\x98\x98\xEF\xB8\x8F" }, { k: "shark", v: "\xF0\x9F\xA6\x88" }, { k: "shaved_ice", v: "\xF0\x9F\x8D\xA7" }, { k: "sheep", v: "\xF0\x9F\x90\x91" }, { k: "shell", v: "\xF0\x9F\x90\x9A" }, { k: "shield", v: "\xF0\x9F\x9B\xA1" }, { k: "shinto_shrine", v: "\xE2\x9B\xA9" }, { k: "ship", v: "\xF0\x9F\x9A\xA2" }, { k: "shirt", v: "\xF0\x9F\x91\x95" }, { k: "shit", v: "\xF0\x9F\x92\xA9" }, { k: "shoe", v: "\xF0\x9F\x91\x9E" }, { k: "shopping", v: "\xF0\x9F\x9B\x8D" }, { k: "shopping_cart", v: "\xF0\x9F\x9B\x92" }, { k: "shower", v: "\xF0\x9F\x9A\xBF" }, { k: "shrimp", v: "\xF0\x9F\xA6\x90" }, { k: "sierra_leone", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB1" }, { k: "signal_strength", v: "\xF0\x9F\x93\xB6" }, { k: "singapore", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAC" }, { k: "sint_maarten", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBD" }, { k: "six", v: "6\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "six_pointed_star", v: "\xF0\x9F\x94\xAF" }, { k: "ski", v: "\xF0\x9F\x8E\xBF" }, { k: "skier", v: "\xE2\x9B\xB7" }, { k: "skull", v: "\xF0\x9F\x92\x80" }, { k: "skull_and_crossbones", v: "\xE2\x98\xA0\xEF\xB8\x8F" }, { k: "sleeping", v: "\xF0\x9F\x98\xB4" }, { k: "sleeping_bed", v: "\xF0\x9F\x9B\x8C" }, { k: "sleepy", v: "\xF0\x9F\x98\xAA" }, { k: "slightly_frowning_face", v: "\xF0\x9F\x99\x81" }, { k: "slightly_smiling_face", v: "\xF0\x9F\x99\x82" }, { k: "slot_machine", v: "\xF0\x9F\x8E\xB0" }, { k: "slovakia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB0" }, { k: "slovenia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAE" }, { k: "small_airplane", v: "\xF0\x9F\x9B\xA9" }, { k: "small_blue_diamond", v: "\xF0\x9F\x94\xB9" }, { k: "small_orange_diamond", v: "\xF0\x9F\x94\xB8" }, { k: "small_red_triangle", v: "\xF0\x9F\x94\xBA" }, { k: "small_red_triangle_down", v: "\xF0\x9F\x94\xBB" }, { k: "smile", v: "\xF0\x9F\x98\x84" }, { k: "smile_cat", v: "\xF0\x9F\x98\xB8" }, { k: "smiley", v: "\xF0\x9F\x98\x83" }, { k: "smiley_cat", v: "\xF0\x9F\x98\xBA" }, { k: "smiling_imp", v: "\xF0\x9F\x98\x88" }, { k: "smirk", v: "\xF0\x9F\x98\x8F" }, { k: "smirk_cat", v: "\xF0\x9F\x98\xBC" }, { k: "smoking", v: "\xF0\x9F\x9A\xAC" }, { k: "snail", v: "\xF0\x9F\x90\x8C" }, { k: "snake", v: "\xF0\x9F\x90\x8D" }, { k: "sneezing_face", v: "\xF0\x9F\xA4\xA7" }, { k: "snowboarder", v: "\xF0\x9F\x8F\x82" }, { k: "snowflake", v: "\xE2\x9D\x84\xEF\xB8\x8F" }, { k: "snowman", v: "\xE2\x9B\x84\xEF\xB8\x8F" }, { k: "snowman_with_snow", v: "\xE2\x98\x83\xEF\xB8\x8F" }, { k: "sob", v: "\xF0\x9F\x98\xAD" }, { k: "soccer", v: "\xE2\x9A\xBD\xEF\xB8\x8F" }, { k: "solo", v: "${emojiSite}/solo.png" }, { k: "solomon_islands", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA7" }, { k: "somalia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB4" }, { k: "soon", v: "\xF0\x9F\x94\x9C" }, { k: "sos", v: "\xF0\x9F\x86\x98" }, { k: "sound", v: "\xF0\x9F\x94\x89" }, { k: "south_africa", v: "\xF0\x9F\x87\xBF\xF0\x9F\x87\xA6" }, { k: "south_georgia_south_sandwich_islands", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB8" }, { k: "south_sudan", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB8" }, { k: "space_invader", v: "\xF0\x9F\x91\xBE" }, { k: "spades", v: "\xE2\x99\xA0\xEF\xB8\x8F" }, { k: "spaghetti", v: "\xF0\x9F\x8D\x9D" }, { k: "sparkle", v: "\xE2\x9D\x87\xEF\xB8\x8F" }, { k: "sparkler", v: "\xF0\x9F\x8E\x87" }, { k: "sparkles", v: "\xE2\x9C\xA8" }, { k: "sparkling_heart", v: "\xF0\x9F\x92\x96" }, { k: "speak_no_evil", v: "\xF0\x9F\x99\x8A" }, { k: "speaker", v: "\xF0\x9F\x94\x88" }, { k: "speaking_head", v: "\xF0\x9F\x97\xA3" }, { k: "speech_balloon", v: "\xF0\x9F\x92\xAC" }, { k: "speedboat", v: "\xF0\x9F\x9A\xA4" }, { k: "spider", v: "\xF0\x9F\x95\xB7" }, { k: "spider_web", v: "\xF0\x9F\x95\xB8" }, { k: "spiral_calendar", v: "\xF0\x9F\x97\x93" }, { k: "spiral_notepad", v: "\xF0\x9F\x97\x92" }, { k: "spoon", v: "\xF0\x9F\xA5\x84" }, { k: "squid", v: "\xF0\x9F\xA6\x91" }, { k: "sri_lanka", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB0" }, { k: "st_barthelemy", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB1" }, { k: "st_helena", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAD" }, { k: "st_kitts_nevis", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB3" }, { k: "st_lucia", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xA8" }, { k: "st_pierre_miquelon", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB2" }, { k: "st_vincent_grenadines", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xA8" }, { k: "stadium", v: "\xF0\x9F\x8F\x9F" }, { k: "star", v: "\xE2\xAD\x90\xEF\xB8\x8F" }, { k: "star2", v: "\xF0\x9F\x8C\x9F" }, { k: "star_and_crescent", v: "\xE2\x98\xAA\xEF\xB8\x8F" }, { k: "star_of_david", v: "\xE2\x9C\xA1\xEF\xB8\x8F" }, { k: "stars", v: "\xF0\x9F\x8C\xA0" }, { k: "station", v: "\xF0\x9F\x9A\x89" }, { k: "statue_of_liberty", v: "\xF0\x9F\x97\xBD" }, { k: "steam_locomotive", v: "\xF0\x9F\x9A\x82" }, { k: "stew", v: "\xF0\x9F\x8D\xB2" }, { k: "stop_button", v: "\xE2\x8F\xB9" }, { k: "stop_sign", v: "\xF0\x9F\x9B\x91" }, { k: "stopwatch", v: "\xE2\x8F\xB1" }, { k: "straight_ruler", v: "\xF0\x9F\x93\x8F" }, { k: "strawberry", v: "\xF0\x9F\x8D\x93" }, { k: "stuck_out_tongue", v: "\xF0\x9F\x98\x9B" }, { k: "stuck_out_tongue_closed_eyes", v: "\xF0\x9F\x98\x9D" }, { k: "stuck_out_tongue_winking_eye", v: "\xF0\x9F\x98\x9C" }, { k: "studio_microphone", v: "\xF0\x9F\x8E\x99" }, { k: "stuffed_flatbread", v: "\xF0\x9F\xA5\x99" }, { k: "sudan", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA9" }, { k: "sun_behind_large_cloud", v: "\xF0\x9F\x8C\xA5" }, { k: "sun_behind_rain_cloud", v: "\xF0\x9F\x8C\xA6" }, { k: "sun_behind_small_cloud", v: "\xF0\x9F\x8C\xA4" }, { k: "sun_with_face", v: "\xF0\x9F\x8C\x9E" }, { k: "sunflower", v: "\xF0\x9F\x8C\xBB" }, { k: "sunglasses", v: "\xF0\x9F\x98\x8E" }, { k: "sunny", v: "\xE2\x98\x80\xEF\xB8\x8F" }, { k: "sunrise", v: "\xF0\x9F\x8C\x85" }, { k: "sunrise_over_mountains", v: "\xF0\x9F\x8C\x84" }, { k: "surfer", v: "\xF0\x9F\x8F\x84" }, { k: "surfing_man", v: "\xF0\x9F\x8F\x84" }, { k: "surfing_woman", v: "\xF0\x9F\x8F\x84\xE2\x80\x8D\xE2\x99\x80" }, { k: "suriname", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB7" }, { k: "sushi", v: "\xF0\x9F\x8D\xA3" }, { k: "suspension_railway", v: "\xF0\x9F\x9A\x9F" }, { k: "swaziland", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBF" }, { k: "sweat", v: "\xF0\x9F\x98\x93" }, { k: "sweat_drops", v: "\xF0\x9F\x92\xA6" }, { k: "sweat_smile", v: "\xF0\x9F\x98\x85" }, { k: "sweden", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAA" }, { k: "sweet_potato", v: "\xF0\x9F\x8D\xA0" }, { k: "swimmer", v: "\xF0\x9F\x8F\x8A" }, { k: "swimming_man", v: "\xF0\x9F\x8F\x8A" }, { k: "swimming_woman", v: "\xF0\x9F\x8F\x8A\xE2\x80\x8D\xE2\x99\x80" }, { k: "switzerland", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAD" }, { k: "sym", v: "${emojiSite}/sym.png" }, { k: "symbols", v: "\xF0\x9F\x94\xA3" }, { k: "synagogue", v: "\xF0\x9F\x95\x8D" }, { k: "syria", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBE" }, { k: "syringe", v: "\xF0\x9F\x92\x89" }, { k: "taco", v: "\xF0\x9F\x8C\xAE" }, { k: "tada", v: "\xF0\x9F\x8E\x89" }, { k: "taiwan", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xBC" }, { k: "tajikistan", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAF" }, { k: "tanabata_tree", v: "\xF0\x9F\x8E\x8B" }, { k: "tangerine", v: "\xF0\x9F\x8D\x8A" }, { k: "tanzania", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xBF" }, { k: "taurus", v: "\xE2\x99\x89\xEF\xB8\x8F" }, { k: "taxi", v: "\xF0\x9F\x9A\x95" }, { k: "tea", v: "\xF0\x9F\x8D\xB5" }, { k: "telephone", v: "\xE2\x98\x8E\xEF\xB8\x8F" }, { k: "telephone_receiver", v: "\xF0\x9F\x93\x9E" }, { k: "telescope", v: "\xF0\x9F\x94\xAD" }, { k: "tennis", v: "\xF0\x9F\x8E\xBE" }, { k: "tent", v: "\xE2\x9B\xBA\xEF\xB8\x8F" }, { k: "thailand", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAD" }, { k: "thermometer", v: "\xF0\x9F\x8C\xA1" }, { k: "thinking", v: "\xF0\x9F\xA4\x94" }, { k: "thought_balloon", v: "\xF0\x9F\x92\xAD" }, { k: "three", v: "3\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "thumbsdown", v: "\xF0\x9F\x91\x8E" }, { k: "thumbsup", v: "\xF0\x9F\x91\x8D" }, { k: "ticket", v: "\xF0\x9F\x8E\xAB" }, { k: "tickets", v: "\xF0\x9F\x8E\x9F" }, { k: "tiger", v: "\xF0\x9F\x90\xAF" }, { k: "tiger2", v: "\xF0\x9F\x90\x85" }, { k: "timer_clock", v: "\xE2\x8F\xB2" }, { k: "timor_leste", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB1" }, { k: "tipping_hand_man", v: "\xF0\x9F\x92\x81\xE2\x80\x8D\xE2\x99\x82" }, { k: "tipping_hand_woman", v: "\xF0\x9F\x92\x81" }, { k: "tired_face", v: "\xF0\x9F\x98\xAB" }, { k: "tm", v: "\xE2\x84\xA2\xEF\xB8\x8F" }, { k: "togo", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAC" }, { k: "toilet", v: "\xF0\x9F\x9A\xBD" }, { k: "tokelau", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB0" }, { k: "tokyo_tower", v: "\xF0\x9F\x97\xBC" }, { k: "tomato", v: "\xF0\x9F\x8D\x85" }, { k: "tonga", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB4" }, { k: "tongue", v: "\xF0\x9F\x91\x85" }, { k: "top", v: "\xF0\x9F\x94\x9D" }, { k: "tophat", v: "\xF0\x9F\x8E\xA9" }, { k: "tornado", v: "\xF0\x9F\x8C\xAA" }, { k: "tr", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB7" }, { k: "trackball", v: "\xF0\x9F\x96\xB2" }, { k: "tractor", v: "\xF0\x9F\x9A\x9C" }, { k: "traffic_light", v: "\xF0\x9F\x9A\xA5" }, { k: "train", v: "\xF0\x9F\x9A\x8B" }, { k: "train2", v: "\xF0\x9F\x9A\x86" }, { k: "tram", v: "\xF0\x9F\x9A\x8A" }, { k: "triangular_flag_on_post", v: "\xF0\x9F\x9A\xA9" }, { k: "triangular_ruler", v: "\xF0\x9F\x93\x90" }, { k: "trident", v: "\xF0\x9F\x94\xB1" }, { k: "trinidad_tobago", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB9" }, { k: "triumph", v: "\xF0\x9F\x98\xA4" }, { k: "trolleybus", v: "\xF0\x9F\x9A\x8E" }, { k: "trollface", v: "${emojiSite}/trollface.png" }, { k: "trophy", v: "\xF0\x9F\x8F\x86" }, { k: "tropical_drink", v: "\xF0\x9F\x8D\xB9" }, { k: "tropical_fish", v: "\xF0\x9F\x90\xA0" }, { k: "truck", v: "\xF0\x9F\x9A\x9A" }, { k: "trumpet", v: "\xF0\x9F\x8E\xBA" }, { k: "tshirt", v: "\xF0\x9F\x91\x95" }, { k: "tulip", v: "\xF0\x9F\x8C\xB7" }, { k: "tumbler_glass", v: "\xF0\x9F\xA5\x83" }, { k: "tunisia", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB3" }, { k: "turkey", v: "\xF0\x9F\xA6\x83" }, { k: "turkmenistan", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB2" }, { k: "turks_caicos_islands", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xA8" }, { k: "turtle", v: "\xF0\x9F\x90\xA2" }, { k: "tuvalu", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xBB" }, { k: "tv", v: "\xF0\x9F\x93\xBA" }, { k: "twisted_rightwards_arrows", v: "\xF0\x9F\x94\x80" }, { k: "two", v: "2\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "two_hearts", v: "\xF0\x9F\x92\x95" }, { k: "two_men_holding_hands", v: "\xF0\x9F\x91\xAC" }, { k: "two_women_holding_hands", v: "\xF0\x9F\x91\xAD" }, { k: "u5272", v: "\xF0\x9F\x88\xB9" }, { k: "u5408", v: "\xF0\x9F\x88\xB4" }, { k: "u55b6", v: "\xF0\x9F\x88\xBA" }, { k: "u6307", v: "\xF0\x9F\x88\xAF\xEF\xB8\x8F" }, { k: "u6708", v: "\xF0\x9F\x88\xB7\xEF\xB8\x8F" }, { k: "u6709", v: "\xF0\x9F\x88\xB6" }, { k: "u6e80", v: "\xF0\x9F\x88\xB5" }, { k: "u7121", v: "\xF0\x9F\x88\x9A\xEF\xB8\x8F" }, { k: "u7533", v: "\xF0\x9F\x88\xB8" }, { k: "u7981", v: "\xF0\x9F\x88\xB2" }, { k: "u7a7a", v: "\xF0\x9F\x88\xB3" }, { k: "uganda", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xAC" }, { k: "uk", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA7" }, { k: "ukraine", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xA6" }, { k: "umbrella", v: "\xE2\x98\x94\xEF\xB8\x8F" }, { k: "unamused", v: "\xF0\x9F\x98\x92" }, { k: "underage", v: "\xF0\x9F\x94\x9E" }, { k: "unicorn", v: "\xF0\x9F\xA6\x84" }, { k: "united_arab_emirates", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAA" }, { k: "unlock", v: "\xF0\x9F\x94\x93" }, { k: "up", v: "\xF0\x9F\x86\x99" }, { k: "upside_down_face", v: "\xF0\x9F\x99\x83" }, { k: "uruguay", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xBE" }, { k: "us", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xB8" }, { k: "us_virgin_islands", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xAE" }, { k: "uzbekistan", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xBF" }, { k: "v", v: "\xE2\x9C\x8C\xEF\xB8\x8F" }, { k: "vanuatu", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xBA" }, { k: "vatican_city", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xA6" }, { k: "vditor", v: "${emojiSite}/vditor.png" }, { k: "venezuela", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xAA" }, { k: "vertical_traffic_light", v: "\xF0\x9F\x9A\xA6" }, { k: "vhs", v: "\xF0\x9F\x93\xBC" }, { k: "vibration_mode", v: "\xF0\x9F\x93\xB3" }, { k: "video_camera", v: "\xF0\x9F\x93\xB9" }, { k: "video_game", v: "\xF0\x9F\x8E\xAE" }, { k: "vietnam", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xB3" }, { k: "violin", v: "\xF0\x9F\x8E\xBB" }, { k: "virgo", v: "\xE2\x99\x8D\xEF\xB8\x8F" }, { k: "volcano", v: "\xF0\x9F\x8C\x8B" }, { k: "volleyball", v: "\xF0\x9F\x8F\x90" }, { k: "vs", v: "\xF0\x9F\x86\x9A" }, { k: "vulcan_salute", v: "\xF0\x9F\x96\x96" }, { k: "walking", v: "\xF0\x9F\x9A\xB6" }, { k: "walking_man", v: "\xF0\x9F\x9A\xB6" }, { k: "walking_woman", v: "\xF0\x9F\x9A\xB6\xE2\x80\x8D\xE2\x99\x80" }, { k: "wallis_futuna", v: "\xF0\x9F\x87\xBC\xF0\x9F\x87\xAB" }, { k: "waning_crescent_moon", v: "\xF0\x9F\x8C\x98" }, { k: "waning_gibbous_moon", v: "\xF0\x9F\x8C\x96" }, { k: "warning", v: "\xE2\x9A\xA0\xEF\xB8\x8F" }, { k: "wastebasket", v: "\xF0\x9F\x97\x91" }, { k: "watch", v: "\xE2\x8C\x9A\xEF\xB8\x8F" }, { k: "water_buffalo", v: "\xF0\x9F\x90\x83" }, { k: "watermelon", v: "\xF0\x9F\x8D\x89" }, { k: "wave", v: "\xF0\x9F\x91\x8B" }, { k: "wavy_dash", v: "\xE3\x80\xB0\xEF\xB8\x8F" }, { k: "waxing_crescent_moon", v: "\xF0\x9F\x8C\x92" }, { k: "waxing_gibbous_moon", v: "\xF0\x9F\x8C\x94" }, { k: "wc", v: "\xF0\x9F\x9A\xBE" }, { k: "weary", v: "\xF0\x9F\x98\xA9" }, { k: "wedding", v: "\xF0\x9F\x92\x92" }, { k: "weight_lifting_man", v: "\xF0\x9F\x8F\x8B" }, { k: "weight_lifting_woman", v: "\xF0\x9F\x8F\x8B\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "western_sahara", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xAD" }, { k: "whale", v: "\xF0\x9F\x90\xB3" }, { k: "whale2", v: "\xF0\x9F\x90\x8B" }, { k: "wheel_of_dharma", v: "\xE2\x98\xB8\xEF\xB8\x8F" }, { k: "wheelchair", v: "\xE2\x99\xBF\xEF\xB8\x8F" }, { k: "white_check_mark", v: "\xE2\x9C\x85" }, { k: "white_circle", v: "\xE2\x9A\xAA\xEF\xB8\x8F" }, { k: "white_flag", v: "\xF0\x9F\x8F\xB3\xEF\xB8\x8F" }, { k: "white_flower", v: "\xF0\x9F\x92\xAE" }, { k: "white_large_square", v: "\xE2\xAC\x9C\xEF\xB8\x8F" }, { k: "white_medium_small_square", v: "\xE2\x97\xBD\xEF\xB8\x8F" }, { k: "white_medium_square", v: "\xE2\x97\xBB\xEF\xB8\x8F" }, { k: "white_small_square", v: "\xE2\x96\xAB\xEF\xB8\x8F" }, { k: "white_square_button", v: "\xF0\x9F\x94\xB3" }, { k: "wide", v: "${emojiSite}/wide.png" }, { k: "wilted_flower", v: "\xF0\x9F\xA5\x80" }, { k: "wind_chime", v: "\xF0\x9F\x8E\x90" }, { k: "wind_face", v: "\xF0\x9F\x8C\xAC" }, { k: "wine_glass", v: "\xF0\x9F\x8D\xB7" }, { k: "wink", v: "\xF0\x9F\x98\x89" }, { k: "wolf", v: "\xF0\x9F\x90\xBA" }, { k: "woman", v: "\xF0\x9F\x91\xA9" }, { k: "woman_artist", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8E\xA8" }, { k: "woman_astronaut", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x9A\x80" }, { k: "woman_cartwheeling", v: "\xF0\x9F\xA4\xB8\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_cook", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8D\xB3" }, { k: "woman_facepalming", v: "\xF0\x9F\xA4\xA6\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_factory_worker", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8F\xAD" }, { k: "woman_farmer", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8C\xBE" }, { k: "woman_firefighter", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x9A\x92" }, { k: "woman_health_worker", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9A\x95" }, { k: "woman_judge", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9A\x96" }, { k: "woman_juggling", v: "\xF0\x9F\xA4\xB9\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_mechanic", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x94\xA7" }, { k: "woman_office_worker", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x92\xBC" }, { k: "woman_pilot", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9C\x88" }, { k: "woman_playing_handball", v: "\xF0\x9F\xA4\xBE\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_playing_water_polo", v: "\xF0\x9F\xA4\xBD\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_scientist", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x94\xAC" }, { k: "woman_shrugging", v: "\xF0\x9F\xA4\xB7\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_singer", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8E\xA4" }, { k: "woman_student", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8E\x93" }, { k: "woman_teacher", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8F\xAB" }, { k: "woman_technologist", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x92\xBB" }, { k: "woman_with_turban", v: "\xF0\x9F\x91\xB3\xE2\x80\x8D\xE2\x99\x80" }, { k: "womans_clothes", v: "\xF0\x9F\x91\x9A" }, { k: "womans_hat", v: "\xF0\x9F\x91\x92" }, { k: "women_wrestling", v: "\xF0\x9F\xA4\xBC\xE2\x80\x8D\xE2\x99\x80" }, { k: "womens", v: "\xF0\x9F\x9A\xBA" }, { k: "world_map", v: "\xF0\x9F\x97\xBA" }, { k: "worried", v: "\xF0\x9F\x98\x9F" }, { k: "wrench", v: "\xF0\x9F\x94\xA7" }, { k: "writing_hand", v: "\xE2\x9C\x8D\xEF\xB8\x8F" }, { k: "x", v: "\xE2\x9D\x8C" }, { k: "yellow_heart", v: "\xF0\x9F\x92\x9B" }, { k: "yemen", v: "\xF0\x9F\x87\xBE\xF0\x9F\x87\xAA" }, { k: "yen", v: "\xF0\x9F\x92\xB4" }, { k: "yin_yang", v: "\xE2\x98\xAF\xEF\xB8\x8F" }, { k: "yum", v: "\xF0\x9F\x98\x8B" }, { k: "zambia", v: "\xF0\x9F\x87\xBF\xF0\x9F\x87\xB2" }, { k: "zap", v: "\xE2\x9A\xA1\xEF\xB8\x8F" }, { k: "zero", v: "0\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "zimbabwe", v: "\xF0\x9F\x87\xBF\xF0\x9F\x87\xBC" }, { k: "zipper_mouth_face", v: "\xF0\x9F\xA4\x90" }, { k: "zzz", v: "\xF0\x9F\x92\xA4" }]);
		amp = strToBytes("&amp;");
		lt = strToBytes("&lt;");
		gt = strToBytes("&gt;");
		quot = strToBytes("&quot;");
		htmlBlockTags1 = new sliceType$1([strToBytes("<script"), strToBytes("<pre"), strToBytes("<style")]);
		htmlBlockCloseTags1 = new sliceType$1([strToBytes("</script>"), strToBytes("</pre>"), strToBytes("</style>")]);
		htmlBlockTags6 = new sliceType$1([strToBytes("<address"), strToBytes("<article"), strToBytes("<aside"), strToBytes("<base"), strToBytes("<basefont"), strToBytes("<blockquote"), strToBytes("<body"), strToBytes("<caption"), strToBytes("<center"), strToBytes("<col"), strToBytes("<colgroup"), strToBytes("<dd"), strToBytes("<details"), strToBytes("<dialog"), strToBytes("<dir"), strToBytes("<div"), strToBytes("<dl"), strToBytes("<dt"), strToBytes("<fieldset"), strToBytes("<figcaption"), strToBytes("<figure"), strToBytes("<footer"), strToBytes("<form"), strToBytes("<frame"), strToBytes("<frameset"), strToBytes("<h1"), strToBytes("<h2"), strToBytes("<h3"), strToBytes("<h4"), strToBytes("<h5"), strToBytes("<h6"), strToBytes("<head"), strToBytes("<header"), strToBytes("<hr"), strToBytes("<html"), strToBytes("<iframe"), strToBytes("<legend"), strToBytes("<li"), strToBytes("<link"), strToBytes("<main"), strToBytes("<menu"), strToBytes("<menuitem"), strToBytes("<nav"), strToBytes("<noframes"), strToBytes("<ol"), strToBytes("<optgroup"), strToBytes("<option"), strToBytes("<p"), strToBytes("<param"), strToBytes("<section"), strToBytes("<source"), strToBytes("<summary"), strToBytes("<table"), strToBytes("<tbody"), strToBytes("<td"), strToBytes("<tfoot"), strToBytes("<th"), strToBytes("<thead"), strToBytes("<title"), strToBytes("<tr"), strToBytes("<track"), strToBytes("<ul"), strToBytes("</address"), strToBytes("</article"), strToBytes("</aside"), strToBytes("</base"), strToBytes("</basefont"), strToBytes("</blockquote"), strToBytes("</body"), strToBytes("</caption"), strToBytes("</center"), strToBytes("</col"), strToBytes("</colgroup"), strToBytes("</dd"), strToBytes("</details"), strToBytes("</dialog"), strToBytes("</dir"), strToBytes("</div"), strToBytes("</dl"), strToBytes("</dt"), strToBytes("</fieldset"), strToBytes("</figcaption"), strToBytes("</figure"), strToBytes("</footer"), strToBytes("</form"), strToBytes("</frame"), strToBytes("</frameset"), strToBytes("</h1"), strToBytes("</h2"), strToBytes("</h3"), strToBytes("</h4"), strToBytes("</h5"), strToBytes("</h6"), strToBytes("</head"), strToBytes("</header"), strToBytes("</hr"), strToBytes("</html"), strToBytes("</iframe"), strToBytes("</legend"), strToBytes("</li"), strToBytes("</link"), strToBytes("</main"), strToBytes("</menu"), strToBytes("</menuitem"), strToBytes("</nav"), strToBytes("</noframes"), strToBytes("</ol"), strToBytes("</optgroup"), strToBytes("</option"), strToBytes("</p"), strToBytes("</param"), strToBytes("</section"), strToBytes("</source"), strToBytes("</summary"), strToBytes("</table"), strToBytes("</tbody"), strToBytes("</td"), strToBytes("</tfoot"), strToBytes("</th"), strToBytes("</thead"), strToBytes("</title"), strToBytes("</tr"), strToBytes("</track"), strToBytes("</ul")]);
		htmlBlockSinglequote = strToBytes("'");
		htmlBlockDoublequote = strToBytes("\"");
		htmlBlockGreater = strToBytes(">");
		backslash = strToBytes("\\");
		dollar = strToBytes("$");
		items1 = strToBytes("1");
		mathBlockMarker = strToBytes("$$");
		mathBlockDollar = strToBytes("$");
		terms = $makeMap($String.keyFor, [{ k: "jetty", v: "Jetty" }, { k: "tomcat", v: "Tomcat" }, { k: "jdbc", v: "JDBC" }, { k: "mariadb", v: "MariaDB" }, { k: "ipfs", v: "IPFS" }, { k: "saas", v: "SaaS" }, { k: "paas", v: "PaaS" }, { k: "iaas", v: "IaaS" }, { k: "ioc", v: "IoC" }, { k: "freemarker", v: "FreeMarker" }, { k: "ruby", v: "Ruby" }, { k: "rails", v: "Rails" }, { k: "mina", v: "Mina" }, { k: "puppet", v: "Puppet" }, { k: "vagrant", v: "Vagrant" }, { k: "chef", v: "Chef" }, { k: "beego", v: "Beego" }, { k: "gin", v: "Gin" }, { k: "iris", v: "Iris" }, { k: "php", v: "PHP" }, { k: "ssh", v: "SSH" }, { k: "web", v: "Web" }, { k: "api", v: "API" }, { k: "css", v: "CSS" }, { k: "html", v: "HTML" }, { k: "json", v: "JSON" }, { k: "jsonp", v: "JSONP" }, { k: "xml", v: "XML" }, { k: "yaml", v: "YAML" }, { k: "csv", v: "CSV" }, { k: "soap", v: "SOAP" }, { k: "ajax", v: "AJAX" }, { k: "messagepack", v: "MessagePack" }, { k: "javascript", v: "JavaScript" }, { k: "java", v: "Java" }, { k: "jsp", v: "JSP" }, { k: "restful", v: "RESTFul" }, { k: "graphql", v: "GraphQL" }, { k: "gorm", v: "GORM" }, { k: "orm", v: "ORM" }, { k: "oauth", v: "OAuth" }, { k: "facebook", v: "Facebook" }, { k: "github", v: "GitHub" }, { k: "gist", v: "Gist" }, { k: "heroku", v: "Heroku" }, { k: "twitter", v: "Twitter" }, { k: "youtube", v: "YouTube" }, { k: "dynamodb", v: "DynamoDB" }, { k: "mysql", v: "MySQL" }, { k: "postgresql", v: "PostgreSQL" }, { k: "sqlite", v: "SQLite" }, { k: "memcached", v: "Memcached" }, { k: "mongodb", v: "MongoDB" }, { k: "redis", v: "Redis" }, { k: "elasticsearch", v: "Elasticsearch" }, { k: "solr", v: "Solr" }, { k: "b3log", v: "B3log" }, { k: "hacpai", v: "HacPai" }, { k: "lute", v: "Lute" }, { k: "sphinx", v: "Sphinx" }, { k: "linux", v: "Linux" }, { k: "mac", v: "Mac" }, { k: "osx", v: "OS X" }, { k: "ubuntu", v: "Ubuntu" }, { k: "centos", v: "CentOS" }, { k: "centos7", v: "CentOS7" }, { k: "redhat", v: "RedHat" }, { k: "gitlab", v: "GitLab" }, { k: "jquery", v: "jQuery" }, { k: "angularjs", v: "AngularJS" }, { k: "ffmpeg", v: "FFMPEG" }, { k: "git", v: "Git" }, { k: "svn", v: "SVN" }, { k: "vim", v: "VIM" }, { k: "emacs", v: "Emacs" }, { k: "sublime", v: "Sublime" }, { k: "virtualbox", v: "VirtualBox" }, { k: "safari", v: "Safari" }, { k: "chrome", v: "Chrome" }, { k: "ie", v: "IE" }, { k: "firefox", v: "Firefox" }, { k: "iterm", v: "iTerm" }, { k: "iterm2", v: "iTerm2" }, { k: "iwork", v: "iWork" }, { k: "itunes", v: "iTunes" }, { k: "iphoto", v: "iPhoto" }, { k: "ibook", v: "iBook" }, { k: "imessage", v: "iMessage" }, { k: "photoshop", v: "Photoshop" }, { k: "excel", v: "Excel" }, { k: "powerpoint", v: "PowerPoint" }, { k: "ios", v: "iOS" }, { k: "iphone", v: "iPhone" }, { k: "ipad", v: "iPad" }, { k: "android", v: "Android" }, { k: "imac", v: "iMac" }, { k: "macbook", v: "MacBook" }, { k: "vps", v: "VPS" }, { k: "vpn", v: "VPN" }, { k: "arm", v: "ARM" }, { k: "cpu", v: "CPU" }, { k: "spring", v: "Spring" }, { k: "springboot", v: "SpringBoot" }, { k: "springcloud", v: "SpringCloud" }, { k: "sprintmvc", v: "SpringMVC" }, { k: "mybatis", v: "MyBatis" }, { k: "qq", v: "QQ" }, { k: "sql", v: "SQL" }]);
		blockStarts = new sliceType$2([(function $b(t, container) {
			var _r, container, marker, markers$1, t, whitespace, withSpace, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; container = $f.container; marker = $f.marker; markers$1 = $f.markers$1; t = $f.t; whitespace = $f.whitespace; withSpace = $f.withSpace; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented) { */ case 1:
				marker = peek(t.context.currentLine, t.context.nextNonspace);
				/* */ if (62 === marker) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (62 === marker) { */ case 3:
					markers$1 = new sliceType([marker]);
					t.context.advanceNextNonspace();
					t.context.advanceOffset(1, false);
					whitespace = peek(t.context.currentLine, t.context.offset);
					withSpace = (32 === whitespace) || (9 === whitespace);
					if (withSpace) {
						t.context.advanceOffset(1, true);
						markers$1 = $append(markers$1, whitespace);
					} else {
						if (t.context.option.VditorWYSIWYG) {
							$s = -1; return 0;
						}
					}
					$r = t.context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.context.addChild(5, t.context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_r;
					t.context.addChildMarker(6, markers$1);
					$s = -1; return 1;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.container = container; $f.marker = marker; $f.markers$1 = markers$1; $f.t = t; $f.whitespace = whitespace; $f.withSpace = withSpace; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, container, content, crosshatchMarker, heading, level, markers$1, ok, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; container = $f.container; content = $f.content; crosshatchMarker = $f.crosshatchMarker; heading = $f.heading; level = $f.level; markers$1 = $f.markers$1; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented) { */ case 1:
				_tuple = t.parseATXHeading();
				ok = _tuple[0];
				markers$1 = _tuple[1];
				content = _tuple[2];
				level = _tuple[3];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					t.context.advanceNextNonspace();
					t.context.advanceOffset(content.$length, false);
					$r = t.context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.context.addChild(2, t.context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					heading = _r;
					heading.headingLevel = level;
					heading.tokens = content;
					crosshatchMarker = new Node.ptr(3, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", markers$1, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, 0, false, "", "");
					heading.AppendChild(crosshatchMarker);
					t.context.advanceOffset(t.context.currentLineLen - t.context.offset >> 0, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.container = container; $f.content = content; $f.crosshatchMarker = crosshatchMarker; $f.heading = heading; $f.level = level; $f.markers$1 = markers$1; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, codeBlockFenceChar, codeBlockFenceLen, codeBlockFenceOffset, codeBlockInfo, codeBlockOpenFence, container, container$1, ok, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; codeBlockFenceChar = $f.codeBlockFenceChar; codeBlockFenceLen = $f.codeBlockFenceLen; codeBlockFenceOffset = $f.codeBlockFenceOffset; codeBlockInfo = $f.codeBlockInfo; codeBlockOpenFence = $f.codeBlockOpenFence; container = $f.container; container$1 = $f.container$1; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented) { */ case 1:
				_tuple = t.parseFencedCode();
				ok = _tuple[0];
				codeBlockFenceChar = _tuple[1];
				codeBlockFenceLen = _tuple[2];
				codeBlockFenceOffset = _tuple[3];
				codeBlockOpenFence = _tuple[4];
				codeBlockInfo = _tuple[5];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					$r = t.context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.context.addChild(11, t.context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					container$1 = _r;
					container$1.isFencedCodeBlock = true;
					container$1.codeBlockFenceLen = codeBlockFenceLen;
					container$1.codeBlockFenceChar = codeBlockFenceChar;
					container$1.codeBlockFenceOffset = codeBlockFenceOffset;
					container$1.codeBlockOpenFence = codeBlockOpenFence;
					container$1.codeBlockInfo = codeBlockInfo;
					t.context.advanceNextNonspace();
					t.context.advanceOffset(codeBlockFenceLen, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.codeBlockFenceChar = codeBlockFenceChar; $f.codeBlockFenceLen = codeBlockFenceLen; $f.codeBlockFenceOffset = codeBlockFenceOffset; $f.codeBlockInfo = codeBlockInfo; $f.codeBlockOpenFence = codeBlockOpenFence; $f.container = container; $f.container$1 = container$1; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, child, container, level, nextTr, remains, t, table, tokens, tr, value, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; child = $f.child; container = $f.container; level = $f.level; nextTr = $f.nextTr; remains = $f.remains; t = $f.t; table = $f.table; tokens = $f.tokens; tr = $f.tr; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented && (container.typ === 1)) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented && (container.typ === 1)) { */ case 1:
				level = t.parseSetextHeading();
				/* */ if (!((0 === level))) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (!((0 === level))) { */ case 3:
					if (t.context.option.GFMTable) {
						table = t.context.parseTable(container);
						if (!(ptrType.nil === table)) {
							container.typ = 106;
							container.tableAligns = table.tableAligns;
							tr = table.firstChild;
							while (true) {
								if (!(!(ptrType.nil === tr))) { break; }
								nextTr = tr.next;
								container.AppendChild(tr);
								tr = nextTr;
							}
							container.tokens = sliceType.nil;
							$s = -1; return 0;
						}
					}
					$r = t.context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					tokens = container.tokens;
					/* while (true) { */ case 6:
						/* if (!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { break; } */ if(!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { $s = 7; continue; }
						_r = t.context.parseLinkRefDef(tokens); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						remains = _r;
						if (!(sliceType.nil === remains)) {
							container.tokens = remains;
						} else {
							/* break; */ $s = 7; continue;
						}
						tokens = container.tokens;
					/* } */ $s = 6; continue; case 7:
					value = container.tokens;
					if (0 < value.$length) {
						child = new Node.ptr(2, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, "", sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, level, 0, false, "", "");
						child.tokens = trimWhitespace(value);
						container.InsertAfter(child);
						container.Unlink();
						t.context.tip = child;
						t.context.advanceOffset(t.context.currentLineLen - t.context.offset >> 0, false);
						$s = -1; return 2;
					}
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.child = child; $f.container = container; $f.level = level; $f.nextTr = nextTr; $f.remains = remains; $f.t = t; $f.table = table; $f.tokens = tokens; $f.tr = tr; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, block, container, htmlType, t, tokens, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; block = $f.block; container = $f.container; htmlType = $f.htmlType; t = $f.t; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented && (peek(t.context.currentLine, t.context.nextNonspace) === 60)) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented && (peek(t.context.currentLine, t.context.nextNonspace) === 60)) { */ case 1:
				tokens = $subslice(t.context.currentLine, t.context.nextNonspace);
				htmlType = t.parseHTML(tokens);
				/* */ if (!((0 === htmlType))) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (!((0 === htmlType))) { */ case 3:
					$r = t.context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.context.addChild(9, t.context.offset); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					block = _r;
					block.htmlBlockType = htmlType;
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.block = block; $f.container = container; $f.htmlType = htmlType; $f.t = t; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, container, markers$1, ok, t, thematicBreak, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; container = $f.container; markers$1 = $f.markers$1; ok = $f.ok; t = $f.t; thematicBreak = $f.thematicBreak; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented) { */ case 1:
				_tuple = t.parseThematicBreak();
				ok = _tuple[0];
				markers$1 = _tuple[1];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					$r = t.context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.context.addChild(4, t.context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					thematicBreak = _r;
					thematicBreak.tokens = markers$1;
					t.context.advanceOffset(t.context.currentLineLen - t.context.offset >> 0, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.container = container; $f.markers$1 = markers$1; $f.ok = ok; $f.t = t; $f.thematicBreak = thematicBreak; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _r$1, container, data, list, listItem, listsMatch, prev, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; container = $f.container; data = $f.data; list = $f.list; listItem = $f.listItem; listsMatch = $f.listsMatch; prev = $f.prev; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented || (container.typ === 7)) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented || (container.typ === 7)) { */ case 1:
				data = t.parseListMarker(container);
				if (ptrType$1.nil === data) {
					$s = -1; return 0;
				}
				$r = t.context.closeUnmatchedBlocks(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				listsMatch = (container.typ === 7) && t.context.listsMatch(container.listData, data);
				/* */ if (!((t.context.tip.typ === 7)) || !listsMatch) { $s = 4; continue; }
				/* */ $s = 5; continue;
				/* if (!((t.context.tip.typ === 7)) || !listsMatch) { */ case 4:
					_r = t.context.addChild(7, t.context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					list = _r;
					list.listData = data;
				/* } */ case 5:
				_r$1 = t.context.addChild(8, t.context.nextNonspace); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				listItem = _r$1;
				listItem.listData = data;
				listItem.tokens = data.marker;
				if (1 === listItem.listData.typ) {
					prev = listItem.previous;
					if (!(ptrType.nil === prev)) {
						listItem.listData.num = prev.listData.num + 1 >> 0;
					} else {
						listItem.listData.num = data.start;
					}
				}
				$s = -1; return 1;
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f.container = container; $f.data = data; $f.list = list; $f.listItem = listItem; $f.listsMatch = listsMatch; $f.prev = prev; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, block, container, mathBlockDollarOffset, ok, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; block = $f.block; container = $f.container; mathBlockDollarOffset = $f.mathBlockDollarOffset; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.context.indented) { */ case 1:
				_tuple = t.parseMathBlock();
				ok = _tuple[0];
				mathBlockDollarOffset = _tuple[1];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					$r = t.context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.context.addChild(300, t.context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					block = _r;
					block.mathBlockDollarOffset = mathBlockDollarOffset;
					t.context.advanceNextNonspace();
					t.context.advanceOffset(mathBlockDollarOffset, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.block = block; $f.container = container; $f.mathBlockDollarOffset = mathBlockDollarOffset; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, container, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; container = $f.container; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (t.context.indented && !((t.context.tip.typ === 1)) && !t.context.blank) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (t.context.indented && !((t.context.tip.typ === 1)) && !t.context.blank) { */ case 1:
				t.context.advanceOffset(4, true);
				$r = t.context.closeUnmatchedBlocks(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_r = t.context.addChild(11, t.context.offset); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_r;
				$s = -1; return 2;
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.container = container; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		})]);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/b3log/lute/javascript"] = (function() {
	var $pkg = {}, $init, lute, js, sliceType, mapType, ptrType, funcType, New, main;
	lute = $packages["github.com/b3log/lute"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	sliceType = $sliceType(lute.option);
	mapType = $mapType($String, $emptyInterface);
	ptrType = $ptrType(js.Object);
	funcType = $funcType([], [ptrType], false);
	New = function() {
		var _r, _r$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = lute.New(new sliceType([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = js.MakeWrapper(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: New }; } $f._r = _r; $f._r$1 = _r$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.New = New;
	main = function() {
		var l;
		$global.Lute = $externalize({}, mapType);
		l = $global.Lute;
		l.New = $externalize(New, funcType);
	};
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = lute.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if ($pkg === $mainPkg) {
			main();
			$mainFinished = true;
		}
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$synthesizeMethods();
var $mainPkg = $packages["github.com/b3log/lute/javascript"];
$packages["runtime"].$init();
$go($mainPkg.$init, []);
$flushConsole();

}).call(this);
//# sourceMappingURL=lute.min.js.map
